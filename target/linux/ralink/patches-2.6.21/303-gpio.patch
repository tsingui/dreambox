Index: linux-2.6.21/arch/mips/rt2880/Makefile
===================================================================
--- linux-2.6.21.orig/arch/mips/rt2880/Makefile	2009-07-21 12:47:07.000000000 +0200
+++ linux-2.6.21/arch/mips/rt2880/Makefile	2009-07-21 12:47:07.000000000 +0200
@@ -14,7 +14,8 @@
 	$(CC) $(CFLAGS) -c $< -o $*.o
 
 obj-y    := mipsIRQ.o reset.o init.o irq.o \
-            memory.o printf.o cmdline.o setup.o time.o board.o
+            memory.o printf.o cmdline.o setup.o time.o \
+			board.o gpio.o
 obj-$(CONFIG_PCI) += pci.o
 obj-y += lm.o
 
Index: linux-2.6.21/arch/mips/rt2880/gpio.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/gpio.c	2009-07-21 12:47:58.000000000 +0200
@@ -0,0 +1,195 @@
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <net/sock.h>
+#include <asm/uaccess.h>
+#include <linux/string.h>
+#include "gpio.h"
+#include <asm/rt2880/surfboardint.h>
+#include <linux/proc_fs.h>
+
+struct proc_dir_entry *gpio_proc;
+
+ramips_gpio_reg_info ramips_gpio_info[RALINK_GPIO_NUMBER];
+extern unsigned long volatile jiffies;
+
+ramips_gpio_reg_info info;
+
+static inline void add_msg(struct sk_buff *skb, char *msg)
+{
+	char *scratch;
+	scratch = skb_put(skb, strlen(msg) + 1);
+	sprintf(scratch, msg);
+}
+
+extern struct sock *uevent_sock;
+extern u64 uevent_next_seqnum(void);
+
+static void hotplug_button(char *name, int seen)
+{
+	struct sk_buff *skb;
+	size_t len;
+	char *scratch, *s;
+	char buf[128];
+
+	if (!uevent_sock)
+		goto done;
+
+	/* allocate message with the maximum possible size */
+	s = (seen > 0) ?  "released" : "pressed";
+	len = strlen(s) + 2;
+	skb = alloc_skb(len + 2048, GFP_KERNEL);
+	if (!skb)
+		goto done;
+
+	/* add header */
+	scratch = skb_put(skb, len);
+	sprintf(scratch, "%s@",s);
+
+	/* copy keys to our continuous event payload buffer */
+	add_msg(skb, "HOME=/");
+	add_msg(skb, "PATH=/sbin:/bin:/usr/sbin:/usr/bin");
+	add_msg(skb, "SUBSYSTEM=button");
+	snprintf(buf, 128, "BUTTON=%s", name);
+	add_msg(skb, buf);
+	snprintf(buf, 128, "SEQNUM=%llu", uevent_next_seqnum());
+	add_msg(skb, buf);
+	add_msg(skb, (seen ? "ACTION=released" : "ACTION=pressed"));
+	snprintf(buf, 128, "SEEN=%d", seen / 100);
+	add_msg(skb, buf);
+
+	NETLINK_CB(skb).dst_group = 1;
+	netlink_broadcast(uevent_sock, skb, 0, 1, GFP_KERNEL);
+done:
+	return;
+}
+
+irqreturn_t
+ramips_gpio_irq_handler(int irq, void *irqaction)
+{
+	u32 ramips_gpio_intp = 0;
+	int ramips_gpio_irqnum = 0;
+	u32 ramips_gpio_edge = 0;
+	struct gpio_time_record {
+		unsigned long falling;
+		unsigned long rising;
+	};
+	static struct gpio_time_record record[RALINK_GPIO_NUMBER];
+	unsigned long now;
+	int i;
+
+	ramips_gpio_intp = le32_to_cpu(*(volatile u32 *)(RALINK_REG_PIOINT));
+	ramips_gpio_edge = le32_to_cpu(*(volatile u32 *)(RALINK_REG_PIOEDGE));
+	*(volatile u32 *)(RALINK_REG_PIOINT) = cpu_to_le32(0x00FFFFFF);
+	*(volatile u32 *)(RALINK_REG_PIOEDGE) = cpu_to_le32(0x00FFFFFF);
+	now = jiffies;
+	for (i = 0; i < RALINK_GPIO_NUMBER; i++) {
+		if (! (ramips_gpio_intp & (1 << i)))
+			continue;
+		ramips_gpio_irqnum = i;
+		if (ramips_gpio_edge & (1 << i)) { //rising edge
+			if (record[i].rising != 0 && time_before_eq(now, record[i].rising + 30L)) {
+			} else {
+				record[i].rising = now;
+				hotplug_button(ramips_gpio_info[i].name, now - record[i].falling);
+			}
+		} else { //falling edge
+			if((now - record[i].rising > 2) && (now - record[i].falling > 2))
+				hotplug_button(ramips_gpio_info[i].name, 0);
+			record[i].falling = now;
+		}
+		break;
+	}
+
+	return IRQ_HANDLED;
+
+}
+
+struct irqaction ramips_gpio_irqaction = {
+	.handler = ramips_gpio_irq_handler,
+	.flags = SA_INTERRUPT,
+	.mask = 0,
+	.name = "ramips_gpio",
+};
+
+void
+ramips_gpio_enable_int(int gpio, char *name)
+{
+	u32 tmp;
+	tmp = le32_to_cpu(*(volatile u32 *)(RALINK_REG_PIODIR));
+	tmp &= ~cpu_to_le32(1 << gpio);
+	*(volatile u32 *)(RALINK_REG_PIODIR) = tmp;
+	tmp = le32_to_cpu(*(volatile u32 *)(RALINK_REG_PIORENA));
+	tmp |= (0x1 << gpio);
+	*(volatile u32 *)(RALINK_REG_PIORENA) = cpu_to_le32(tmp);
+	tmp = le32_to_cpu(*(volatile u32 *)(RALINK_REG_PIOFENA));
+	tmp |= (0x1 << gpio);
+	*(volatile u32 *)(RALINK_REG_PIOFENA) = cpu_to_le32(tmp);
+	ramips_gpio_info[gpio].name = kstrdup(name, GFP_KERNEL);
+}
+
+int
+procfile_read(char *buffer,
+	char **buffer_location,
+	off_t offset, int buffer_length, int *eof, void *data)
+{
+	int ret;
+	if (offset > 0) {
+		ret  = 0;
+	} else {
+		if(le32_to_cpu(*(volatile u32 *)(RALINK_REG_PIODATA)) & (1 << 13))
+			ret = sprintf(buffer, "1");
+		else
+			ret = sprintf(buffer, "0");
+	}
+	return ret;
+}
+
+int __init
+ramips_gpio_init(void)
+{
+	unsigned int i;
+	u32 gpiomode;
+
+	// GPIO pin mode
+	gpiomode = le32_to_cpu(*(volatile u32 *)(RALINK_REG_GPIOMODE));
+	gpiomode |= RALINK_GPIOMODE_DFT;
+	*(volatile u32 *)(RALINK_REG_GPIOMODE) = cpu_to_le32(gpiomode);
+
+	// Enable irqs
+	*(volatile u32 *)(RALINK_REG_INTENA) = cpu_to_le32(RALINK_INTCTL_PIO);
+	for(i = 0; i < RALINK_GPIO_NUMBER; i++)
+	{
+		ramips_gpio_info[i].irq = i;
+		ramips_gpio_info[i].pid = 0;
+	}
+
+	ramips_gpio_enable_int(12, "reset");
+	ramips_gpio_enable_int(13, "switch");
+
+	setup_irq(SURFBOARDINT_GPIO, &ramips_gpio_irqaction);
+
+	gpio_proc = create_proc_entry("gpio_switch", 0644, NULL);
+	gpio_proc->read_proc = procfile_read;
+	gpio_proc->owner = THIS_MODULE;
+	gpio_proc->mode = S_IFREG | S_IRUGO;
+	gpio_proc->uid = 0;
+	gpio_proc->gid = 0;
+	gpio_proc->size = 37;
+
+
+	printk("ramips_gpio: done\n");
+
+	return 0;
+}
+
+module_init(ramips_gpio_init);
+
+MODULE_DESCRIPTION("ramips gpio");
+MODULE_AUTHOR("John Crispin <john@phrozen.org>");
+MODULE_LICENSE("GPL");
Index: linux-2.6.21/arch/mips/rt2880/gpio.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/gpio.h	2009-07-21 12:47:07.000000000 +0200
@@ -0,0 +1,188 @@
+/*
+ ***************************************************************************
+ * Ralink Tech Inc.
+ * 4F, No. 2 Technology 5th Rd.
+ * Science-based Industrial Park
+ * Hsin-chu, Taiwan, R.O.C.
+ *
+ * (c) Copyright, Ralink Technology, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ ***************************************************************************
+ */
+
+#ifndef __RALINK_GPIO_H__
+#define __RALINK_GPIO_H__
+
+#include <asm/rt2880/rt_mmap.h>
+
+/*
+ * ioctl commands
+ */
+#define	RALINK_GPIO_SET_DIR		0x01
+#define RALINK_GPIO_SET_DIR_IN		0x11
+#define RALINK_GPIO_SET_DIR_OUT		0x12
+#define	RALINK_GPIO_READ		0x02
+#define	RALINK_GPIO_WRITE		0x03
+#define	RALINK_GPIO_SET			0x21
+#define	RALINK_GPIO_CLEAR		0x31
+#define	RALINK_GPIO_READ_BIT		0x04
+#define	RALINK_GPIO_WRITE_BIT		0x05
+#define	RALINK_GPIO_READ_BYTE		0x06
+#define	RALINK_GPIO_WRITE_BYTE		0x07
+#define	RALINK_GPIO_READ_INT		0x02 //same as read
+#define	RALINK_GPIO_WRITE_INT		0x03 //same as write
+#define	RALINK_GPIO_SET_INT		0x21 //same as set
+#define	RALINK_GPIO_CLEAR_INT		0x31 //same as clear
+#define RALINK_GPIO_ENABLE_INTP		0x08
+#define RALINK_GPIO_DISABLE_INTP	0x09
+#define RALINK_GPIO_REG_IRQ		0x0A
+#define RALINK_GPIO_LED_SET		0x41
+
+
+/*
+ * Address of RALINK_ Registers
+ */
+#define RALINK_SYSCTL_ADDR		RALINK_SYSCTL_BASE	// system control
+#define RALINK_REG_GPIOMODE		(RALINK_SYSCTL_ADDR + 0x60)
+
+#define RALINK_IRQ_ADDR			RALINK_INTCL_BASE
+#define RALINK_REG_INTENA		(RALINK_IRQ_ADDR + 0x34)
+#define RALINK_REG_INTDIS		(RALINK_IRQ_ADDR + 0x38)
+
+#define RALINK_PRGIO_ADDR		RALINK_PIO_BASE // Programmable I/O
+#define RALINK_REG_PIOINT		(RALINK_PRGIO_ADDR + 0)
+#define RALINK_REG_PIOEDGE		(RALINK_PRGIO_ADDR + 0x04)
+#define RALINK_REG_PIORENA		(RALINK_PRGIO_ADDR + 0x08)
+#define RALINK_REG_PIOFENA		(RALINK_PRGIO_ADDR + 0x0C)
+#define RALINK_REG_PIODATA		(RALINK_PRGIO_ADDR + 0x20)
+#define RALINK_REG_PIODIR		(RALINK_PRGIO_ADDR + 0x24)
+#define RALINK_REG_PIOSET		(RALINK_PRGIO_ADDR + 0x2C)
+#define RALINK_REG_PIORESET		(RALINK_PRGIO_ADDR + 0x30)
+#define RALINK_REG_PIOTOGGLE		(RALINK_PRGIO_ADDR + 0x34)
+#define RALINK_REG_PIO3924INT		(RALINK_PRGIO_ADDR + 0x38)
+#define RALINK_REG_PIO3924EDGE		(RALINK_PRGIO_ADDR + 0x3C)
+#define RALINK_REG_PIO3924RENA		(RALINK_PRGIO_ADDR + 0x40)
+#define RALINK_REG_PIO3924FENA		(RALINK_PRGIO_ADDR + 0x44)
+#define RALINK_REG_PIO3924DATA		(RALINK_PRGIO_ADDR + 0x48)
+#define RALINK_REG_PIO3924DIR		(RALINK_PRGIO_ADDR + 0x4C)
+#define RALINK_REG_PIO3924SET		(RALINK_PRGIO_ADDR + 0x54)
+#define RALINK_REG_PIO3924RESET		(RALINK_PRGIO_ADDR + 0x58)
+#define RALINK_REG_PIO3924TOGGLE	(RALINK_PRGIO_ADDR + 0x5C)
+#define RALINK_REG_PIO5140INT		(RALINK_PRGIO_ADDR + 0x60)
+#define RALINK_REG_PIO5140EDGE		(RALINK_PRGIO_ADDR + 0x64)
+#define RALINK_REG_PIO5140RENA		(RALINK_PRGIO_ADDR + 0x68)
+#define RALINK_REG_PIO5140FENA		(RALINK_PRGIO_ADDR + 0x6C)
+#define RALINK_REG_PIO5140DATA		(RALINK_PRGIO_ADDR + 0x70)
+#define RALINK_REG_PIO5140DIR		(RALINK_PRGIO_ADDR + 0x74)
+#define RALINK_REG_PIO5140SET		(RALINK_PRGIO_ADDR + 0x7C)
+#define RALINK_REG_PIO5140RESET		(RALINK_PRGIO_ADDR + 0x80)
+#define RALINK_REG_PIO5140TOGGLE	(RALINK_PRGIO_ADDR + 0x84)
+
+
+/*
+ * Values for the GPIOMODE Register
+ */
+#ifdef CONFIG_RALINK_RT2880
+#define RALINK_GPIOMODE_I2C		0x01
+#define RALINK_GPIOMODE_UARTF		0x02
+#define RALINK_GPIOMODE_SPI		0x04
+#define RALINK_GPIOMODE_UARTL		0x08
+#define RALINK_GPIOMODE_JTAG		0x10
+#define RALINK_GPIOMODE_MDIO		0x20
+#define RALINK_GPIOMODE_SDRAM		0x40
+#define RALINK_GPIOMODE_PCI		0x80
+#elif defined (CONFIG_RALINK_RT3052) || defined (CONFIG_RALINK_RT2883)
+#define RALINK_GPIOMODE_I2C		0x01
+#define RALINK_GPIOMODE_SPI		0x02
+#define RALINK_GPIOMODE_UARTF		0x1C
+#define RALINK_GPIOMODE_UARTL		0x20
+#define RALINK_GPIOMODE_JTAG		0x40
+#define RALINK_GPIOMODE_MDIO		0x80
+#define RALINK_GPIOMODE_SDRAM		0x100
+#define RALINK_GPIOMODE_RGMII		0x200
+#endif
+
+// if you would like to enable GPIO mode for other pins, please modify this value
+// !! Warning: changing this value may make other features(MDIO, PCI, etc) lose efficacy
+#define RALINK_GPIOMODE_DFT		(RALINK_GPIOMODE_UARTF)
+
+/*
+ * bit is the unit of length
+ */
+#define RALINK_GPIO_NUMBER		24
+#define RALINK_GPIO_DATA_MASK		0x00FFFFFF
+#define RALINK_GPIO_DATA_LEN		24
+#define RALINK_GPIO_DIR_IN		0
+#define RALINK_GPIO_DIR_OUT		1
+#define RALINK_GPIO_DIR_ALLIN		0
+#define RALINK_GPIO_DIR_ALLOUT		0x00FFFFFF
+
+/*
+ * structure used at regsitration
+ */
+typedef struct {
+	unsigned int irq;		//request irq pin number
+	pid_t pid;			//process id to notify
+	char *name;
+} ramips_gpio_reg_info;
+
+#define RALINK_GPIO_LED_LOW_ACT		1
+#define RALINK_GPIO_LED_INFINITY	4000
+typedef struct {
+	int gpio;			//gpio number (0 ~ 23)
+	unsigned int on;		//interval of led on
+	unsigned int off;		//interval of led off
+	unsigned int blinks;		//number of blinking cycles
+	unsigned int rests;		//number of break cycles
+	unsigned int times;		//blinking times
+} ramips_gpio_led_info;
+
+
+#define RALINK_GPIO_0			0x00000001
+#define RALINK_GPIO_1			0x00000002
+#define RALINK_GPIO_2			0x00000004
+#define RALINK_GPIO_3			0x00000008
+#define RALINK_GPIO_4			0x00000010
+#define RALINK_GPIO_5			0x00000020
+#define RALINK_GPIO_6			0x00000040
+#define RALINK_GPIO_7			0x00000080
+#define RALINK_GPIO_8			0x00000100
+#define RALINK_GPIO_9			0x00000200
+#define RALINK_GPIO_10			0x00000400
+#define RALINK_GPIO_11			0x00000800
+#define RALINK_GPIO_12			0x00001000
+#define RALINK_GPIO_13			0x00002000
+#define RALINK_GPIO_14			0x00004000
+#define RALINK_GPIO_15			0x00008000
+#define RALINK_GPIO_16			0x00010000
+#define RALINK_GPIO_17			0x00020000
+#define RALINK_GPIO_18			0x00040000
+#define RALINK_GPIO_19			0x00080000
+#define RALINK_GPIO_20			0x00100000
+#define RALINK_GPIO_21			0x00200000
+#define RALINK_GPIO_22			0x00400000
+#define RALINK_GPIO_23			0x00800000
+#define RALINK_GPIO(x)			(1 << x)
+
+#endif
