Index: linux-2.6.21/drivers/usb/serial/usb-serial.c
===================================================================
--- linux-2.6.21.orig/drivers/usb/serial/usb-serial.c	2007-04-26 05:08:32.000000000 +0200
+++ linux-2.6.21/drivers/usb/serial/usb-serial.c	2009-07-17 15:59:33.000000000 +0200
@@ -34,6 +34,75 @@
 #include <linux/usb/serial.h>
 #include "pl2303.h"
 
+
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/kobject.h>
+#include <linux/workqueue.h>
+#include <linux/skbuff.h>
+#include <linux/netlink.h>
+#include <net/sock.h>
+#include <asm/uaccess.h>
+
+struct event_t {
+    struct work_struct wq;
+    int set;
+    unsigned long jiffies;
+};
+
+static inline void add_msg_usb(struct sk_buff *skb, char *msg)
+{
+   char *scratch;
+   scratch = skb_put(skb, strlen(msg) + 1);
+   sprintf(scratch, msg);
+}
+
+extern struct sock *uevent_sock;
+extern u64 uevent_next_seqnum(void);
+
+static void hotplug_ttyusb(int connect, char *node, char *driver, int vid, int pid)
+{
+	struct sk_buff *skb;
+	size_t len;
+	char *scratch, *s;
+	char buf[128];
+
+	if (!uevent_sock)
+		goto done;
+
+	/* allocate message with the maximum possible size */
+	s = connect ? "add" : "remove";
+	len = strlen(s) + 2;
+	skb = alloc_skb(len + 2048, GFP_KERNEL);
+	if (!skb)
+		goto done;
+
+	/* add header */
+	scratch = skb_put(skb, len);
+	sprintf(scratch, "%s@",s);
+
+	/* copy keys to our continuous event payload buffer */
+	add_msg_usb(skb, "HOME=/");
+	add_msg_usb(skb, "PATH=/sbin:/bin:/usr/sbin:/usr/bin");
+	add_msg_usb(skb, "SUBSYSTEM=ttyusb");
+	add_msg_usb(skb, (connect ? "ACTION=add" : "ACTION=remove"));
+	snprintf(buf, 128, "SEQNUM=%llu", uevent_next_seqnum());
+	add_msg_usb(skb, buf);
+	snprintf(buf, 128, "NODE=%s", node);
+	add_msg_usb(skb, buf);
+	snprintf(buf, 128, "DRIVER=%s", driver);
+	add_msg_usb(skb, buf);
+	snprintf(buf, 128, "VIDPID=%04X%04X", vid, pid);
+	add_msg_usb(skb, buf);
+	printk("ttyusb -> %d %s %s %04X%04X\n",
+		connect, node, driver, vid, pid);
+	NETLINK_CB(skb).dst_group = 1;
+	netlink_broadcast(uevent_sock, skb, 0, 1, GFP_KERNEL);
+done:
+	return;
+}
+
 /*
  * Version Information
  */
@@ -997,6 +1066,10 @@
 		if (retval)
 			dev_err(&port->dev, "Error registering port device, "
 				"continuing\n");
+		else
+			hotplug_ttyusb(1, port->dev.bus_id, module_name(serial->type->driver.owner),
+				le16_to_cpu(serial->dev->descriptor.idVendor),
+				le16_to_cpu(serial->dev->descriptor.idProduct));
 	}
 
 	usb_serial_console_init (debug, minor);
@@ -1058,6 +1131,9 @@
 		for (i = 0; i < serial->num_ports; ++i) {
 			port = serial->port[i];
 			if (port) {
+				hotplug_ttyusb(0, port->dev.bus_id, module_name(serial->type->driver.owner),
+				le16_to_cpu(serial->dev->descriptor.idVendor),
+				le16_to_cpu(serial->dev->descriptor.idProduct));
 				if (port->tty)
 					tty_hangup(port->tty);
 				kill_traffic(port);
