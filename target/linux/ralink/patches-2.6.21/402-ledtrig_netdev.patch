Index: linux-2.6.21/drivers/leds/Kconfig
===================================================================
--- linux-2.6.21.orig/drivers/leds/Kconfig	2009-08-25 09:35:51.000000000 +0200
+++ linux-2.6.21/drivers/leds/Kconfig	2009-08-25 09:35:54.000000000 +0200
@@ -131,5 +131,12 @@
 	  load average.
 	  If unsure, say Y.
 
+config LEDS_TRIGGER_NETDEV
+	tristate "LED Netdev Trigger"
+	depends on LEDS_TRIGGERS
+	help
+	  This allows LEDs to be controlled by network device activity.
+	  If unsure, say Y.
+
 endmenu
 
Index: linux-2.6.21/drivers/leds/Makefile
===================================================================
--- linux-2.6.21.orig/drivers/leds/Makefile	2009-08-25 09:35:51.000000000 +0200
+++ linux-2.6.21/drivers/leds/Makefile	2009-08-25 09:35:54.000000000 +0200
@@ -22,3 +22,4 @@
 obj-$(CONFIG_LEDS_TRIGGER_TIMER)	+= ledtrig-timer.o
 obj-$(CONFIG_LEDS_TRIGGER_IDE_DISK)	+= ledtrig-ide-disk.o
 obj-$(CONFIG_LEDS_TRIGGER_HEARTBEAT)	+= ledtrig-heartbeat.o
+obj-$(CONFIG_LEDS_TRIGGER_NETDEV)      += ledtrig-netdev.o
Index: linux-2.6.21/drivers/leds/ledtrig-netdev.c
===================================================================
--- linux-2.6.21.orig/drivers/leds/ledtrig-netdev.c	2009-08-25 09:35:51.000000000 +0200
+++ linux-2.6.21/drivers/leds/ledtrig-netdev.c	2009-08-25 09:37:21.000000000 +0200
@@ -46,7 +46,7 @@
  *   link: LED's normal state reflects whether the link is up (has carrier) or not
  *   tx:   LED blinks on transmitted data
  *   rx:   LED blinks on receive data
- * 
+ *
  * Some suggestions:
  *
  *  Simple link status LED:
@@ -102,10 +102,9 @@
 		del_timer(&trigger_data->timer);
 }
 
-static ssize_t led_device_name_show(struct device *dev,
-				    struct device_attribute *attr, char *buf)
+static ssize_t led_device_name_show(struct class_device *dev, char *buf)
 {
-	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_classdev *led_cdev = class_get_devdata(dev);
 	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
 
 	read_lock(&trigger_data->lock);
@@ -119,10 +118,9 @@
 extern struct net init_net;
 #endif
 
-static ssize_t led_device_name_store(struct device *dev,
-				     struct device_attribute *attr, const char *buf, size_t size)
+static ssize_t led_device_name_store(struct class_device *dev, const char *buf, size_t size)
 {
-	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_classdev *led_cdev = class_get_devdata(dev);
 	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
 
 	if (size < 0 || size >= IFNAMSIZ)
@@ -150,12 +148,11 @@
 	return size;
 }
 
-static DEVICE_ATTR(device_name, 0644, led_device_name_show, led_device_name_store);
+static CLASS_DEVICE_ATTR(device_name, 0644, led_device_name_show, led_device_name_store);
 
-static ssize_t led_mode_show(struct device *dev,
-			     struct device_attribute *attr, char *buf)
+static ssize_t led_mode_show(struct class_device *dev, char *buf)
 {
-	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_classdev *led_cdev = class_get_devdata(dev);
 	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
 
 	read_lock(&trigger_data->lock);
@@ -177,10 +174,9 @@
 	return strlen(buf)+1;
 }
 
-static ssize_t led_mode_store(struct device *dev,
-			      struct device_attribute *attr, const char *buf, size_t size)
+static ssize_t led_mode_store(struct class_device *dev, const char *buf, size_t size)
 {
-	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_classdev *led_cdev = class_get_devdata(dev);
 	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
 	char copybuf[1024];
 	int new_mode = -1;
@@ -221,12 +217,11 @@
 	return size;
 }
 
-static DEVICE_ATTR(mode, 0644, led_mode_show, led_mode_store);
+static CLASS_DEVICE_ATTR(mode, 0644, led_mode_show, led_mode_store);
 
-static ssize_t led_interval_show(struct device *dev,
-				 struct device_attribute *attr, char *buf)
+static ssize_t led_interval_show(struct class_device *dev, char *buf)
 {
-	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_classdev *led_cdev = class_get_devdata(dev);
 	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
 
 	read_lock(&trigger_data->lock);
@@ -236,10 +231,9 @@
 	return strlen(buf) + 1;
 }
 
-static ssize_t led_interval_store(struct device *dev,
-				  struct device_attribute *attr, const char *buf, size_t size)
+static ssize_t led_interval_store(struct class_device *dev, const char *buf, size_t size)
 {
-	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct led_classdev *led_cdev = class_get_devdata(dev);
 	struct led_netdev_data *trigger_data = led_cdev->trigger_data;
 	int ret = -EINVAL;
 	char *after;
@@ -261,7 +255,7 @@
 	return ret;
 }
 
-static DEVICE_ATTR(interval, 0644, led_interval_show, led_interval_store);
+static CLASS_DEVICE_ATTR(interval, 0644, led_interval_show, led_interval_store);
 
 static int netdev_trig_notify(struct notifier_block *nb,
 			      unsigned long evt,
@@ -329,19 +323,19 @@
 
 		/* OFF -> ON always */
 		/* ON -> OFF on activity */
-		if (trigger_data->led_cdev->brightness == LED_OFF) {
-			led_set_brightness(trigger_data->led_cdev, LED_FULL);
-		} else if (trigger_data->last_activity != new_activity) {
+		if (trigger_data->led_cdev->brightness == LED_FULL) {
 			led_set_brightness(trigger_data->led_cdev, LED_OFF);
+		} else if (trigger_data->last_activity != new_activity) {
+			led_set_brightness(trigger_data->led_cdev, LED_FULL);
 		}
 	} else {
 		/* base state is OFF */
 		/* ON -> OFF always */
 		/* OFF -> ON on activity */
-		if (trigger_data->led_cdev->brightness == LED_FULL) {
-			led_set_brightness(trigger_data->led_cdev, LED_OFF);
-		} else if (trigger_data->last_activity != new_activity) {
+		if (trigger_data->led_cdev->brightness == LED_OFF) {
 			led_set_brightness(trigger_data->led_cdev, LED_FULL);
+		} else if (trigger_data->last_activity != new_activity) {
+			led_set_brightness(trigger_data->led_cdev, LED_OFF);
 		}
 	}
 
@@ -379,13 +373,13 @@
 
 	led_cdev->trigger_data = trigger_data;
 
-	rc = device_create_file(led_cdev->dev, &dev_attr_device_name);
+	rc = class_device_create_file(led_cdev->class_dev, &class_device_attr_device_name);
 	if (rc)
 		goto err_out;
-	rc = device_create_file(led_cdev->dev, &dev_attr_mode);
+	rc = class_device_create_file(led_cdev->class_dev, &class_device_attr_mode);
 	if (rc)
 		goto err_out_device_name;
-	rc = device_create_file(led_cdev->dev, &dev_attr_interval);
+	rc = class_device_create_file(led_cdev->class_dev, &class_device_attr_interval);
 	if (rc)
 		goto err_out_mode;
 
@@ -393,9 +387,9 @@
 	return;
 
 err_out_mode:
-	device_remove_file(led_cdev->dev, &dev_attr_mode);
+	class_device_remove_file(led_cdev->class_dev, &class_device_attr_mode);
 err_out_device_name:
-	device_remove_file(led_cdev->dev, &dev_attr_device_name);
+	class_device_remove_file(led_cdev->class_dev, &class_device_attr_device_name);
 err_out:
 	led_cdev->trigger_data = NULL;
 	kfree(trigger_data);
@@ -408,9 +402,9 @@
 	if (trigger_data) {
 		unregister_netdevice_notifier(&trigger_data->notifier);
 
-		device_remove_file(led_cdev->dev, &dev_attr_device_name);
-		device_remove_file(led_cdev->dev, &dev_attr_mode);
-		device_remove_file(led_cdev->dev, &dev_attr_interval);
+		class_device_remove_file(led_cdev->class_dev, &class_device_attr_device_name);
+		class_device_remove_file(led_cdev->class_dev, &class_device_attr_mode);
+		class_device_remove_file(led_cdev->class_dev, &class_device_attr_interval);
 
 		write_lock(&trigger_data->lock);
 
