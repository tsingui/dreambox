Index: linux-2.6.21/arch/mips/Kconfig
===================================================================
--- linux-2.6.21.orig/arch/mips/Kconfig	2009-11-30 12:44:55.000000000 +0100
+++ linux-2.6.21/arch/mips/Kconfig	2009-11-30 12:44:56.000000000 +0100
@@ -8,833 +8,55 @@
 
 menu "Machine selection"
 
+
 config ZONE_DMA
 	bool
 	default y
 
+config RALINK_RT2880_MP
+	bool
+config RALINK_RT2880_SHUTTLE
+	bool
+config RALINK_RT3052_MP2
+	bool
 choice
 	prompt "System type"
-	default SGI_IP22
-
-config MIPS_MTX1
-	bool "4G Systems MTX-1 board"
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select RESOURCES_64BIT if PCI
-	select SOC_AU1500
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_BOSPORUS
-	bool "AMD Alchemy Bosporus board"
-	select SOC_AU1500
-	select DMA_NONCOHERENT
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_PB1000
-	bool "AMD Alchemy PB1000 board"
-	select SOC_AU1000
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select RESOURCES_64BIT if PCI
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_PB1100
-	bool "AMD Alchemy PB1100 board"
-	select SOC_AU1100
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select RESOURCES_64BIT if PCI
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_PB1500
-	bool "AMD Alchemy PB1500 board"
-	select SOC_AU1500
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select RESOURCES_64BIT if PCI
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_PB1550
-	bool "AMD Alchemy PB1550 board"
-	select SOC_AU1550
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select MIPS_DISABLE_OBSOLETE_IDE
-	select RESOURCES_64BIT if PCI
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_PB1200
-	bool "AMD Alchemy PB1200 board"
-	select SOC_AU1200
-	select DMA_NONCOHERENT
-	select MIPS_DISABLE_OBSOLETE_IDE
-	select RESOURCES_64BIT if PCI
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_DB1000
-	bool "AMD Alchemy DB1000 board"
-	select SOC_AU1000
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select RESOURCES_64BIT if PCI
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config MIPS_DB1100
-	bool "AMD Alchemy DB1100 board"
-	select SOC_AU1100
+config RALINK_RT2880
+        bool "Ralink RT2880 board"
 	select DMA_NONCOHERENT
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_DB1500
-	bool "AMD Alchemy DB1500 board"
-	select SOC_AU1500
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select MIPS_DISABLE_OBSOLETE_IDE
-	select RESOURCES_64BIT if PCI
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_DB1550
-	bool "AMD Alchemy DB1550 board"
-	select SOC_AU1550
-	select HW_HAS_PCI
-	select DMA_NONCOHERENT
-	select MIPS_DISABLE_OBSOLETE_IDE
-	select RESOURCES_64BIT if PCI
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_DB1200
-	bool "AMD Alchemy DB1200 board"
-	select SOC_AU1200
-	select DMA_COHERENT
-	select MIPS_DISABLE_OBSOLETE_IDE
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config MIPS_MIRAGE
-	bool "AMD Alchemy Mirage board"
-	select DMA_NONCOHERENT
-	select SOC_AU1500
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config BASLER_EXCITE
-	bool "Basler eXcite smart camera"
-	select DMA_COHERENT
-	select HW_HAS_PCI
 	select IRQ_CPU
-	select IRQ_CPU_RM7K
-	select IRQ_CPU_RM9K
-	select MIPS_RM9122
-	select SYS_HAS_CPU_RM9000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_KGDB
-	help
-	  The eXcite is a smart camera platform manufactured by
-	  Basler Vision Technologies AG.
-
-config BASLER_EXCITE_PROTOTYPE
-	bool "Support for pre-release units"
-	depends on BASLER_EXCITE
-	default n
-	help
-	  Pre-series (prototype) units are different from later ones in
-	  some ways. Select this option if you have one of these. Please
-	  note that a kernel built with this option selected will not be
-	  able to run on normal units.
-
-config MIPS_COBALT
-	bool "Cobalt Server"
-	select DMA_NONCOHERENT
 	select HW_HAS_PCI
-	select I8259
-	select IRQ_CPU
-	select MIPS_GT64111
-	select SYS_HAS_CPU_NEVADA
-	select SYS_HAS_EARLY_PRINTK
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-
-config MACH_DECSTATION
-	bool "DECstations"
-	select BOOT_ELF32
-	select DMA_NONCOHERENT
-	select SYS_HAS_EARLY_PRINTK
-	select IRQ_CPU
-	select SYS_HAS_CPU_R3000
-	select SYS_HAS_CPU_R4X00
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_SUPPORTS_128HZ
-	select SYS_SUPPORTS_256HZ
-	select SYS_SUPPORTS_1024HZ
-	help
-	  This enables support for DEC's MIPS based workstations.  For details
-	  see the Linux/MIPS FAQ on <http://www.linux-mips.org/> and the
-	  DECstation porting pages on <http://decstation.unix-ag.org/>.
-
-	  If you have one of the following DECstation Models you definitely
-	  want to choose R4xx0 for the CPU Type:
-
-	  	DECstation 5000/50
-	  	DECstation 5000/150
-	  	DECstation 5000/260
-	  	DECsystem 5900/260
-
-	  otherwise choose R3000.
-
-config MIPS_EV64120
-	bool "Galileo EV64120 Evaluation board (EXPERIMENTAL)"
-	depends on EXPERIMENTAL
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select MIPS_GT64120
-	select SYS_HAS_CPU_R5000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_KGDB
-	help
-	  This is an evaluation board based on the Galileo GT-64120
-	  single-chip system controller that contains a MIPS R5000 compatible
-	  core running at 75/100MHz.  Their website is located at
-	  <http://www.marvell.com/>.  Say Y here if you wish to build a
-	  kernel for this platform.
-
-config MACH_JAZZ
-	bool "Jazz family of machines"
-	select ARC
-	select ARC32
-	select ARCH_MAY_HAVE_PC_FDC
-	select GENERIC_ISA_DMA
-	select I8253
-	select I8259
-	select ISA
-	select SYS_HAS_CPU_R4X00
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	select SYS_SUPPORTS_100HZ
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	help
-	 This a family of machines based on the MIPS R4030 chipset which was
-	 used by several vendors to build RISC/os and Windows NT workstations.
-	 Members include the Acer PICA, MIPS Magnum 4000, MIPS Millenium and
-	 Olivetti M700-10 workstations.
-
-config LASAT
-	bool "LASAT Networks platforms"
-	select DMA_NONCOHERENT
-	select SYS_HAS_EARLY_PRINTK
-	select HW_HAS_PCI
-	select MIPS_GT64120
-	select MIPS_NILE4
-	select R5000_CPU_SCACHE
-	select SYS_HAS_CPU_R5000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if BROKEN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-
-config MIPS_ATLAS
-	bool "MIPS Atlas board"
-	select BOOT_ELF32
-	select DMA_NONCOHERENT
-	select SYS_HAS_EARLY_PRINTK
-	select IRQ_CPU
-	select HW_HAS_PCI
-	select MIPS_BOARDS_GEN
-	select MIPS_BONITO64
-	select MIPS_GT64120
-	select MIPS_MSC
-	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
 	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_HAS_CPU_MIPS32_R2
-	select SYS_HAS_CPU_MIPS64_R1
-	select SYS_HAS_CPU_NEVADA
-	select SYS_HAS_CPU_RM7000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
 	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_SUPPORTS_MULTITHREADING if EXPERIMENTAL
-	select SYS_SUPPORTS_SMARTMIPS
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	help
-	  This enables support for the MIPS Technologies Atlas evaluation
-	  board.
-
-config MIPS_MALTA
-	bool "MIPS Malta board"
-	select ARCH_MAY_HAVE_PC_FDC
 	select BOOT_ELF32
-	select HAVE_STD_PC_SERIAL_PORT
-	select DMA_NONCOHERENT
-	select GENERIC_ISA_DMA
-	select IRQ_CPU
-	select HW_HAS_PCI
-	select I8259
-	select MIPS_BOARDS_GEN
-	select MIPS_BONITO64
-	select MIPS_CPU_SCACHE
-	select MIPS_GT64120
-	select MIPS_MSC
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_HAS_CPU_MIPS32_R2
-	select SYS_HAS_CPU_MIPS64_R1
-	select SYS_HAS_CPU_NEVADA
-	select SYS_HAS_CPU_RM7000
-	select SYS_HAS_EARLY_PRINTK
 	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_SUPPORTS_MULTITHREADING
-	select SYS_SUPPORTS_SMARTMIPS
-	help
-	  This enables support for the MIPS Technologies Malta evaluation
-	  board.
+	select RALINK_RT2880_MP
+        help
+         Ralink evaluation board based on RT2880
 
-config MIPS_SEAD
-	bool "MIPS SEAD board (EXPERIMENTAL)"
-	depends on EXPERIMENTAL
-	select IRQ_CPU
+ config RALINK_RT3052
+        bool "Ralink RT3052 board"
 	select DMA_NONCOHERENT
-	select SYS_HAS_EARLY_PRINTK
-	select MIPS_BOARDS_GEN
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_HAS_CPU_MIPS32_R2
-	select SYS_HAS_CPU_MIPS64_R1
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_SUPPORTS_SMARTMIPS
-	help
-	  This enables support for the MIPS Technologies SEAD evaluation
-	  board.
-
-config WR_PPMC
-	bool "Wind River PPMC board"
 	select IRQ_CPU
-	select BOOT_ELF32
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select MIPS_GT64120
 	select SWAP_IO_SPACE
 	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_HAS_CPU_MIPS32_R2
-	select SYS_HAS_CPU_MIPS64_R1
-	select SYS_HAS_CPU_NEVADA
-	select SYS_HAS_CPU_RM7000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	help
-	  This enables support for the Wind River MIPS32 4KC PPMC evaluation
-	  board, which is based on GT64120 bridge chip.
-
-config MIPS_SIM
-	bool 'MIPS simulator (MIPSsim)'
-	select DMA_NONCOHERENT
-	select SYS_HAS_EARLY_PRINTK
-	select IRQ_CPU
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_HAS_CPU_MIPS32_R2
-	select SYS_HAS_EARLY_PRINTK
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
+        select SYS_HAS_CPU_MIPS32_R2
 	select SYS_SUPPORTS_LITTLE_ENDIAN
-	help
-	  This option enables support for MIPS Technologies MIPSsim software
-	  emulator.
-
-config MOMENCO_JAGUAR_ATX
-	bool "Momentum Jaguar board"
 	select BOOT_ELF32
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select IRQ_CPU_RM7K
-	select IRQ_MV64340
-	select LIMITED_DMA
-	select PCI_MARVELL
-	select RM7000_CPU_SCACHE
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_RM9000
-	select SYS_HAS_EARLY_PRINTK
 	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_KGDB
-	help
-	  The Jaguar ATX is a MIPS-based Single Board Computer (SBC) made by
-	  Momentum Computer <http://www.momenco.com/>.
+	select RALINK_RT3052_MP2
+        help
+         Ralink evaluation board based on RT3052
 
-config MOMENCO_OCELOT
-	bool "Momentum Ocelot board"
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select IRQ_CPU_RM7K
-	select MIPS_GT64120
-	select RM7000_CPU_SCACHE
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_RM7000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_KGDB
-	help
-	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
-	  Momentum Computer <http://www.momenco.com/>.
-
-config MOMENCO_OCELOT_3
-	bool "Momentum Ocelot-3 board"
-	select BOOT_ELF32
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select IRQ_CPU_RM7K
-	select IRQ_MV64340
-	select PCI_MARVELL
-	select RM7000_CPU_SCACHE
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_RM9000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	help
-	  The Ocelot-3 is based off Discovery III System Controller and
-	  PMC-Sierra Rm79000 core.
-
-config MOMENCO_OCELOT_C
-	bool "Momentum Ocelot-C board"
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select IRQ_MV64340
-	select PCI_MARVELL
-	select RM7000_CPU_SCACHE
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_RM7000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	help
-	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
-	  Momentum Computer <http://www.momenco.com/>.
-
-config MOMENCO_OCELOT_G
-	bool "Momentum Ocelot-G board"
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select IRQ_CPU_RM7K
-	select PCI_MARVELL
-	select RM7000_CPU_SCACHE
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_RM7000
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if BROKEN
-	select SYS_SUPPORTS_BIG_ENDIAN
-	help
-	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
-	  Momentum Computer <http://www.momenco.com/>.
-
-config MIPS_XXS1500
-	bool "MyCable XXS1500 board"
-	select DMA_NONCOHERENT
-	select SOC_AU1500
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config PNX8550_JBS
-	bool "Philips PNX8550 based JBS board"
-	select PNX8550
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config PNX8550_STB810
-	bool "Support for Philips PNX8550 based STB810 board"
-	select PNX8550
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config DDB5477
-	bool "NEC DDB Vrc-5477"
-	select DDB5XXX_COMMON
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select I8259
-	select IRQ_CPU
-	select SYS_HAS_CPU_R5432
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	select SYS_SUPPORTS_KGDB
-	select SYS_SUPPORTS_KGDB
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	help
-	  This enables support for the R5432-based NEC DDB Vrc-5477,
-	  or Rockhopper/SolutionGear boards with R5432/R5500 CPUs.
-
-	  Features : kernel debugging, serial terminal, NFS root fs, on-board
-	  ether port USB, AC97, PCI, etc.
-
-config MACH_VR41XX
-	bool "NEC VR41XX-based machines"
-	select SYS_HAS_CPU_VR41XX
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-
-config PMC_YOSEMITE
-	bool "PMC-Sierra Yosemite eval board"
-	select DMA_COHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select IRQ_CPU_RM7K
-	select IRQ_CPU_RM9K
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_RM9000
-	select SYS_HAS_EARLY_PRINTK
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_HIGHMEM
-	select SYS_SUPPORTS_KGDB
-	select SYS_SUPPORTS_SMP
-	help
-	  Yosemite is an evaluation board for the RM9000x2 processor
-	  manufactured by PMC-Sierra.
-
-config QEMU
-	bool "Qemu"
-	select DMA_COHERENT
-	select GENERIC_ISA_DMA
-	select HAVE_STD_PC_SERIAL_PORT
-	select I8253
-	select I8259
-	select ISA
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_MIPS32_R1
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select ARCH_SPARSEMEM_ENABLE
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	select NR_CPUS_DEFAULT_1
-	select SYS_SUPPORTS_SMP
-	help
-	  Qemu is a software emulator which among other architectures also
-	  can simulate a MIPS32 4Kc system.  This patch adds support for the
-	  system architecture that currently is being simulated by Qemu.  It
-	  will eventually be removed again when Qemu has the capability to
-	  simulate actual MIPS hardware platforms.  More information on Qemu
-	  can be found at http://www.linux-mips.org/wiki/Qemu.
-
-config MARKEINS
-	bool "Support for NEC EMMA2RH Mark-eins"
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select SWAP_IO_SPACE
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_HAS_CPU_R5000
-	help
-	  This enables support for the R5432-based NEC Mark-eins
-	  boards with R5500 CPU.
-
-config SGI_IP22
-	bool "SGI IP22 (Indy/Indigo2)"
-	select ARC
-	select ARC32
-	select BOOT_ELF32
-	select DMA_NONCOHERENT
-	select HW_HAS_EISA
-	select IP22_CPU_SCACHE
-	select IRQ_CPU
-	select GENERIC_ISA_DMA_SUPPORT_BROKEN
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_R4X00
-	select SYS_HAS_CPU_R5000
-	select SYS_HAS_EARLY_PRINTK
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	help
-	  This are the SGI Indy, Challenge S and Indigo2, as well as certain
-	  OEM variants like the Tandem CMN B006S. To compile a Linux kernel
-	  that runs on these, say Y here.
-
-config SGI_IP27
-	bool "SGI IP27 (Origin200/2000)"
-	select ARC
-	select ARC64
-	select BOOT_ELF64
-	select DMA_IP27
-	select SYS_HAS_EARLY_PRINTK
-	select HW_HAS_PCI
-	select NR_CPUS_DEFAULT_64
-	select PCI_DOMAINS
-	select SYS_HAS_CPU_R10000
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_KGDB
-	select SYS_SUPPORTS_NUMA
-	select SYS_SUPPORTS_SMP
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	help
-	  This are the SGI Origin 200, Origin 2000 and Onyx 2 Graphics
-	  workstations.  To compile a Linux kernel that runs on these, say Y
-	  here.
-
-config SGI_IP32
-	bool "SGI IP32 (O2) (EXPERIMENTAL)"
-	depends on EXPERIMENTAL
-	select ARC
-	select ARC32
-	select BOOT_ELF32
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select R5000_CPU_SCACHE
-	select RM7000_CPU_SCACHE
-	select SYS_HAS_CPU_R5000
-	select SYS_HAS_CPU_R10000 if BROKEN
-	select SYS_HAS_CPU_RM7000
-	select SYS_HAS_CPU_NEVADA
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	help
-	  If you want this kernel to run on SGI O2 workstation, say Y here.
-
-config SIBYTE_BIGSUR
-	bool "Sibyte BCM91480B-BigSur"
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select NR_CPUS_DEFAULT_4
-	select PCI_DOMAINS
-	select SIBYTE_BCM1x80
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SIBYTE_SWARM
-	bool "Sibyte BCM91250A-SWARM"
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select NR_CPUS_DEFAULT_2
-	select SIBYTE_SB1250
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_HIGHMEM
-	select SYS_SUPPORTS_KGDB
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SIBYTE_SENTOSA
-	bool "Sibyte BCM91250E-Sentosa"
-	depends on EXPERIMENTAL
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select NR_CPUS_DEFAULT_2
-	select SIBYTE_SB1250
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SIBYTE_RHONE
-	bool "Sibyte BCM91125E-Rhone"
-	depends on EXPERIMENTAL
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select SIBYTE_BCM1125H
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SIBYTE_CARMEL
-	bool "Sibyte BCM91120x-Carmel"
-	depends on EXPERIMENTAL
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select SIBYTE_BCM1120
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SIBYTE_PTSWARM
-	bool "Sibyte BCM91250PT-PTSWARM"
-	depends on EXPERIMENTAL
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select NR_CPUS_DEFAULT_2
-	select SIBYTE_SB1250
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_HIGHMEM
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SIBYTE_LITTLESUR
-	bool "Sibyte BCM91250C2-LittleSur"
-	depends on EXPERIMENTAL
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select NR_CPUS_DEFAULT_2
-	select SIBYTE_SB1250
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_HIGHMEM
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SIBYTE_CRHINE
-	bool "Sibyte BCM91120C-CRhine"
-	depends on EXPERIMENTAL
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select SIBYTE_BCM1120
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SIBYTE_CRHONE
-	bool "Sibyte BCM91125C-CRhone"
-	depends on EXPERIMENTAL
-	select BOOT_ELF32
-	select DMA_COHERENT
-	select SIBYTE_BCM1125
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_SB1
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_HIGHMEM
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-
-config SNI_RM
-	bool "SNI RM200/300/400"
-	select ARC if CPU_LITTLE_ENDIAN
-	select ARC32 if CPU_LITTLE_ENDIAN
-	select ARCH_MAY_HAVE_PC_FDC
-	select BOOT_ELF32
-	select DMA_NONCOHERENT
-	select GENERIC_ISA_DMA
-	select HW_HAS_EISA
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select I8253
-	select I8259
-	select ISA
-	select SWAP_IO_SPACE if CPU_BIG_ENDIAN
-	select SYS_HAS_CPU_R4X00
-	select SYS_HAS_CPU_R5000
-	select SYS_HAS_CPU_R10000
-	select R5000_CPU_SCACHE
-	select SYS_HAS_EARLY_PRINTK
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_HIGHMEM
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	help
-	  The SNI RM200/300/400 are MIPS-based machines manufactured by
-	  Siemens Nixdorf Informationssysteme (SNI), parent company of Pyramid
-	  Technology and now in turn merged with Fujitsu.  Say Y here to
-	  support this machine type.
-
-config TOSHIBA_JMR3927
-	bool "Toshiba JMR-TX3927 board"
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select MIPS_TX3927
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_TX39XX
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select TOSHIBA_BOARDS
-
-config TOSHIBA_RBTX4927
-	bool "Toshiba TBTX49[23]7 board"
-	select DMA_NONCOHERENT
-	select HAS_TXX9_SERIAL
-	select HW_HAS_PCI
-	select I8259
-	select ISA
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_TX49XX
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_KGDB
-	select TOSHIBA_BOARDS
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	help
-	  This Toshiba board is based on the TX4927 processor. Say Y here to
-	  support this machine type
+endchoice
 
-config TOSHIBA_RBTX4938
-	bool "Toshiba RBTX4938 board"
-	select HAVE_STD_PC_SERIAL_PORT
-	select DMA_NONCOHERENT
-	select GENERIC_ISA_DMA
-	select HAS_TXX9_SERIAL
-	select HW_HAS_PCI
-	select I8259
-	select ISA
-	select SWAP_IO_SPACE
-	select SYS_HAS_CPU_TX49XX
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_LITTLE_ENDIAN
-	select SYS_SUPPORTS_BIG_ENDIAN
-	select SYS_SUPPORTS_KGDB
-	select TOSHIBA_BOARDS
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	help
-	  This Toshiba board is based on the TX4938 processor. Say Y here to
-	  support this machine type
+source "arch/mips/rt2880/Kconfig"
 
-endchoice
 
-source "arch/mips/ddb5xxx/Kconfig"
-source "arch/mips/gt64120/ev64120/Kconfig"
-source "arch/mips/jazz/Kconfig"
-source "arch/mips/lasat/Kconfig"
-source "arch/mips/momentum/Kconfig"
-source "arch/mips/pmc-sierra/Kconfig"
-source "arch/mips/sgi-ip27/Kconfig"
-source "arch/mips/sibyte/Kconfig"
-source "arch/mips/tx4927/Kconfig"
-source "arch/mips/tx4938/Kconfig"
-source "arch/mips/vr41xx/Kconfig"
-source "arch/mips/philips/pnx8550/common/Kconfig"
+config SERIAL_CONSOLE 
+	bool
 
 endmenu
 
@@ -2161,3 +1383,5 @@
 source "crypto/Kconfig"
 
 source "lib/Kconfig"
+
+source "ralink/Kconfig"
Index: linux-2.6.21/arch/mips/kernel/genex.S
===================================================================
--- linux-2.6.21.orig/arch/mips/kernel/genex.S	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/arch/mips/kernel/genex.S	2009-11-30 12:44:56.000000000 +0100
@@ -21,6 +21,16 @@
 #include <asm/war.h>
 #include <asm/page.h>
 
+#ifndef CONFIG_PANIC
+#define PANIC_PIC(msg)					\
+		.set push;				\
+		.set	reorder;			\
+		PTR_LA	a0,8f;				\
+9:		b	9b;				\
+		.set	pop;				\
+		TEXT(msg)
+#else /* CONFIG_PANIC=y */
+#ifdef CONFIG_FULL_PANIC
 #define PANIC_PIC(msg)					\
 		.set push;				\
 		.set	reorder;			\
@@ -31,6 +41,19 @@
 9:		b	9b;				\
 		.set	pop;				\
 		TEXT(msg)
+#else /* CONFIG_FULL_PANIC=n */
+#define PANIC_PIC(msg)					\
+		.set push;				\
+		.set	reorder;			\
+		PTR_LA	a0,8f;				\
+		.set	noat;				\
+		PTR_LA	AT, tiny_panic;			\
+		jr	AT;				\
+9:		b	9b;				\
+		.set	pop;				\
+		TEXT(msg)
+#endif /* CONFIG_FULL_PANIC=n */
+#endif /* CONFIG_PANIC=y */
 
 	__INIT
 
Index: linux-2.6.21/arch/mips/kernel/kspd.c
===================================================================
--- linux-2.6.21.orig/arch/mips/kernel/kspd.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/arch/mips/kernel/kspd.c	2009-11-30 12:44:56.000000000 +0100
@@ -17,6 +17,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/sched.h>
 #include <linux/unistd.h>
 #include <linux/file.h>
 #include <linux/fs.h>
@@ -198,7 +199,6 @@
 	int cmd;
 
 	char *vcwd;
-	mm_segment_t old_fs;
 	int size;
 
 	ret.retval = -1;
@@ -241,8 +241,6 @@
  		if ((ret.retval = sp_syscall(__NR_gettimeofday, (int)&tv,
  		                             (int)&tz, 0,0)) == 0)
 		ret.retval = tv.tv_sec;
-
-		ret.errno = errno;
 		break;
 
  	case MTSP_SYSCALL_EXIT:
@@ -279,7 +277,6 @@
 		if (cmd >= 0) {
 			ret.retval = sp_syscall(cmd, generic.arg0, generic.arg1,
 			                        generic.arg2, generic.arg3);
-			ret.errno = errno;
 		} else
  			printk(KERN_WARNING
 			       "KSPD: Unknown SP syscall number %d\n", sc.cmd);
Index: linux-2.6.21/arch/mips/kernel/ptrace.c
===================================================================
--- linux-2.6.21.orig/arch/mips/kernel/ptrace.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/arch/mips/kernel/ptrace.c	2009-11-30 12:44:56.000000000 +0100
@@ -20,12 +20,12 @@
 #include <linux/mm.h>
 #include <linux/errno.h>
 #include <linux/ptrace.h>
-#include <linux/audit.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/user.h>
 #include <linux/security.h>
-#include <linux/signal.h>
+#include <linux/audit.h>
+#include <linux/seccomp.h>
 
 #include <asm/byteorder.h>
 #include <asm/cpu.h>
@@ -483,12 +483,16 @@
  */
 asmlinkage void do_syscall_trace(struct pt_regs *regs, int entryexit)
 {
+	/* do the secure computing check first */
+	secure_computing(regs->orig_eax);
+
 	if (unlikely(current->audit_context) && entryexit)
 		audit_syscall_exit(AUDITSC_RESULT(regs->regs[2]),
 		                   regs->regs[2]);
 
 	if (!(current->ptrace & PT_PTRACED))
 		goto out;
+
 	if (!test_thread_flag(TIF_SYSCALL_TRACE))
 		goto out;
 
@@ -506,9 +510,14 @@
 		send_sig(current->exit_code, current, 1);
 		current->exit_code = 0;
 	}
- out:
+
+out:
+	/* There is no ->orig_eax and that's quite intensional for now making
+	   this work will require some work in various other place before it's
+	   more than a placebo.  */
+
 	if (unlikely(current->audit_context) && !entryexit)
-		audit_syscall_entry(audit_arch(), regs->regs[2],
-				    regs->regs[4], regs->regs[5],
-				    regs->regs[6], regs->regs[7]);
+		audit_syscall_entry(audit_arch(), regs->orig_eax,
+		                    regs->regs[4], regs->regs[5],
+		                    regs->regs[6], regs->regs[7]);
 }
Index: linux-2.6.21/arch/mips/kernel/rtlx.c
===================================================================
--- linux-2.6.21.orig/arch/mips/kernel/rtlx.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/arch/mips/kernel/rtlx.c	2009-11-30 12:44:56.000000000 +0100
@@ -289,7 +289,7 @@
 	return write_spacefree(chan->rt_read, chan->rt_write, chan->buffer_size);
 }
 
-ssize_t rtlx_read(int index, void __user *buff, size_t count, int user)
+ssize_t rtlx_read(int index, void __user *buff, size_t count)
 {
 	size_t lx_write, fl = 0L;
 	struct rtlx_channel *lx;
@@ -331,9 +331,10 @@
 	return count;
 }
 
-ssize_t rtlx_write(int index, const void __user *buffer, size_t count, int user)
+ssize_t rtlx_write(int index, const void __user *buffer, size_t count)
 {
 	struct rtlx_channel *rt;
+	unsigned long failed;
 	size_t rt_read;
 	size_t fl;
 
@@ -363,7 +364,7 @@
 	}
 
 out:
-	count -= cailed;
+	count -= failed;
 
 	smp_wmb();
 	rt->rt_write = (rt->rt_write + count) % rt->buffer_size;
Index: linux-2.6.21/arch/mips/lib-32/dump_tlb.c
===================================================================
--- linux-2.6.21.orig/arch/mips/lib-32/dump_tlb.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/arch/mips/lib-32/dump_tlb.c	2009-11-30 12:44:56.000000000 +0100
@@ -40,8 +40,6 @@
 		return "256Mb";
 #endif
 	}
-
-	return "unknown";
 }
 
 #define BARRIER()					\
Index: linux-2.6.21/arch/mips/lib-64/dump_tlb.c
===================================================================
--- linux-2.6.21.orig/arch/mips/lib-64/dump_tlb.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/arch/mips/lib-64/dump_tlb.c	2009-11-30 12:44:56.000000000 +0100
@@ -31,8 +31,6 @@
 	case PM_256M:	return "256Mb";
 #endif
 	}
-
-	return "unknown";
 }
 
 #define BARRIER()					\
Index: linux-2.6.21/arch/mips/Makefile
===================================================================
--- linux-2.6.21.orig/arch/mips/Makefile	2009-11-30 12:44:55.000000000 +0100
+++ linux-2.6.21/arch/mips/Makefile	2009-11-30 12:44:56.000000000 +0100
@@ -158,6 +158,27 @@
 #
 
 #
+# Ralink RT2880 board
+#
+core-$(CONFIG_RALINK_RT2880)	+= arch/mips/rt2880/
+cflags-$(CONFIG_RALINK_RT2880)	+= -Iinclude/asm-mips/rt2880
+load-$(CONFIG_RALINK_RT2880)	+= 0x88000000
+
+#
+# Ralink RT2883 board
+#
+core-$(CONFIG_RALINK_RT2883)	+= arch/mips/rt2880/
+cflags-$(CONFIG_RALINK_RT2883)	+= -Iinclude/asm-mips/rt2880
+load-$(CONFIG_RALINK_RT2883)	+= 0x80000000
+
+#
+# Ralink RT3052 board
+#
+core-$(CONFIG_RALINK_RT3052)	+= arch/mips/rt2880/
+cflags-$(CONFIG_RALINK_RT3052)	+= -Iinclude/asm-mips/rt2880
+load-$(CONFIG_RALINK_RT3052)	+= 0x80000000
+
+#
 # Acer PICA 61, Mips Magnum 4000 and Olivetti M700.
 #
 core-$(CONFIG_MACH_JAZZ)	+= arch/mips/jazz/
@@ -672,6 +693,18 @@
 vmlinux.32: vmlinux
 	$(OBJCOPY) -O $(32bit-bfd) $(OBJCOPYFLAGS) $< $@
 
+ifdef CONFIG_RALINK_RT2880
+#error zImage rImage
+zImage rImage: vmlinux $(TOPDIR)/.config
+	$(Q)$(MAKE) $(build)=arch/mips/rt2880/boot $@
+endif
+
+ifdef CONFIG_RALINK_RT3052
+#error zImage rImage
+zImage rImage: vmlinux $(TOPDIR)/.config
+	$(Q)$(MAKE) $(build)=arch/mips/rt2880/boot $@
+endif
+
 #
 # The 64-bit ELF tools are pretty broken so at this time we generate 64-bit
 # ELF files from 32-bit files by conversion.
Index: linux-2.6.21/arch/mips/mm/cache.c
===================================================================
--- linux-2.6.21.orig/arch/mips/mm/cache.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/arch/mips/mm/cache.c	2009-11-30 12:44:56.000000000 +0100
@@ -96,7 +96,7 @@
 
 		kaddr = kmap_coherent(page, vmaddr);
 		flush_data_cache_page((unsigned long)kaddr);
-		kunmap_coherent(kaddr);
+		kunmap_coherent(page);
 	}
 }
 
Index: linux-2.6.21/arch/mips/pci/pci.c
===================================================================
--- linux-2.6.21.orig/arch/mips/pci/pci.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/arch/mips/pci/pci.c	2009-11-30 12:44:56.000000000 +0100
@@ -111,10 +111,15 @@
 	return PCI_SLOT(dev->devfn);
 }
 
+int mips_system_has_legacy_ide;
+
+EXPORT_SYMBOL_GPL(mips_system_has_legacy_ide);
+
 static int __init pcibios_init(void)
 {
 	struct pci_controller *hose;
 	struct pci_bus *bus;
+	struct pci_dev *dev;
 	int next_busno;
 	int need_domain_info = 0;
 
@@ -158,6 +163,13 @@
 		pci_assign_unassigned_resources();
 	pci_fixup_irqs(common_swizzle, pcibios_map_irq);
 
+	if ((dev = pci_get_class(PCI_CLASS_BRIDGE_EISA << 8, NULL)) != NULL ||
+	    (dev = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, NULL)) != NULL) {
+		pci_dev_put(dev);
+
+		mips_system_has_legacy_ide = 1;
+	}
+
 	return 0;
 }
 
Index: linux-2.6.21/arch/mips/rt2880/cmdline.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/cmdline.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,93 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     cmdline parsing for Ralink RT2880 solution
+ *
+ *  Copyright 2007 Ralink Inc. (bruce_chang@ralinktech.com.tw)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2007 Bruce Chang
+ *
+ * Initial Release
+ *
+ *
+ *
+ **************************************************************************
+ */
+
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+
+#if defined (CONFIG_RT2880_ROOTFS_IN_FLASH)
+#ifdef CONFIG_SYSFS
+char rt2880_cmdline[]="console=ttyS1,57600n8 root=/dev/mtdblock5 init=/etc/preinit";
+#else
+char rt2880_cmdline[]="console=ttyS1,57600n8 root=1f04";
+#endif
+#elif defined (CONFIG_RT2880_ROOTFS_IN_RAM)
+char rt2880_cmdline[]="console=ttyS1,57600n8 root=/dev/ram0";
+#else
+#error "RT2880 Root File System not defined"
+#endif
+
+extern int prom_argc;
+extern int *_prom_argv;
+
+/*
+ * YAMON (32-bit PROM) pass arguments and environment as 32-bit pointer.
+ * This macro take care of sign extension.
+ */
+#define prom_argv(index) ((char *)(((int *)(int)_prom_argv)[(index)]))
+
+extern char arcs_cmdline[CL_SIZE];
+
+char * __init prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
+
+void  __init prom_init_cmdline(void)
+{
+	char *cp;
+	int actr=1; /* Always ignore argv[0] */
+
+	cp = &(arcs_cmdline[0]);
+
+	strcpy(cp, rt2880_cmdline);
+	cp += strlen(rt2880_cmdline);
+	*cp++ = ' ';
+
+	while(actr < prom_argc) {
+	    strcpy(cp, prom_argv(actr));
+	    cp += strlen(prom_argv(actr));
+	    *cp++ = ' ';
+	    actr++;
+	}
+	if (cp != &(arcs_cmdline[0])) /* get rid of trailing space */
+	    --cp;
+	*cp = '\0';
+	
+}
Index: linux-2.6.21/arch/mips/rt2880/display.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/display.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,49 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Display routines for display messages in MIPS boards ascii display.
+ *
+ */
+
+#include <asm/mips-boards/generic.h>
+
+
+void mips_display_message(const char *str)
+{
+        volatile unsigned int *display = (void *)ASCII_DISPLAY_POS_BASE;
+	int i;
+
+	for (i = 0; i <= 14; i=i+2) {
+	         if (*str)
+		         display[i] = *str++;
+		 else
+		         display[i] = ' ';
+	}
+}
+
+#ifndef CONFIG_MIPS_SEAD
+void mips_display_word(unsigned int num)
+{
+        volatile unsigned int *display = (void *)ASCII_DISPLAY_WORD_BASE;
+
+	*display = num;
+}
+#endif
Index: linux-2.6.21/arch/mips/rt2880/gdb_hook.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/gdb_hook.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,213 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * This is the interface to the remote debugger stub.
+ *
+ */
+#include <linux/serialP.h>
+#include <linux/serial_reg.h>
+
+#include <asm/serial.h>
+#include <asm/io.h>
+
+static struct serial_state rs_table[RS_TABLE_SIZE] = {
+	SERIAL_PORT_DFNS	/* Defined in serial.h */
+};
+
+static struct async_struct kdb_port_info = {0};
+
+int (*generic_putDebugChar)(char);
+char (*generic_getDebugChar)(void);
+
+static __inline__ unsigned int serial_in(struct async_struct *info, int offset)
+{
+	return inb(info->port + offset);
+}
+
+static __inline__ void serial_out(struct async_struct *info, int offset,
+				int value)
+{
+	outb(value, info->port+offset);
+}
+
+void rs_kgdb_hook(int tty_no) {
+	int t;
+	struct serial_state *ser = &rs_table[tty_no];
+
+	kdb_port_info.state = ser;
+	kdb_port_info.magic = SERIAL_MAGIC;
+	kdb_port_info.port = ser->port;
+	kdb_port_info.flags = ser->flags;
+
+	/*
+	 * Clear all interrupts
+	 */
+	serial_in(&kdb_port_info, UART_LSR);
+	serial_in(&kdb_port_info, UART_RX);
+	serial_in(&kdb_port_info, UART_IIR);
+	serial_in(&kdb_port_info, UART_MSR);
+
+	/*
+	 * Now, initialize the UART
+	 */
+	serial_out(&kdb_port_info, UART_LCR, UART_LCR_WLEN8);	/* reset DLAB */
+	if (kdb_port_info.flags & ASYNC_FOURPORT) {
+		kdb_port_info.MCR = UART_MCR_DTR | UART_MCR_RTS;
+		t = UART_MCR_DTR | UART_MCR_OUT1;
+	} else {
+		kdb_port_info.MCR
+			= UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2;
+		t = UART_MCR_DTR | UART_MCR_RTS;
+	}
+
+	kdb_port_info.MCR = t;		/* no interrupts, please */
+	serial_out(&kdb_port_info, UART_MCR, kdb_port_info.MCR);
+
+	/*
+	 * and set the speed of the serial port
+	 * (currently hardwired to 9600 8N1
+	 */
+
+	/* baud rate is fixed to 9600 (is this sufficient?)*/
+	t = kdb_port_info.state->baud_base / 9600;
+	/* set DLAB */
+	serial_out(&kdb_port_info, UART_LCR, UART_LCR_WLEN8 | UART_LCR_DLAB);
+	serial_out(&kdb_port_info, UART_DLL, t & 0xff);/* LS of divisor */
+	serial_out(&kdb_port_info, UART_DLM, t >> 8);  /* MS of divisor */
+	/* reset DLAB */
+	serial_out(&kdb_port_info, UART_LCR, UART_LCR_WLEN8);
+}
+
+int putDebugChar(char c)
+{
+	return generic_putDebugChar(c);
+}
+
+char getDebugChar(void)
+{
+	return generic_getDebugChar();
+}
+
+int rs_putDebugChar(char c)
+{
+
+	if (!kdb_port_info.state) { 	/* need to init device first */
+		return 0;
+	}
+
+	while ((serial_in(&kdb_port_info, UART_LSR) & UART_LSR_THRE) == 0)
+		;
+
+	serial_out(&kdb_port_info, UART_TX, c);
+
+	return 1;
+}
+
+char rs_getDebugChar(void)
+{
+	if (!kdb_port_info.state) { 	/* need to init device first */
+		return 0;
+	}
+
+	while (!(serial_in(&kdb_port_info, UART_LSR) & 1))
+		;
+
+	return(serial_in(&kdb_port_info, UART_RX));
+}
+
+
+#if defined (CONFIG_RALINK_RT2880) || defined (CONFIG_RALINK_RT3052) 
+
+#include <asm/mips-boards/atlas.h>
+#include <asm/mips-boards/saa9730_uart.h>
+
+#define INB(a)     inb((unsigned long)a)
+#define OUTB(x,a)  outb(x,(unsigned long)a)
+
+/*
+ * This is the interface to the remote debugger stub
+ * if the Philips part is used for the debug port,
+ * called from the platform setup code.
+ *
+ * PCI init will not have been done yet, we make a
+ * universal assumption about the way the bootloader (YAMON)
+ * have located and set up the chip.
+ */
+static t_uart_saa9730_regmap *kgdb_uart = (void *)(ATLAS_SAA9730_REG + SAA9730_UART_REGS_ADDR);
+
+static int saa9730_kgdb_active = 0;
+
+void saa9730_kgdb_hook(void)
+{
+        volatile unsigned char t;
+
+        /*
+         * Clear all interrupts
+         */
+	t = INB(&kgdb_uart->Lsr);
+	t += INB(&kgdb_uart->Msr);
+	t += INB(&kgdb_uart->Thr_Rbr);
+	t += INB(&kgdb_uart->Iir_Fcr);
+
+        /*
+         * Now, initialize the UART
+         */
+	/* 8 data bits, one stop bit, no parity */
+	OUTB(SAA9730_LCR_DATA8, &kgdb_uart->Lcr);
+
+        /* baud rate is fixed to 9600 (is this sufficient?)*/
+	OUTB(0, &kgdb_uart->BaudDivMsb); /* HACK - Assumes standard crystal */
+	OUTB(23, &kgdb_uart->BaudDivLsb); /* HACK - known for MIPS Atlas */
+
+	/* Set RTS/DTR active */
+	OUTB(SAA9730_MCR_DTR | SAA9730_MCR_RTS, &kgdb_uart->Mcr);
+	saa9730_kgdb_active = 1;
+}
+
+int saa9730_putDebugChar(char c)
+{
+
+        if (!saa9730_kgdb_active) {     /* need to init device first */
+                return 0;
+        }
+
+        while (!(INB(&kgdb_uart->Lsr) & SAA9730_LSR_THRE))
+                ;
+	OUTB(c, &kgdb_uart->Thr_Rbr);
+
+        return 1;
+}
+
+char saa9730_getDebugChar(void)
+{
+	char c;
+
+        if (!saa9730_kgdb_active) {     /* need to init device first */
+                return 0;
+        }
+        while (!(INB(&kgdb_uart->Lsr) & SAA9730_LSR_DR))
+                ;
+
+	c = INB(&kgdb_uart->Thr_Rbr);
+        return(c);
+}
+
+#endif
Index: linux-2.6.21/arch/mips/rt2880/init.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/init.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,358 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     init setup for Ralink RT2880 solution
+ *
+ *  Copyright 2007 Ralink Inc. (bruce_chang@ralinktech.com.tw)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2007 Bruce Chang
+ *
+ * Initial Release
+ *
+ *
+ *
+ **************************************************************************
+ */
+
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/serialP.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/serial.h>
+#include <asm/rt2880/prom.h>
+#include <asm/rt2880/generic.h>
+#include <asm/rt2880/surfboard.h>
+#include <asm/rt2880/surfboardint.h>
+#include <asm/rt2880/rt_mmap.h>
+extern unsigned long surfboard_sysclk;
+extern unsigned long mips_machgroup;
+u32 mips_cpu_feq;
+
+/* Environment variable */
+typedef struct {
+	char *name;
+	char *val;
+} t_env_var;
+
+int prom_argc;
+int *_prom_argv, *_prom_envp;
+
+/* PROM version of rs_table - needed for Serial Console */
+struct serial_state prom_rs_table[] = {
+       SERIAL_PORT_DFNS        /* Defined in serial.h */
+};
+
+/*
+ * YAMON (32-bit PROM) pass arguments and environment as 32-bit pointer.
+ * This macro take care of sign extension, if running in 64-bit mode.
+ */
+#define prom_envp(index) ((char *)(((int *)(int)_prom_envp)[(index)]))
+
+int init_debug = 0;
+
+char *prom_getenv(char *envname)
+{
+	/*
+	 * Return a pointer to the given environment variable.
+	 * In 64-bit mode: we're using 64-bit pointers, but all pointers
+	 * in the PROM structures are only 32-bit, so we need some
+	 * workarounds, if we are running in 64-bit mode.
+	 */
+	int i, index=0;
+	// Dennis Lee +
+	return NULL;
+	// 
+	i = strlen(envname);
+
+	while (prom_envp(index)) {
+		if(strncmp(envname, prom_envp(index), i) == 0) {
+			return(prom_envp(index+1));
+		}
+		index += 2;
+	}
+
+	return NULL;
+}
+
+static inline unsigned char str2hexnum(unsigned char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	return 0; /* foo */
+}
+
+static inline void str2eaddr(unsigned char *ea, unsigned char *str)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		unsigned char num;
+
+		if((*str == '.') || (*str == ':'))
+			str++;
+		num = str2hexnum(*str++) << 4;
+		num |= (str2hexnum(*str++));
+		ea[i] = num;
+	}
+}
+
+int get_ethernet_addr(char *ethernet_addr)
+{
+        char *ethaddr_str;
+
+        ethaddr_str = prom_getenv("ethaddr");
+	if (!ethaddr_str) {
+	        printk("ethaddr not set in boot prom\n");
+		return -1;
+	}
+	str2eaddr(ethernet_addr, ethaddr_str);
+
+	if (init_debug > 1) {
+	        int i;
+		printk("get_ethernet_addr: ");
+	        for (i=0; i<5; i++)
+		        printk("%02x:", (unsigned char)*(ethernet_addr+i));
+		printk("%02x\n", *(ethernet_addr+i));
+	}
+
+	return 0;
+}
+
+void prom_init_sysclk(void)
+{
+
+#if defined(CONFIG_RT2880_FPGA)
+        mips_cpu_feq = 25000000; 
+#elif defined (CONFIG_RT3052_FPGA) || defined (CONFIG_RT2883_FPGA)
+        mips_cpu_feq = 40000000; 
+#else
+	u32 	reg;
+        u8      clk_sel;
+
+        reg = (*((volatile u32 *)(RALINK_SYSCTL_BASE + 0x10)));
+#if defined (CONFIG_RT2880_ASIC)
+        clk_sel = (reg>>20) & 0x03;
+#elif defined (CONFIG_RT2883_ASIC) 
+        clk_sel = (reg>>18) & 0x03;
+#elif defined (CONFIG_RT3052_ASIC) 
+        clk_sel = (reg>>18) & 0x01;
+#else
+#error Please Choice System Type
+#endif
+        switch(clk_sel) {
+#if defined (CONFIG_RALINK_RT2880_SHUTTLE)
+	case 0:
+		mips_cpu_feq = (233333333);
+		break;
+	case 1:
+		mips_cpu_feq = (250000000);
+		break;
+	case 2:
+		mips_cpu_feq = (266666666);
+		break;
+	case 3:
+		mips_cpu_feq = (280000000);
+		break;
+#elif defined (CONFIG_RALINK_RT2880_MP)
+	case 0:
+		mips_cpu_feq = (250000000);
+		break;
+	case 1:
+		mips_cpu_feq = (266666666);
+		break;
+	case 2:
+		mips_cpu_feq = (280000000);
+		break;
+	case 3:
+		mips_cpu_feq = (300000000);
+		break;
+#elif defined (CONFIG_RALINK_RT2883) 
+	case 0:
+		mips_cpu_feq = (380*1000*1000);
+		break;
+	case 1:
+		mips_cpu_feq = (390*1000*1000);
+		break;
+	case 2:
+		mips_cpu_feq = (400*1000*1000);
+		break;
+	case 3:
+		mips_cpu_feq = (420*1000*1000);
+		break;
+#elif defined (CONFIG_RALINK_RT3052) 
+	case 0:
+		mips_cpu_feq = (320*1000*1000);
+		break;
+	case 1:
+		mips_cpu_feq = (384*1000*1000); 
+		break;
+#else
+#error Please Choice Chip Type
+#endif
+	}
+
+#endif
+	
+#if defined (CONFIG_RALINK_RT3052) || defined (CONFIG_RALINK_RT2883)  
+	surfboard_sysclk = mips_cpu_feq/3;
+#else
+	surfboard_sysclk = mips_cpu_feq/2;
+#endif
+	printk("\n The CPU feqenuce set to %d MHz\n",mips_cpu_feq / 1000 / 1000);
+}
+
+/*
+** This function sets up the local prom_rs_table used only for the fake console
+** console (mainly prom_printf for debug display and no input processing)
+** and also sets up the global rs_table used for the actual serial console.
+** To get the correct baud_base value, prom_init_sysclk() must be called before
+** this function is called.
+*/
+static struct uart_port serial_req[2];
+int prom_init_serial_port(void)
+{
+
+  /*
+   * baud rate = system clock freq / (CLKDIV * 16)
+   * CLKDIV=system clock freq/16/baud rate
+   */
+  memset(serial_req, 0, 2*sizeof(serial_req));
+
+  serial_req[0].type       = PORT_16550A;
+  serial_req[0].line       = 0;
+  serial_req[0].irq        = SURFBOARDINT_UART;
+  serial_req[0].flags      = STD_COM_FLAGS;
+  serial_req[0].uartclk    = 57600 *16;
+  serial_req[0].iotype     = SERIAL_IO_PORT;
+  serial_req[0].iobase	   = KSEG1ADDR(RALINK_UART_BASE);
+  serial_req[0].regshift   = 2;
+  serial_req[0].mapbase    = KSEG1ADDR(RALINK_UART_BASE);
+  serial_req[0].custom_divisor = (surfboard_sysclk / SURFBOARD_BAUD_DIV / 57600);
+
+  serial_req[1].type       = PORT_16550A;
+  serial_req[1].line       = 1;
+  serial_req[1].irq        = SURFBOARDINT_UART1;
+  serial_req[1].flags      = STD_COM_FLAGS;
+  serial_req[1].uartclk    = 57600 *16;
+  serial_req[1].iotype     = SERIAL_IO_PORT;
+  serial_req[1].iobase	   = KSEG1ADDR(RALINK_UART_LITE_BASE);
+  serial_req[1].regshift   = 2;
+  serial_req[1].mapbase    = KSEG1ADDR(RALINK_UART_LITE_BASE);
+  serial_req[1].custom_divisor = (surfboard_sysclk / SURFBOARD_BAUD_DIV / 57600);
+
+  early_serial_setup(&serial_req[0]);
+  early_serial_setup(&serial_req[1]);
+
+  return(0);
+}
+
+//early_initcall(prom_init_serial_port);
+
+int prom_get_ttysnum(void)
+{
+	char *argptr;
+	int ttys_num = 0;       /* default */
+
+	/* get ttys_num to use with the fake console/prom_printf */
+	argptr = prom_getcmdline();
+
+	if ((argptr = strstr(argptr, "console=ttyS")) != NULL)
+	{
+                argptr += strlen("console=ttyS");
+
+                if (argptr[0] == '0')           /* ttyS0 */
+                        ttys_num = 0;           /* happens to be rs_table[0] */
+                else if (argptr[0] == '1')      /* ttyS1 */
+                        ttys_num = 1;           /* happens to be rs_table[1] */
+	}
+
+	return (ttys_num);
+}
+
+static void serial_setbrg(unsigned long wBaud)
+{
+        unsigned int clock_divisor = 0;
+        clock_divisor = (surfboard_sysclk / SURFBOARD_BAUD_DIV);
+	
+#if 1
+	//fix at 57600 8 n 1 n
+ 	*(volatile u32 *)(RALINK_SYSCTL_BASE + 0xC08)= 0;
+        *(volatile u32 *)(RALINK_SYSCTL_BASE + 0xC10)= 0;
+        *(volatile u32 *)(RALINK_SYSCTL_BASE + 0xC14)= 0x3;
+        *(volatile u32 *)(RALINK_SYSCTL_BASE + 0xC28)= (surfboard_sysclk / SURFBOARD_BAUD_DIV / 57600);
+	//fix at 57600 8 n 1 n
+ 	*(volatile u32 *)(RALINK_SYSCTL_BASE + 0x508)= 0;
+        *(volatile u32 *)(RALINK_SYSCTL_BASE + 0x510)= 0;
+        *(volatile u32 *)(RALINK_SYSCTL_BASE + 0x514)= 0x3;
+        *(volatile u32 *)(RALINK_SYSCTL_BASE + 0x528)= (surfboard_sysclk / SURFBOARD_BAUD_DIV / 57600);
+#else
+        IER(CFG_RT2880_CONSOLE) = 0;                                    /* Disable for now */
+        FCR(CFG_RT2880_CONSOLE) = 0;                                    /* No fifos enabled */
+
+        /* set baud rate */
+        LCR(CFG_RT2880_CONSOLE) = LCR_WLS0 | LCR_WLS1 | LCR_DLAB;
+        DLL(CFG_RT2880_CONSOLE) = clock_divisor &0xffff;
+        LCR(CFG_RT2880_CONSOLE) = LCR_WLS0 | LCR_WLS1;
+#endif
+}
+
+
+int serial_init(unsigned long wBaud)
+{
+        serial_setbrg(wBaud);
+
+        return (0);
+}
+__init void prom_init(void)
+{
+
+	mips_machgroup = MACH_GROUP_RT2880;
+	mips_machtype = MACH_RALINK_ROUTER;
+
+	prom_init_cmdline();
+	prom_init_sysclk();
+
+	set_io_port_base(KSEG1);
+	write_c0_wired(0);
+	serial_init(57600);
+
+	prom_init_serial_port();  /* Needed for Serial Console */
+	prom_meminit();
+	prom_setup_printf(prom_get_ttysnum());
+	prom_printf("\nLINUX started...\n");
+#if defined(CONFIG_RT2880_FPGA) || defined(CONFIG_RT3052_FPGA) || defined(CONFIG_RT2883_FPGA)
+	prom_printf("\n THIS IS FPGA\n");
+#elif defined(CONFIG_RT2880_ASIC) || defined(CONFIG_RT3052_ASIC) || defined (CONFIG_RT2883_ASIC)
+	prom_printf("\n THIS IS ASIC\n");
+#endif
+
+}
+
Index: linux-2.6.21/arch/mips/rt2880/irq.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/irq.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,478 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     Interrupt routines for Ralink RT2880 solution
+ *
+ *  Copyright 2007 Ralink Inc. (bruce_chang@ralinktech.com.tw)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2007 Bruce Chang
+ *
+ * Initial Release
+ *
+ *
+ *
+ **************************************************************************
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/kernel_stat.h>
+#include <linux/hardirq.h>
+#include <linux/preempt.h>
+
+#include <asm/irq.h>
+#include <asm/rt2880/surfboard.h>
+#include <asm/rt2880/surfboardint.h>
+#include <asm/rt2880/rt_mmap.h>
+#include <asm/gdb-stub.h>
+
+#include <asm/rt2880/eureka_ep430.h>
+
+#define shutdown_surfboard_irq	disable_surfboard_irq
+#define mask_and_ack_surfboard_irq disable_surfboard_irq
+
+
+extern volatile unsigned int dma1_intstat;
+extern volatile unsigned int dma1_rawstat;
+extern volatile unsigned int surfpcmcia_intstat;
+extern volatile unsigned int surfpcmcia_rawstat;
+
+extern asmlinkage void mipsIRQ(void);
+void mips_timer_interrupt(void);
+void __init ralink_gpio_init_irq(void);
+
+#ifdef CONFIG_KGDB
+extern void breakpoint(void);
+extern int remote_debug;
+#endif
+
+
+struct surfboard_ictrl_regs *surfboard_hw0_icregs
+	= (struct surfboard_ictrl_regs *)RALINK_INTCL_BASE;
+
+static unsigned char pci_order = 0;
+
+#if 0
+#define DEBUG_INT(x...) printk(x)
+#else
+#define DEBUG_INT(x...)
+#endif
+
+void disable_surfboard_irq(unsigned int irq_nr)
+{
+	//printk("%s(): irq_nr = %d\n",__FUNCTION__,  irq_nr);
+	if(irq_nr >5){
+		surfboard_hw0_icregs->intDisable = (1 << irq_nr);
+	}
+}
+
+void enable_surfboard_irq(unsigned int irq_nr)
+{
+	//printk("%s(): irq_nr = %d\n",__FUNCTION__,  irq_nr);
+	if(irq_nr >5)
+	surfboard_hw0_icregs->intEnable = (1 << irq_nr);
+}
+
+static unsigned int startup_surfboard_irq(unsigned int irq)
+{
+	enable_surfboard_irq(irq);
+	return 0; /* never anything pending */
+}
+
+
+static void end_surfboard_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		enable_surfboard_irq(irq);
+}
+#if 0
+static void rt2880_irq_handler(unsigned int irq)
+{
+	return;
+}
+#endif
+
+static void __inline__ disable_all(void)
+{
+	unsigned long int_status;
+	int_status = read_32bit_cp0_register(CP0_STATUS);
+	int_status &= 0xfffffffe;
+	write_32bit_cp0_register(CP0_STATUS, int_status);
+}
+
+static void __inline__ enable_all(void)
+{
+	unsigned long int_status;
+	int_status = read_32bit_cp0_register(CP0_STATUS);
+	int_status |= 0x1;
+	write_32bit_cp0_register(CP0_STATUS, int_status);
+}
+
+#if 0
+static void enable_rt2880_irq(unsigned int irq)
+{
+	unsigned long int_status;
+	int_status = read_32bit_cp0_register(CP0_STATUS);
+
+	if ( irq == 3)
+		int_status = int_status | CAUSEF_IP5;	
+	write_32bit_cp0_register(CP0_STATUS, int_status);
+}
+
+static void disable_rt2880_irq(unsigned int irq)
+{
+	unsigned long int_status;
+	int_status = read_32bit_cp0_register(CP0_STATUS);
+
+	if ( irq == 3)
+		int_status = int_status & ~(CAUSEF_IP5);	
+	write_32bit_cp0_register(CP0_STATUS, int_status);
+}
+#endif
+
+#if 1
+#define	startup_rt2880_irq	enable_rt2880_irq
+#define	shutdown_rt2880_irq	disable_rt2880_irq
+#else
+#define	startup_rt2880_irq 	rt2880_irq_handler	
+#define	shutdown_rt2880_irq	rt2880_irq_handler
+#endif
+
+#define	enable_rt2880_irq	rt2880_irq_handler
+#define	disable_rt2880_irq	rt2880_irq_handler
+#define	mask_and_ack_rt2880_irq	rt2880_irq_handler
+#define	end_rt2880_irq		rt2880_irq_handler
+
+#if 0
+static struct hw_interrupt_type rt2880_irq_type = {
+	"RT2880",
+	startup_rt2880_irq,
+	shutdown_rt2880_irq,
+	enable_rt2880_irq,
+	disable_rt2880_irq,
+	mask_and_ack_rt2880_irq,
+	end_rt2880_irq,
+	NULL
+};
+#endif
+
+static struct hw_interrupt_type surfboard_irq_type = {
+  .typename = "Surfboard",
+  .startup  = startup_surfboard_irq,
+  .shutdown = shutdown_surfboard_irq,
+  .enable   = enable_surfboard_irq,
+  .disable  = disable_surfboard_irq,
+  .ack      = mask_and_ack_surfboard_irq,
+  .end      = end_surfboard_irq,
+};
+
+static inline int ls1bit32(unsigned int x)
+{
+	int b = 31, s;
+
+	s = 16; if (x << 16 == 0) s = 0; b -= s; x <<= s;
+	s =  8; if (x <<  8 == 0) s = 0; b -= s; x <<= s;
+	s =  4; if (x <<  4 == 0) s = 0; b -= s; x <<= s;
+	s =  2; if (x <<  2 == 0) s = 0; b -= s; x <<= s;
+	s =  1; if (x <<  1 == 0) s = 0; b -= s;
+
+	return b;
+}
+
+void surfboard_hw0_irqdispatch(void)
+{
+	struct irqaction *action;
+	unsigned long int_status;
+	int irq;
+
+	int_status = surfboard_hw0_icregs->irq0Status; 
+	/* if int_status == 0, then the interrupt has already been cleared */
+	if (int_status == 0)
+		return;
+	irq = ls1bit32(int_status);
+
+//	printk("-------------------------\n");
+//	printk("irqdispatch receive IRQ%d\n",irq);
+//	printk("-------------------------\n");
+	/*
+	 * RT2880:
+	 * bit[3] PIO Programmable IO Interrupt Status after Mask
+	 * bit[2] UART Interrupt Status after Mask
+	 * bit[1] WDTIMER Timer 1 Interrupt Status after Mask
+	 * bit[0] TIMER0 Timer 0 Interrupt Status after Mask
+	 *
+	 * RT2883/RT3052:
+	 * bit[17] Ethernet switch interrupt status after mask
+	 * bit[6] PIO Programmable IO Interrupt Status after Mask
+	 * bit[5] UART Interrupt Status after Mask
+	 * bit[2] WDTIMER Timer 1 Interrupt Status after Mask
+	 * bit[1] TIMER0 Timer 0 Interrupt Status after Mask
+	 */
+#ifdef CONFIG_RALINK_TIMER
+#if defined (CONFIG_RALINK_RT2880_SHUTTLE) || \
+    defined (CONFIG_RALINK_RT2880_MP)
+	if (irq == 0) {
+#else
+	if (irq == 1) {
+#endif
+		irq = SURFBOARDINT_TIMER0;
+	}
+#endif
+
+#if defined (CONFIG_RALINK_RT2880_SHUTTLE) ||   \
+    defined (CONFIG_RALINK_RT2880_MP)
+	if (irq == 3) {
+#ifdef CONFIG_RALINK_GPIO 
+		/* cause gpio registered irq 7 (see rt2880gpio_init_irq()) */
+		irq = SURFBOARDINT_GPIO;
+		printk("surfboard_hw0_irqdispatch(): INT #7...\n");
+#else
+		printk("surfboard_hw0_irqdispatch(): External INT #3... surfboard discard!\n");
+#endif
+	}
+#else
+	/* ILL_ACC */ 
+	if (irq == 3) {
+		irq = SURFBOARDINT_ILL_ACC;
+	}
+#endif
+#if defined (CONFIG_RALINK_PCM) || defined (CONFIG_RALINK_PCM_MODULE)
+	/* PCM */ 
+	if (irq == 4) {
+		irq = SURFBOARDINT_PCM;
+	}
+#endif
+	/* UARTF */ 
+	if (irq == 5) {
+		irq = SURFBOARDINT_UART;
+	}
+
+	action = irq_desc[irq].action;
+	do_IRQ(irq);
+	return;
+}
+
+
+static void enable_rt2880_cp_int(unsigned int IP_X)
+{
+	unsigned long int_status;
+
+	int_status = read_32bit_cp0_register(CP0_STATUS);
+	int_status = int_status | IP_X ;
+	write_32bit_cp0_register(CP0_STATUS, int_status);
+}
+
+static void disable_rt2880_cp_int(unsigned int IP_X)
+{
+	unsigned long int_status;
+	int_status = read_32bit_cp0_register(CP0_STATUS);
+	int_status = int_status & ~(IP_X);
+	write_32bit_cp0_register(CP0_STATUS, int_status);
+}
+
+void __init arch_init_irq(void)
+{
+	int i;
+
+	/*
+	 * Mask out all interrupt by writing "1" to all bit position in
+	 * the interrupt reset reg.
+	 */
+#if 1
+	int mips_cp0_cause, mips_cp0_status;
+        mips_cp0_cause = read_32bit_cp0_register(CP0_CAUSE);
+        mips_cp0_status = read_32bit_cp0_register(CP0_STATUS);
+        printk("cause = %x, status = %x\n", mips_cp0_cause, mips_cp0_status);
+        mips_cp0_status= mips_cp0_status& ~(CAUSEF_IP0|CAUSEF_IP1|CAUSEF_IP2|CAUSEF_IP3|CAUSEF_IP4|CAUSEF_IP5|CAUSEF_IP6|CAUSEF_IP7);
+        write_32bit_cp0_register(CP0_STATUS, mips_cp0_status);
+#endif
+	
+	memset(irq_desc, 0, sizeof(irq_desc));
+
+	for (i = 0; i <= SURFBOARDINT_END; i++) {
+		set_irq_chip(i, &surfboard_irq_type);
+	}
+
+	/* Enable global interrupt bit */
+//	surfboard_hw0_icregs->intDisable = 0xffffffff;
+	surfboard_hw0_icregs->intEnable = M_SURFBOARD_GLOBAL_INT;
+
+#ifdef CONFIG_RALINK_GPIO
+	ralink_gpio_init_irq();
+#endif
+
+#ifdef CONFIG_KGDB
+	if (remote_debug) {
+		set_debug_traps();
+		breakpoint();
+	}
+#endif
+}
+
+void rt2880_irqdispatch(void)
+{
+#if 1
+	unsigned long mips_cp0_status, mips_cp0_cause, irq_x, irq, i, pci_status=0;
+
+	mips_cp0_cause = read_32bit_cp0_register(CP0_CAUSE);
+	mips_cp0_status = read_32bit_cp0_register(CP0_STATUS);
+	irq_x = mips_cp0_cause & mips_cp0_status & 0xfc00;
+	irq_x >>= 10; //start from HW_INT#0
+	/* from low to high priority */
+	/*
+	   irq = 0;
+	   for (i = 0; i< 6; i++) {
+	   if(irq_x & 0x1)
+	   {
+	   if(irq != 0)
+	   do_IRQ(irq, regs);
+	   else
+	   surfboard_hw0_irqdispatch(regs);
+	   }
+	   irq++;
+	   irq_x >>= 1;
+	   }
+	   */
+	/* from high to low priority */
+	irq = 5;
+	pci_order^=1;
+
+#ifdef CONFIG_RAETH_ROUTER
+//	if(irq_x & 0x08)
+//		do_IRQ(irq, regs);
+#else
+	//if(irq_x & 0x10)
+	//	do_IRQ(irq, regs);
+#endif
+
+	for (i = 0; i< 6; i++) {
+		if(irq_x & 0x20)
+		{
+			disable_rt2880_cp_int(1<<(irq+10));
+			if(irq > 2)
+				do_IRQ(irq);
+			else if(irq == 2){
+			 //disable_rt2880_cp_int(CAUSEF_IP4);
+/*FIXME*/
+#if defined(CONFIG_RT2880_FPGA) || defined(CONFIG_RT2880_ASIC)
+			 pci_status = RALINK_PCI_PCIINT_ADDR;
+#endif
+			 if(pci_order ==0) { 
+#if defined(CONFIG_RT2880_ASIC) || \
+	defined (CONFIG_RT2883_ASIC) || \
+	defined (CONFIG_RT3052_ASIC) 
+				if(pci_status &0x40000)
+#elif defined(CONFIG_RT2880_FPGA) || \
+	defined (CONFIG_RT2883_FPGA) || \
+	defined(CONFIG_RT3052_FPGA)
+				if(pci_status &0x80000)
+#endif
+					do_IRQ(2);
+				else // if(pci_status & 0x40000)
+					do_IRQ(15);
+			 } else {
+#if defined(CONFIG_RT2880_ASIC)  || \
+	defined (CONFIG_RT2883_ASIC) || \
+	defined (CONFIG_RT3052_ASIC)
+				if(pci_status &0x80000)
+#elif defined(CONFIG_RT2880_FPGA) || \
+	defined (CONFIG_RT2883_FPGA) || \
+	defined(CONFIG_RT3052_FPGA)
+				if(pci_status &0x40000)
+#endif
+					do_IRQ(15);
+				else // if(pci_status & 0x80000)
+					do_IRQ(2);
+			 }
+
+			 //enable_rt2880_cp_int(CAUSEF_IP4);
+			}
+			else {
+				surfboard_hw0_irqdispatch();
+			}
+			enable_rt2880_cp_int(1<<(irq+10));
+		}
+		irq--;
+		irq_x <<= 1;
+	}
+#else
+	unsigned long int_status, int_cause;
+	u32 ill_acc_val;
+	
+	int_cause = read_32bit_cp0_register(CP0_CAUSE);
+	ill_acc_val = RALINK_SDRAM_ILL_ACC_ADDR;
+			
+	if(ill_acc_val != 0)
+	{
+		printk("\n RALINK_SDRAM_ILL_ACC_ADDR=[0x%08X]\n",ill_acc_val);
+		ill_acc_val = RALINK_SDRAM_ILL_ACC_TYPE;
+		RALINK_SDRAM_ILL_ACC_ADDR = 0xFFFFFFFF;
+		printk("\n RALINK_SDRAM_ILL_ACC_TYPE=[0x%08X]\n",ill_acc_val);
+			
+		//surfboard_hw0_icregs->irq0Status = 0;
+		//surfboard_hw0_icregs->irq1Status = 0;
+		return;
+				
+	}
+
+	if ((int_cause & CAUSEF_IP2))
+	{
+		
+		surfboard_hw0_irqdispatch();	
+	}	
+	else
+	{
+
+		if(( int_cause & CAUSEF_IP5 ))
+			do_IRQ(3); /* dispatch gmac irq here */	
+		else if(( int_cause & CAUSEF_IP4 ))
+		{//PCI slot
+			int_status = RALINK_PCI_PCIRAW_ADDR;
+			RALINK_PCI_PCIRAW_ADDR = 0xFFFFFFFF;
+
+			if(RALINK_PCI_PCIRAW_FAIL_STATUS & int_status)
+			{
+				printk("\n PCI fail status occur!! Status=[0x%08X] \n",int_status);
+				return;
+			}
+			
+			if((int_status & 0x000C0000))
+				do_IRQ(2); /* dispatch gmac irq here */		
+		}
+	}	
+#endif
+	
+	return;
+}
+asmlinkage void plat_irq_dispatch(void)
+{
+        unsigned int pending = read_c0_status() & read_c0_cause() & ST0_IM;
+        if (pending & CAUSEF_IP7)
+                mips_timer_interrupt();
+	else
+		rt2880_irqdispatch();
+}
Index: linux-2.6.21/arch/mips/rt2880/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/Kconfig	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,180 @@
+if RALINK_RT2880
+
+choice
+        prompt "Soc Hardware Type"
+	default RT2880_ASIC
+
+config  RT2880_ASIC 
+        bool "RT2880-ASIC"
+endchoice
+
+endif
+#-----------------------------
+
+if RALINK_RT3052
+
+choice
+        prompt "Soc Hardware Type"
+	default RT3052_ASIC
+
+config  RT3052_ASIC 
+        bool "RT3052-ASIC"
+endchoice
+
+endif
+
+#--------------------------
+
+config FLASH_REMAP_NEED
+       bool
+       default y if (RALINK_RT2880)
+choice
+       prompt "DRAM Size"
+       default RT2880_DRAM_16M
+
+config RT2880_DRAM_8M
+       bool "8M"
+
+config RT2880_DRAM_16M
+       bool "16M"
+
+config RT2880_DRAM_32M
+       bool "32M"
+
+config RT2880_DRAM_64M
+       bool "64M"
+
+endchoice
+
+
+choice
+       prompt "Flash Type"
+       default MTD_NOR_RALINK
+
+config MTD_NOR_RALINK
+       bool "NOR"
+
+config MTD_SPI_RALINK
+       bool "SPI"
+
+config MTD_NAND_RALINK
+       bool "NAND"
+
+endchoice
+
+
+choice
+       prompt "Flash Size"
+       default RT2880_FLASH_4M
+#       depends on  FLASH_REMAP_NEED
+       depends on  FLASH_REMAP_NEED || DUAL_IMAGE
+
+config RT2880_FLASH_2M
+       bool "2M"
+       depends on  !DUAL_IMAGE
+
+config RT2880_FLASH_4M
+       bool "4M"
+
+config RT2880_FLASH_8M
+       bool "8M"
+
+config RT2880_FLASH_16M
+       bool "16M"
+
+endchoice
+
+config  DUAL_IMAGE
+	bool 'Dual Image' 
+
+config  RT2880_FLASH_32M
+        bool "Flash Size 32MB Support"
+	depends on RALINK_RT3052_MP2
+	select MTD_CONCAT if RT2880_FLASH_32M
+
+config  RALINK_RAM_SIZE
+	int 
+	default 8 if RT2880_DRAM_8M
+	default 16 if RT2880_DRAM_16M
+	default 32 if RT2880_DRAM_32M
+	default 64 if RT2880_DRAM_64M
+
+config MTD_PHYSMAP_START
+       hex 
+       default 0xBFC00000 if RT2880_FLASH_2M && !RALINK_RT3052
+       default 0xBFC00000 if RT2880_FLASH_4M && !RALINK_RT3052
+       default 0xBF400000 if RT2880_FLASH_8M && !RALINK_RT3052
+       default 0xBEC00000 if RT2880_FLASH_16M && !RALINK_RT3052
+       default 0xBF000000 if RT2880_FLASH_32M && !RALINK_RT3052
+       default 0xBF000000 if !FLASH_REMAP_NEED && RALINK_RT3052
+
+config MTD_PHYSMAP_LEN
+       hex 
+       default 0x200000 if RT2880_FLASH_2M
+       default 0x400000 if RT2880_FLASH_4M
+       default 0x800000 if RT2880_FLASH_8M
+       default 0x1000000 if RT2880_FLASH_16M
+       default 0x2000000 if RT2880_FLASH_32M
+       default 0x1000000 if !FLASH_REMAP_NEED
+
+config MTD_PHYSMAP_BUSWIDTH
+       int 
+       default 2
+
+choice
+	prompt "Root File System Type"
+	default RT2880_ROOTFS_IN_RAM
+
+config  RT2880_ROOTFS_IN_RAM
+        bool "RootFS_in_RAM"
+	select BLK_DEV_INITRD 
+	select BLK_DEV_RAM 
+
+config  RT2880_ROOTFS_IN_FLASH
+        bool "RootFS_in_FLASH"
+endchoice
+
+config BLK_DEV_RAM_SIZE
+	int 'Default RAM disk size'
+	default 8192
+	depends on RT2880_ROOTFS_IN_RAM
+
+config	INITRAMFS_LZMA
+	bool "Compress ramdisk by lzma instead of gzip"
+	depends on RT2880_ROOTFS_IN_RAM
+
+config ROOTFS_IN_FLASH_NO_PADDING
+	bool 'No Padding between Kernel and RootFS'
+	default n
+	depends on RT2880_ROOTFS_IN_FLASH && !RT2880_FLASH_32M && !DUAL_IMAGE
+
+config MTD_KERNEL_PART_SIZ
+	hex 'MTD Kernel Partition Size (Unit:Bytes)'
+	default 0xD0000
+	depends on RT2880_ROOTFS_IN_FLASH && !ROOTFS_IN_FLASH_NO_PADDING
+
+config  RALINK_TIMER
+	tristate 'Ralink WatchDog' 
+
+config  RALINK_TIMER_WDG
+        bool "Ralink WatchDog Timer"
+        depends on RALINK_TIMER
+
+config  RALINK_TIMER_WDG_RESET_OUTPUT
+        bool "Ralink WatchDog Reset Output"
+        depends on RALINK_TIMER_WDG
+
+config  RALINK_WDG_TIMER
+        int "WatchDog Timer (Unit:1Sec, Max=30Sec)"
+        default 10
+        depends on RALINK_TIMER_WDG
+
+config  RALINK_WDG_REFRESH_INTERVAL
+        int "WatchDog Refresh Interval (Unit:1Sec, Max=30Sec)"
+        default 4
+        depends on RALINK_TIMER_WDG
+
+config  RALINK_TIMER_DFS
+        bool "Ralink DFS Timer"
+        depends on RALINK_TIMER
+
Index: linux-2.6.21/arch/mips/rt2880/lm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/lm.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,103 @@
+/*
+ *  linux/arch/arm/mach-integrator/lm.c
+ *
+ *  Copyright (C) 2003 Deep Blue Solutions Ltd, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+
+//#include <asm/arch/lm.h>
+#include <asm/rt2880/lm.h>
+
+#define to_lm_device(d)	container_of(d, struct lm_device, dev)
+#define to_lm_driver(d)	container_of(d, struct lm_driver, drv)
+
+static int lm_match(struct device *dev, struct device_driver *drv)
+{
+	return 1;
+}
+
+static struct bus_type lm_bustype = {
+	.name		= "logicmodule",
+	.match		= lm_match,
+//	.suspend	= lm_suspend,
+//	.resume		= lm_resume,
+};
+
+static int __init lm_init(void)
+{
+	return bus_register(&lm_bustype);
+}
+
+postcore_initcall(lm_init);
+
+static int lm_bus_probe(struct device *dev)
+{
+	struct lm_device *lmdev = to_lm_device(dev);
+	struct lm_driver *lmdrv = to_lm_driver(dev->driver);
+
+	if(lmdrv->probe !=NULL) {
+	    return lmdrv->probe(lmdev);
+	}
+}
+
+static int lm_bus_remove(struct device *dev)
+{
+	struct lm_device *lmdev = to_lm_device(dev);
+	struct lm_driver *lmdrv = to_lm_driver(dev->driver);
+
+	if(lmdrv->remove != NULL) {
+	    lmdrv->remove(lmdev);
+	}
+	return 0;
+}
+
+int lm_driver_register(struct lm_driver *drv)
+{
+	drv->drv.bus = &lm_bustype;
+	drv->drv.probe = lm_bus_probe;
+	drv->drv.remove = lm_bus_remove;
+
+	return driver_register(&drv->drv);
+}
+
+void lm_driver_unregister(struct lm_driver *drv)
+{
+	driver_unregister(&drv->drv);
+}
+
+static void lm_device_release(struct device *dev)
+{
+	struct lm_device *d = to_lm_device(dev);
+
+	kfree(d);
+}
+
+int lm_device_register(struct lm_device *dev)
+{
+	int ret;
+
+	dev->dev.release = lm_device_release;
+	dev->dev.bus = &lm_bustype;
+
+	snprintf(dev->dev.bus_id, sizeof(dev->dev.bus_id), "lm%d", dev->id);
+	dev->resource.name = dev->dev.bus_id;
+
+	ret = request_resource(&iomem_resource, &dev->resource);
+	if (ret == 0) {
+		ret = device_register(&dev->dev);
+		if (ret)
+			release_resource(&dev->resource);
+	}
+	return ret;
+}
+
+MODULE_LICENSE("GPL");
+EXPORT_SYMBOL(lm_device_register); //FIXME
+EXPORT_SYMBOL(lm_driver_register);
+EXPORT_SYMBOL(lm_driver_unregister);
Index: linux-2.6.21/arch/mips/rt2880/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/Makefile	2009-11-30 13:12:44.000000000 +0100
@@ -0,0 +1,20 @@
+###############################################################################
+#  Jan 2007 Bruce Chang
+#
+#  Initial Release
+#
+#
+#
+###############################################################################
+
+
+.S.s:
+	$(CPP) $(CFLAGS) $< -o $*.s
+.S.o:
+	$(CC) $(CFLAGS) -c $< -o $*.o
+
+obj-y    := mipsIRQ.o reset.o init.o irq.o \
+            memory.o printf.o cmdline.o setup.o time.o 
+obj-$(CONFIG_PCI) += pci.o
+obj-y += lm.o
+
Index: linux-2.6.21/arch/mips/rt2880/memory.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/memory.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,244 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     memory setup for Ralink RT2880 solution
+ *
+ *  Copyright 2007 Ralink Inc. (bruce_chang@ralinktech.com.tw)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2007 Bruce Chang
+ *
+ * Initial Release
+ *
+ *
+ *
+ **************************************************************************
+ */
+
+
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/ioport.h>
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+
+#include <asm/rt2880/prom.h>
+//#define DEBUG
+
+enum surfboard_memtypes {
+	surfboard_dontuse,
+	surfboard_rom,
+	surfboard_ram,
+};
+struct prom_pmemblock mdesc[PROM_MAX_PMEMBLOCKS];
+
+#ifdef DEBUG
+static char *mtypes[3] = {
+	"Dont use memory",
+	"Used ROM memory",
+	"Free RAM memory",
+};
+#endif
+
+/* References to section boundaries */
+extern char _end;
+
+#if defined(CONFIG_RT2880_ASIC) || defined(CONFIG_RT2880_FPGA)
+#define RAM_FIRST       0x08000400  /* Leave room for interrupt vectors */
+#define RAM_SIZE        CONFIG_RALINK_RAM_SIZE*1024*1024
+#define RAM_END         (0x08000000 + RAM_SIZE)
+#else
+#define RAM_FIRST       0x00000400  /* Leave room for interrupt vectors */
+#define RAM_SIZE        CONFIG_RALINK_RAM_SIZE*1024*1024
+#define RAM_END         (0x00000000 + RAM_SIZE)
+#endif
+struct resource rt2880_res_ram = {
+        .name = "RAM",
+        .start = 0,
+        .end = RAM_SIZE,
+        .flags = IORESOURCE_MEM
+};
+
+
+#define PFN_ALIGN(x)    (((unsigned long)(x) + (PAGE_SIZE - 1)) & PAGE_MASK)
+
+
+struct prom_pmemblock * __init prom_getmdesc(void)
+{
+	/*
+	*  Configures memory map based on Environment Variables set up by
+	*  surfmilo (linux loader):
+	*
+	*    rambase = base of useable SDRAM
+	*    ramsize = size of useable SDRAM
+	*
+	*  Assumptions made by linux:
+	*    The kernel variables (.data) immediately follow the kernel code
+	*      (.text) in memory.  The end of .data section, symbol _end,
+	*      is used to denote the end of the kernel.
+	*    The kernel code resides in ram, and all available ram exists
+	*      after the kernel.
+	*
+	*  Note: Cpu jump vectors are in remapped ISRAM/VECMEM,
+	*        which begins at 0000_0000
+	*
+	*        Linux memory map does not contain ISRAM since ISRAM
+	*        does not support DMA transfers.
+	*/
+	char *env_str;
+	unsigned int ramsize, rambase;
+
+	env_str = prom_getenv("ramsize");
+	if (!env_str) {
+		ramsize = CONFIG_RALINK_RAM_SIZE * 1024 * 1024;
+		prom_printf("ramsize = %d MBytes\n", CONFIG_RALINK_RAM_SIZE );
+	} else {
+#ifdef DEBUG
+		prom_printf("ramsize = %s\n", env_str);
+#endif
+		ramsize = simple_strtol(env_str, NULL, 0);
+	}
+
+	env_str = prom_getenv("rambase");
+	if (!env_str) {
+#if defined(CONFIG_RT2880_ASIC) || defined(CONFIG_RT2880_FPGA)
+		prom_printf("rambase not set, set to default (0x08000000)\n");
+		rambase = 0x08000000;
+#else
+		prom_printf("rambase not set, set to default (0x00000000)\n");
+		rambase = 0x00000000;
+#endif 
+	} else {
+#ifdef DEBUG
+		prom_printf("rambase = %s\n", env_str);
+#endif
+		rambase = simple_strtol(env_str, NULL, 0);
+	}
+
+	memset(mdesc, 0, sizeof(mdesc));
+
+	mdesc[0].type = surfboard_ram;
+	mdesc[0].base = rambase;
+	mdesc[0].size = ramsize;
+
+	return &mdesc[0];
+}
+#if 0
+static int __init prom_memtype_classify (unsigned int type)
+{
+	switch (type) {
+	case surfboard_ram:
+		return BOOT_MEM_RAM;
+	case surfboard_rom:
+		return BOOT_MEM_ROM_DATA;
+	default:
+		return BOOT_MEM_RESERVED;
+	}
+}
+#endif
+
+void __init prom_meminit(void)
+{
+	//struct prom_pmemblock *p;
+#ifdef DEBUG
+	struct prom_pmemblock *psave;
+#endif
+
+	//printk("ram start= %x, ram end= %x\n",rt2880_res_ram.start, rt2880_res_ram.end); 
+	//printk("size = %x\n",rt2880_res_ram.end - rt2880_res_ram.start); 
+ 	//add_memory_region(0x0a000000, rt2880_res_ram.end - rt2880_res_ram.start, BOOT_MEM_RAM);
+#if defined(CONFIG_RT2880_ASIC) || defined(CONFIG_RT2880_FPGA)
+ 	add_memory_region(0x08000000, RAM_SIZE, BOOT_MEM_RAM);
+#else
+        add_memory_region(0x00000000, RAM_SIZE, BOOT_MEM_RAM);
+#endif
+	
+	//p = prom_getmdesc();
+#ifdef DEBUG
+	prom_printf("MEMORY DESCRIPTOR dump:\n");
+	psave = p;	/* Save p */
+	while (p->size) {
+		int i = 0;
+		prom_printf("[%d,%p]: base<%08lx> size<%08lx> type<%s>\n",
+			    i, p, p->base, p->size, mtypes[p->type]);
+		p++;
+		i++;
+	}
+	p = psave;	/* Restore p */
+
+#endif
+#if 0
+	while (p->size) {
+		long type;
+		unsigned long base, size;
+
+		type = prom_memtype_classify (p->type);
+		base = p->base;
+		size = p->size;
+		add_memory_region(base, size, type);
+                p++;
+	}
+#endif
+}
+
+void __init prom_free_prom_memory(void)
+{
+        unsigned long addr;
+        int i;
+
+        for (i = 0; i < boot_mem_map.nr_map; i++) {
+                if (boot_mem_map.map[i].type != BOOT_MEM_ROM_DATA)
+                        continue;
+
+                addr = boot_mem_map.map[i].addr;
+                free_init_pages("prom memory",
+                                addr, addr + boot_mem_map.map[i].size);
+        }
+}
+#if 0
+void __init
+prom_free_prom_memory (void)
+{
+	int i;
+	unsigned long freed = 0;
+	unsigned long addr;
+
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		if (boot_mem_map.map[i].type != BOOT_MEM_ROM_DATA)
+			continue;
+
+		addr = boot_mem_map.map[i].addr;
+		while (addr < boot_mem_map.map[i].addr
+			      + boot_mem_map.map[i].size) {
+			ClearPageReserved(virt_to_page(__va(addr)));
+			set_page_count(virt_to_page(__va(addr)), 1);
+			free_page((unsigned long)__va(addr));
+			addr += PAGE_SIZE;
+			freed += PAGE_SIZE;
+		}
+	}
+	printk("Freeing prom memory: %ldkb freed\n", freed >> 10);
+}
+#endif
Index: linux-2.6.21/arch/mips/rt2880/mipsIRQ.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/mipsIRQ.S	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,122 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999, 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Interrupt exception dispatch code.
+ *
+ */
+
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+/* A lot of complication here is taken away because:
+ *
+ * 1) We handle one interrupt and return, sitting in a loop and moving across
+ *    all the pending IRQ bits in the cause register is _NOT_ the answer, the
+ *    common case is one pending IRQ so optimize in that direction.
+ *
+ * 2) We need not check against bits in the status register IRQ mask, that
+ *    would make this routine slow as hell.
+ *
+ * 3) Linux only thinks in terms of all IRQs on or all IRQs off, nothing in
+ *    between like BSD spl() brain-damage.
+ *
+ * Furthermore, the IRQs on the MIPS board look basically (barring software
+ * IRQs which we don't use at all and all external interrupt sources are
+ * combined together on hardware interrupt 0 (MIPS IRQ 2)) like:
+ *
+ *	MIPS IRQ	Source
+ *      --------        ------
+ *             0	Software (ignored)
+ *             1        Software (ignored)
+ *             2        Combined hardware interrupt (hw0)
+ *             3        Hardware (ignored)
+ *             4        Hardware (ignored)
+ *             5        Hardware (ignored)
+ *             6        Hardware (ignored)
+ *             7        R4k timer (what we use)
+ *
+ * Note: On the SEAD board thing are a little bit different.
+ *       Here IRQ 2 (hw0) is wired to the UART0 and IRQ 3 (hw1) is wired
+ *       wired to UART1.
+ *
+ * We handle the IRQ according to _our_ priority which is:
+ *
+ * Highest ----     R4k Timer
+ * Lowest  ----     Combined hardware interrupt
+ *
+ * then we just return, if multiple IRQs are pending then we will just take
+ * another exception, big deal.
+ */
+
+	.text
+	.set	noreorder
+	.set	noat
+	.align	5
+	NESTED(mipsIRQ, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+	.set	at
+
+	mfc0	s0, CP0_CAUSE		# get irq bits
+	mfc0	s1, CP0_STATUS		# get irq mask
+	and	s0, s1
+
+	/* First we check for r4k counter/timer IRQ. */
+	andi	a0, s0, CAUSEF_IP7
+	beq	a0, zero, 1f
+	andi	a0, s0, CAUSEF_IP2	# delay slot, check hw0 interrupt
+
+	/* Wheee, a timer interrupt. */
+	move	a0, sp
+	jal	mips_timer_interrupt
+	 nop
+
+	j	ret_from_irq
+	 nop
+
+1:
+	/* Wheee, combined hardware level zero interrupt. */
+#if defined(CONFIG_RALINK_RT2880) || defined(CONFIG_RALINK_RT3052) || defined(CONFIG_RALINK_RT2883)
+	jal	rt2880_irqdispatch
+#else
+#error "MIPS board not supported\n"
+#endif
+	 move	a0, sp			# delay slot
+
+	j	ret_from_irq
+	 nop				# delay slot
+
+1:
+	/*
+	 * Here by mistake?  This is possible, what can happen is that by the
+	 * time we take the exception the IRQ pin goes low, so just leave if
+	 * this is the case.
+	 */
+	move	a1,s0
+/*	PRINT("Got interrupt: c0_cause = %08x\n")*/
+	mfc0	a1, CP0_EPC
+/*	PRINT("c0_epc = %08x\n")*/
+
+	j	ret_from_irq
+	 nop
+	END(mipsIRQ)
Index: linux-2.6.21/arch/mips/rt2880/pci.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/pci.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,1050 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     PCI init for Ralink RT2880 solution
+ *
+ *  Copyright 2007 Ralink Inc. (bruce_chang@ralinktech.com.tw)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2007 Bruce Chang
+ *
+ * Initial Release
+ *
+ *
+ *
+ **************************************************************************
+ */
+
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <asm/pci.h>
+#include <asm/io.h>
+#include <asm/rt2880/eureka_ep430.h>
+#include <linux/init.h>
+#include <linux/mod_devicetable.h>
+
+#ifdef CONFIG_PCI
+
+
+
+/*
+ * These functions and structures provide the BIOS scan and mapping of the PCI
+ * devices.
+ */
+
+#define MAX_PCI_DEVS 10
+#if 1
+#define RT2880_PCI_SLOT1_BASE	0x20000000 //0x00510000 
+#define RT2880_PCI_SLOT1_END	RT2880_PCI_SLOT2_BASE -1
+#define RT2880_PCI_SLOT2_BASE	0x28000000 //0x00518000 
+#define RT2880_PCI_SLOT2_END	0x2fffffff //0x0051ffff 
+
+#define RT2880_PCI_SLOT1_1_BASE	RT2880_PCI_SLOT1_BASE+0x04000000
+#define RT2880_PCI_SLOT1_2_BASE	RT2880_PCI_SLOT1_BASE+0x05000000
+#define RT2880_PCI_SLOT1_3_BASE	RT2880_PCI_SLOT1_BASE+0x06000000
+#define RT2880_PCI_SLOT1_4_BASE	RT2880_PCI_SLOT1_BASE+0x07000000
+#define RT2880_PCI_SLOT1_5_BASE	RT2880_PCI_SLOT1_BASE+0x07800000
+
+#define RT2880_PCI_SLOT2_1_BASE	RT2880_PCI_SLOT2_BASE+0x04000000
+#define RT2880_PCI_SLOT2_2_BASE	RT2880_PCI_SLOT2_BASE+0x05000000
+#define RT2880_PCI_SLOT2_3_BASE	RT2880_PCI_SLOT2_BASE+0x06000000
+#define RT2880_PCI_SLOT2_4_BASE	RT2880_PCI_SLOT2_BASE+0x07000000
+#define RT2880_PCI_SLOT2_5_BASE	RT2880_PCI_SLOT2_BASE+0x07800000
+#else
+#define RT2880_PCI_SLOT1_BASE	0x00510000 
+#define RT2880_PCI_SLOT1_END	RT2880_PCI_SLOT2_BASE -1
+#define RT2880_PCI_SLOT2_BASE	0x00518000 
+#define RT2880_PCI_SLOT2_END	0x0051ffff 
+#endif
+
+#define PCI_ACCESS_READ  0
+#define PCI_ACCESS_WRITE 1
+
+//extern pci_probe_only;
+
+void __inline__ read_config(unsigned long bus, unsigned long dev, unsigned long func, unsigned long reg, unsigned long *val);
+void __inline__ write_config(unsigned long bus, unsigned long dev, unsigned long func, unsigned long reg, unsigned long val);
+#if 0
+/*  Functions to implement "pci ops"  */
+static int rt2880_pcibios_read_config_word(struct pci_dev *dev,
+					    int offset, u16 * val);
+static int rt2880_pcibios_read_config_byte(struct pci_dev *dev,
+					    int offset, u8 * val);
+static int rt2880_pcibios_read_config_dword(struct pci_dev *dev,
+					     int offset, u32 * val);
+static int rt2880_pcibios_write_config_byte(struct pci_dev *dev,
+					     int offset, u8 val);
+static int rt2880_pcibios_write_config_word(struct pci_dev *dev,
+					     int offset, u16 val);
+static int rt2880_pcibios_write_config_dword(struct pci_dev *dev,
+					      int offset, u32 val);
+#endif
+
+static int config_access(unsigned char access_type, struct pci_bus *bus,
+                         unsigned int devfn, unsigned char where,
+                         u32 * data)
+{
+  unsigned int slot = PCI_SLOT(devfn);
+  u8 func = PCI_FUNC(devfn);
+  uint32_t address_reg, data_reg;
+  unsigned int address;
+
+  address_reg = EUREKA_EP430_PCI_CONFIG_ADDR;
+  data_reg = EUREKA_EP430_PCI_CONFIG_DATA_VIRTUAL_REG;
+
+  /* Setup address */
+  address = (bus->number << 16) | (slot << 11) | (func << 8) | (where& 0xfc) | 0x80000000;
+
+  /* start the configuration cycle */
+  MV_WRITE(address_reg, address);
+
+  if (access_type == PCI_ACCESS_WRITE){
+    MV_WRITE(data_reg, *data);
+  }else{
+    MV_READ(data_reg, data);
+  }
+  return 0;
+}
+
+
+
+static int read_config_byte(struct pci_bus *bus, unsigned int devfn,
+                            int where, u8 * val)
+{
+  u32 data;
+  int ret;
+
+  ret = config_access(PCI_ACCESS_READ, bus, devfn, where, &data);
+  *val = (data >> ((where & 3) << 3)) & 0xff;
+  return ret;
+}
+
+static int read_config_word(struct pci_bus *bus, unsigned int devfn,
+                            int where, u16 * val)
+{
+  u32 data;
+  int ret;
+
+  ret = config_access(PCI_ACCESS_READ, bus, devfn, where, &data);
+  *val = (data >> ((where & 3) << 3)) & 0xffff;
+  return ret;
+}
+
+static int read_config_dword(struct pci_bus *bus, unsigned int devfn,
+                             int where, u32 * val)
+{
+  int ret;
+
+  ret = config_access(PCI_ACCESS_READ, bus, devfn, where, val);
+  return ret;
+}
+static int
+write_config_byte(struct pci_bus *bus, unsigned int devfn, int where,
+                  u8 val)
+{
+  u32 data = 0;
+
+  if (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))
+    return -1;
+
+  data = (data & ~(0xff << ((where & 3) << 3))) |
+    (val << ((where & 3) << 3));
+
+  if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))
+    return -1;
+
+  return PCIBIOS_SUCCESSFUL;
+}
+
+static int
+write_config_word(struct pci_bus *bus, unsigned int devfn, int where,
+                  u16 val)
+{
+  u32 data = 0;
+
+  if (config_access(PCI_ACCESS_READ, bus, devfn, where, &data))
+    return -1;
+
+  data = (data & ~(0xffff << ((where & 3) << 3))) |
+    (val << ((where & 3) << 3));
+
+  if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))
+    return -1;
+
+
+  return PCIBIOS_SUCCESSFUL;
+}
+
+static int
+write_config_dword(struct pci_bus *bus, unsigned int devfn, int where,
+                   u32 val)
+{
+  if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &val))
+    return -1;
+
+  return PCIBIOS_SUCCESSFUL;
+}
+
+static int pci_config_read(struct pci_bus *bus, unsigned int devfn,
+                       int where, int size, u32 * val)
+{
+   switch (size) {
+  case 1:
+    return read_config_byte(bus, devfn, where, (u8 *) val);
+  case 2:
+    return read_config_word(bus, devfn, where, (u16 *) val);
+  default:
+    return read_config_dword(bus, devfn, where, val);
+  }
+}
+
+static int pci_config_write(struct pci_bus *bus, unsigned int devfn,
+                        int where, int size, u32 val)
+{
+  switch (size) {
+  case 1:
+    return write_config_byte(bus, devfn, where, (u8) val);
+  case 2:
+    return write_config_word(bus, devfn, where, (u16) val);
+  default:
+    return write_config_dword(bus, devfn, where, val);
+  }
+}
+
+
+/*
+ *  General-purpose PCI functions.
+ */
+
+struct pci_ops rt2880_pci_ops= {
+  .read =  pci_config_read,
+  .write = pci_config_write,
+};
+
+static struct resource rt2880_res_pci_mem1 = {
+  .name = "PCI MEM1",
+//  .start = 0,
+//  .end = 0x0fffffff,
+  .start = 0x20000000,
+  .end = 0x2FFFFFFF,
+  .flags = IORESOURCE_MEM,
+};
+static struct resource rt2880_res_pci_io1 = {
+  .name = "PCI I/O1",
+  .start = 0x00460000,
+  .end = 0x0046FFFF,
+//  .start = 0,
+//  .end = 0xffff,
+  .flags = IORESOURCE_IO,
+};
+
+struct pci_controller rt2880_controller = {
+  .pci_ops = &rt2880_pci_ops,
+  .mem_resource = &rt2880_res_pci_mem1,
+  .io_resource = &rt2880_res_pci_io1,
+  .mem_offset     = 0x00000000UL,
+  .io_offset      = 0x00000000UL,
+};
+
+
+/*
+ * pci_range_ck -
+ *
+ * Check if the pci device that are trying to access does really exists
+ * on the evaluation board.  
+ *
+ * Inputs :
+ * bus - bus number (0 for PCI 0 ; 1 for PCI 1)
+ * dev - number of device on the specific pci bus
+ *
+ * Outpus :
+ * 0 - if OK , 1 - if failure
+ */
+static __inline__ int pci_range_ck(unsigned char bus, unsigned char dev)
+{
+	/* Accessing device 31 crashes the MV-64340. */
+	return 0;
+	if (dev < 5)
+		return 0;
+	return -1;
+}
+
+void __inline__ read_config(unsigned long bus, unsigned long dev, unsigned long func, unsigned long reg, unsigned long *val)
+{
+	unsigned long address_reg, data_reg, address;
+
+ 	address_reg = EUREKA_EP430_PCI_CONFIG_ADDR;
+        data_reg = EUREKA_EP430_PCI_CONFIG_DATA_VIRTUAL_REG;
+
+        /* set addr */
+        address = (bus << 16) | (dev << 11) | (func << 8) | (reg & 0xfc) | 0x80000000 ;
+
+        /* start the configuration cycle */
+        MV_WRITE(address_reg, address);
+        /* read the data */
+        MV_READ(data_reg, val);
+	return;
+}
+
+void __inline__ write_config(unsigned long bus, unsigned long dev, unsigned long func, unsigned long reg, unsigned long val)
+{
+	unsigned long address_reg, data_reg, address;
+
+ 	address_reg = EUREKA_EP430_PCI_CONFIG_ADDR;
+        data_reg = EUREKA_EP430_PCI_CONFIG_DATA_VIRTUAL_REG;
+
+        /* set addr */
+        address = (bus << 16) | (dev << 11) | (func << 8) | (reg & 0xfc) | 0x80000000;
+
+        /* start the configuration cycle */
+        MV_WRITE(address_reg, address);
+        /* read the data */
+        MV_WRITE(data_reg, val);
+	return;
+}
+
+/*
+ * marvell_pcibios_(read/write)_config_(dword/word/byte) -
+ *
+ * reads/write a dword/word/byte register from the configuration space
+ * of a device.
+ *
+ * Note that bus 0 and bus 1 are local, and we assume all other busses are
+ * bridged from bus 1.  This is a safe assumption, since any other
+ * configuration will require major modifications to the CP7000G
+ *
+ * Inputs :
+ * bus - bus number
+ * dev - device number
+ * offset - register offset in the configuration space
+ * val - value to be written / read
+ *
+ * Outputs :
+ * PCIBIOS_SUCCESSFUL when operation was succesfull
+ * PCIBIOS_DEVICE_NOT_FOUND when the bus or dev is errorneous
+ * PCIBIOS_BAD_REGISTER_NUMBER when accessing non aligned
+ */
+#if 0
+static int rt2880_pcibios_read_config_dword(struct pci_dev *device,
+					      int offset, u32* val)
+{
+	int dev, bus, func;
+	uint32_t address_reg, data_reg;
+	uint32_t address;
+
+	bus = device->bus->number;
+	dev = PCI_SLOT(device->devfn);
+	func = PCI_FUNC(device->devfn);
+
+	/* verify the range */
+	if (pci_range_ck(bus, dev))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/* select the MV-64340 registers to communicate with the PCI bus */
+	
+		address_reg = EUREKA_EP430_PCI_CONFIG_ADDR;
+		data_reg = EUREKA_EP430_PCI_CONFIG_DATA_VIRTUAL_REG;
+	
+
+	address = (bus << 16) | (dev << 11) | (func << 8) |
+		(offset & 0xfc) | 0x80000000;
+
+	/* start the configuration cycle */
+	MV_WRITE(address_reg, address);
+
+	/* read the data */
+	MV_READ(data_reg, val);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+
+static int rt2880_pcibios_read_config_word(struct pci_dev *device,
+					     int offset, u16* val)
+{
+	int dev, bus, func;
+	uint32_t address_reg, data_reg;
+	uint32_t address,temp;
+
+	bus = device->bus->number;
+	dev = PCI_SLOT(device->devfn);
+	func = PCI_FUNC(device->devfn);
+
+	/* verify the range */
+	if (pci_range_ck(bus, dev))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/* select the MV-64340 registers to communicate with the PCI bus */
+	
+		address_reg = EUREKA_EP430_PCI_CONFIG_ADDR;
+		data_reg = EUREKA_EP430_PCI_CONFIG_DATA_VIRTUAL_REG;
+	
+
+	address = (bus << 16) | (dev << 11) | (func << 8) |
+		(offset & 0xfc) | 0x80000000;
+
+	/* start the configuration cycle */
+	MV_WRITE(address_reg, address);
+
+	/* read the data */
+	//MV_READ_16(data_reg + (offset & 0x3), val);
+	/* read the data */
+	MV_READ(data_reg, &temp);
+
+	switch(offset % 4)
+    {
+        case 0:
+	case 1:
+	    temp &= 0x0000FFFF;
+	    break;
+	case 2:
+	case 3:
+	    temp &= 0xFFFF0000;
+	    temp = temp >> 16;
+	    break;
+    }
+	*val = (u16)temp;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int rt2880_pcibios_read_config_byte(struct pci_dev *device,
+					     int offset, u8* val)
+{
+	int dev, bus, func;
+	uint32_t address_reg, data_reg;
+	uint32_t address;
+	uint32_t temp;
+
+	bus = device->bus->number;
+	dev = PCI_SLOT(device->devfn);
+	func = PCI_FUNC(device->devfn);
+
+	/* verify the range */
+	if (pci_range_ck(bus, dev))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/* select the MV-64340 registers to communicate with the PCI bus */
+	
+		address_reg = EUREKA_EP430_PCI_CONFIG_ADDR;
+		data_reg = EUREKA_EP430_PCI_CONFIG_DATA_VIRTUAL_REG;
+	
+
+	address = (bus << 16) | (dev << 11) | (func << 8) |
+		(offset & 0xfc) | 0x80000000;
+
+	/* start the configuration cycle */
+	MV_WRITE(address_reg, address);
+
+	/* read the data */
+	MV_READ(data_reg, &temp);
+
+
+	/* read the data */
+	//MV_READ(data_reg, val);
+	
+	/* write the data */
+	//MV_READ_8(data_reg + (offset & 0x3), val);
+
+	switch(offset % 4)
+    {
+        case 0:
+	    temp &= 0x000000FF;
+	    break;
+	case 1:
+	    temp &= 0x0000FF00;
+   	    temp = temp >> 8;
+	    break;
+	case 2:
+            temp &= 0x00FF0000;
+            temp = temp >> 16;
+            break;
+ 	case 3:
+            temp &= 0xFF000000;
+            temp = temp >> 24;
+ 	break;
+    }
+
+	*val = (u8)temp;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int rt2880_pcibios_write_config_dword(struct pci_dev *device,
+					      int offset, u32 val)
+{
+	int dev, bus, func;
+	uint32_t address_reg, data_reg;
+	uint32_t address;
+
+	bus = device->bus->number;
+	dev = PCI_SLOT(device->devfn);
+	func = PCI_FUNC(device->devfn);
+
+	/* verify the range */
+	if (pci_range_ck(bus, dev))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/* select the MV-64340 registers to communicate with the PCI bus */
+	
+		address_reg = EUREKA_EP430_PCI_CONFIG_ADDR;
+		data_reg = EUREKA_EP430_PCI_CONFIG_DATA_VIRTUAL_REG;
+	
+
+	address = (bus << 16) | (dev << 11) | (func << 8) |
+		(offset & 0xfc) | 0x80000000;
+
+	/* start the configuration cycle */
+	MV_WRITE(address_reg, address);
+
+	/* write the data */
+	MV_WRITE(data_reg, val);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+
+static int rt2880_pcibios_write_config_word(struct pci_dev *device,
+					     int offset, u16 val)
+{
+	int dev, bus, func;
+	uint32_t address_reg, data_reg;
+	uint32_t address,temp;
+
+	bus = device->bus->number;
+	dev = PCI_SLOT(device->devfn);
+	func = PCI_FUNC(device->devfn);
+
+	/* verify the range */
+	if (pci_range_ck(bus, dev))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/* select the MV-64340 registers to communicate with the PCI bus */
+	
+		address_reg = EUREKA_EP430_PCI_CONFIG_ADDR;
+		data_reg = EUREKA_EP430_PCI_CONFIG_DATA_VIRTUAL_REG;
+	
+	address = (bus << 16) | (dev << 11) | (func << 8) |
+		(offset & 0xfc) | 0x80000000;
+
+	/* start the configuration cycle */
+	MV_WRITE(address_reg, address);
+	
+
+	/* read the data */
+	MV_READ(data_reg, &temp);
+
+	switch(offset % 4)
+    { 
+        case 0:
+		case 1:
+			temp &= 0xFFFF0000;
+            temp += val;
+	    
+	    break;
+		case 2:
+		case 3:
+            temp &= 0x0000FFFF;
+            temp += (u32)(((u32)val) << 16);
+	    
+		break;
+    }
+
+	
+	/* write the data */
+	MV_WRITE(data_reg, temp);
+	
+
+	/* write the data */
+	//MV_WRITE_16(data_reg + (offset & 0x3), val);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int rt2880_pcibios_write_config_byte(struct pci_dev *device,
+					     int offset, u8 val)
+{
+	int dev, bus, func;
+	uint32_t address_reg, data_reg;
+	uint32_t address,temp;
+
+	bus = device->bus->number;
+	dev = PCI_SLOT(device->devfn);
+	func = PCI_FUNC(device->devfn);
+
+	/* verify the range */
+	if (pci_range_ck(bus, dev))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/* select the MV-64340 registers to communicate with the PCI bus */
+	
+		address_reg = EUREKA_EP430_PCI_CONFIG_ADDR;
+		data_reg = EUREKA_EP430_PCI_CONFIG_DATA_VIRTUAL_REG;
+	
+
+	address = (bus << 16) | (dev << 11) | (func << 8) |
+		(offset & 0xfc) | 0x80000000;
+
+	/* start the configuration cycle */
+	MV_WRITE(address_reg, address);
+
+	/* read the data */
+	MV_READ(data_reg, &temp);
+
+ 	switch (offset % 4)
+    {
+        case 0:
+	    temp &= 0xFFFFFF00;
+	    temp += val;
+	     break;
+	case 1:
+		temp &= 0xFFFF00FF;
+	    temp += (u32)(((u32)val) << 8);
+	    break;
+	case 2:
+		temp &= 0xFF00FFFF;
+	    temp += (u32)(((u32)val) << 16);
+	     break;
+	case 3:
+   	    temp &= 0x00FFFFFF;
+	    temp += (u32)(((u32)val) << 24);
+	    break;
+    }
+
+//--------------------------	
+
+	/* write the data */
+//	MV_WRITE_8(data_reg + (offset & 0x3), val);
+
+	/* write the data */
+	MV_WRITE(data_reg, temp);
+
+
+	return PCIBIOS_SUCCESSFUL;
+}
+#endif
+
+
+#if 0
+void __init pcibios_fixup_bus(struct pci_bus *bus)
+{
+	struct pci_bus *current_bus = bus;
+	struct pci_dev *devices;
+	struct list_head *devices_link;
+	u32 cmd;
+	/* loop over all known devices on this bus */
+	//printk("%s %s():%d\n",__FILE__,__FUNCTION__,__LINE__);
+	list_for_each(devices_link, &(current_bus->devices)) {
+
+		devices = pci_dev_b(devices_link);
+		if (devices == NULL)
+			continue;
+		#if 0
+		if ((current_bus->number == 0) &&
+			(PCI_SLOT(devices->devfn) == 1) &&
+			(PCI_FUNC(devices->devfn) == 0)) {
+			/* LSI 53C10101R SCSI (A) */
+			devices->irq = 2;
+		} else if ((current_bus->number == 0) &&
+			(PCI_SLOT(devices->devfn) == 1) &&
+			(PCI_FUNC(devices->devfn) == 1)) {
+			/* LSI 53C10101R SCSI (B) */
+			devices->irq = 2;
+		} else if ((current_bus->number == 1) &&
+			(PCI_SLOT(devices->devfn) == 1)) {
+			/* Intel 21555 bridge */
+			devices->irq = 12;
+		} else if ((current_bus->number == 1) &&
+			(PCI_SLOT(devices->devfn) == 2)) {
+			/* PMC Slot */
+			devices->irq = 4;
+		} else {
+			/* We don't have assign interrupts for other devices. */
+			devices->irq = 0xff;
+		}
+		#endif
+		/* Assign an interrupt number for the device */
+		//bus->ops->write_byte(devices, PCI_INTERRUPT_LINE, devices->irq);
+
+		/* enable master for everything but the MV-64340 */
+		//if (((current_bus->number != 0) && (current_bus->number != 1))
+		//		|| (PCI_SLOT(devices->devfn) != 0)) {
+		//	bus->ops->read(devices, PCI_COMMAND, &cmd);
+		//	cmd |= PCI_COMMAND_MASTER;
+		//	bus->ops->write(devices, PCI_COMMAND, cmd);
+		//}
+	}
+	//mv64340_board_pcibios_fixup_bus(c);
+}
+#endif
+#if 0
+int pci_scan(unsigned long slot)
+{
+	unsigned long val, i, BaseAddr, data = 0;
+	//int io_set=0, mem_set=0;
+	
+	//printk("%s %s():%d\n",__FILE__,__FUNCTION__,__LINE__);
+	BaseAddr = PCI_BASE_ADDRESS_0;
+
+	read_config(0, slot, 0, 0, &val);
+	if(val !=0){
+	  for (i=0;i<2;i++, BaseAddr+=4) {  //detect resource usage
+	
+	  write_config(0, slot, 0, BaseAddr, 0xffffffff);
+	  read_config(0, slot, 0, BaseAddr, &data);
+	  //printk("write %d 0xffffffff and read back %x\n", i, data);
+          if (data!=0) {  //resource request exist
+              int j;
+              if (data&1) {  //IO space
+		  //if(io_set == 1)
+		//	  continue;
+                  //pci_config->BAR[i].Type = IO_SPACE;
+                  //scan resource size
+                  for (j=2;j<32;j++)
+                      if (data&(1<<j)) break;
+		  if(j>16){
+			printk("slot 0x%x, request memory over 32k, not support\n", slot);
+			return -1;
+		  }
+		  if(slot == 0x11)
+		    write_config(0, slot, 0, BaseAddr, 0x00520000);
+		  else if(slot == 0x12)
+		    write_config(0, slot, 0, BaseAddr, 0x00528000);
+
+		    read_config(0, slot, 0, BaseAddr, &data);
+		    //printk(" ********* %x\n", data);
+		  //io_set = 1;
+                  //if (j<32) pci_config->BAR[i].Size = 1<<j;
+                  //else  pci_config->BAR[i].Size = 0;
+              } else {  //Memory space
+		  //if(mem_set == 1)
+		//	  continue;
+                  //pci_config->BAR[i].Type = MEM_SPACE;
+                  //bus width
+                  if ((data&0x0006)==4) {
+		    //pci_config->BAR[i].Width = WIDTH64; //bus width 64
+		    printk("slot 0x%x, 64bit, not support\n", slot);
+		    return -1;
+		  }
+                  //else 
+		     //pci_config->BAR[i].Width = WIDTH32;  //bus width 32
+
+                  //prefetchable
+                  //if (data&0x0008) pci_config->BAR[i].Prefetch = 1; //prefetchable
+                  //else pci_config->BAR[i].Prefetch = 0;  //no prefetch
+                  //scan resource size
+                  //if (pci_config->BAR[i].Width==WIDTH32) {
+                    for (j=4;j<32;j++)
+                      if (data&(1<<j)) break;
+		    if(j>16){
+			printk("slot 0x%x, request memory over 32k, not support\n", slot);
+			return -1;
+		    }
+		  if(slot == 0x11)
+		    write_config(0, slot, 0, BaseAddr, RT2880_PCI_SLOT1_BASE);
+		  else if(slot == 0x12)
+		    write_config(0, slot, 0, BaseAddr, RT2880_PCI_SLOT2_BASE);
+
+		    //read_config(0, slot, 0, BaseAddr, &data);
+		    //printk(" ********* %x\n", data);
+		    //mem_set = 1;
+                    //if (j<32) pci_config->BAR[i].Size = 1<<j;
+                    //else  pci_config->BAR[i].Size = 0;
+                  //} else //width64 is not support
+                  //  pci_config->BAR[i].Size = 0;
+              };
+          } else {  //no resource
+              //memset(&(pci_config->BAR[i]), 0, sizeof(base_address_s));
+		printk("slot 0x%x, error access\n", slot);
+		return -1;
+          };
+    	  };//for
+	} else {
+	  printk("slot 0x%x empty\n", slot);
+	}
+}
+void pcibios_fixup_resources(struct pci_dev *dev)
+{
+
+	u16 cmd;
+	u32 bus, devid, func;
+
+		printk("*********************%s %s():%d\n",__FILE__,__FUNCTION__,__LINE__);
+		pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 0x14);  //configure cache line size 0x14
+  		pci_write_config_byte(dev, PCI_LATENCY_TIMER, 0xFF);  //configure latency timer 0x10
+		//Set device
+		pci_read_config_word(dev, PCI_COMMAND, &cmd);		
+#if 0
+		cmd = cmd | PCI_COMMAND_MASTER | PCI_COMMAND_IO | PCI_COMMAND_MEMORY;
+		cmd |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);			 
+#else
+		cmd = cmd | PCI_COMMAND_MASTER | PCI_COMMAND_IO | PCI_COMMAND_MEMORY |
+			PCI_COMMAND_INVALIDATE | PCI_COMMAND_FAST_BACK | PCI_COMMAND_SERR |
+			PCI_COMMAND_WAIT | PCI_COMMAND_PARITY;
+#endif
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+		
+        	bus = dev->bus->number;
+        	devid = PCI_SLOT(dev->devfn);
+        	func = PCI_FUNC(dev->devfn);
+		//printk("bus = %d, dev = %d, fun = %d\n", bus,devid,func);
+		
+		if (bus == 0 && (devid == 0x11 ||devid==0x12) ) {
+
+		unsigned long i, j, BaseAddr;
+		u32 val, data=0;
+		int mem_cnt=0;
+		struct resource *res;
+		BaseAddr = PCI_BASE_ADDRESS_0;
+
+		pci_write_config_dword(dev, BaseAddr, ~0);
+		pci_read_config_dword(dev, BaseAddr, &val);
+		if(val !=0){	//find the card
+	  	  for (i=0;i<3;i++, BaseAddr+=4) {  //detect resource usage
+			pci_write_config_dword(dev, BaseAddr, ~0);
+			pci_read_config_dword(dev, BaseAddr, &data);
+			res = &dev->resource[i];
+          		if (data!=0) {  //resource request exist
+              		  if (data&1) {  //IO space
+
+				for (j=2;j<32;j++)
+				  if (data&(1<<j)) break;	
+		  		if(devid == 0x11){
+	  			  pci_write_config_dword(dev, BaseAddr, 0x00460000);
+				  res->start = 0x00460000;
+				  res->end = 0x00467FFF;
+				}
+		  		else if(devid == 0x12){
+	  			  pci_write_config_dword(dev, BaseAddr, 0x00528000);
+				  res->start = 0x00528000;
+				  res->end = 0x0052FFFF;
+				}
+
+				pci_read_config_dword(dev, BaseAddr, &data);
+		    		//printk(" ********* %x\n", data);
+              		  } else { //memory space 
+				for (j=4;j<32;j++)
+                      		  if (data&(1<<j)) break;
+
+		  		if(devid == 0x11){
+				 if(mem_cnt==0) {
+	  			  pci_write_config_dword(dev, BaseAddr, RT2880_PCI_SLOT1_BASE);
+				  res->start = RT2880_PCI_SLOT1_BASE;
+				  //res->size = 1<<j;
+				  res->end = RT2880_PCI_SLOT1_BASE + (1<<j) -1;
+				 }else if(mem_cnt==1){
+	  			  pci_write_config_dword(dev, BaseAddr, RT2880_PCI_SLOT1_1_BASE);
+				  res->start = RT2880_PCI_SLOT1_1_BASE;
+				  //res->size = 1<<j;
+				  res->end = RT2880_PCI_SLOT1_1_BASE + (1<<j) -1;
+				 }
+				}
+		  		else if(devid== 0x12){
+				 if(mem_cnt==0) {
+	  			  pci_write_config_dword(dev, BaseAddr, RT2880_PCI_SLOT2_BASE);
+				  res->start = RT2880_PCI_SLOT2_BASE;
+				  //res->size = 1<<j;
+				  res->end = RT2880_PCI_SLOT2_BASE + (1<<j) -1;
+				 }else if(mem_cnt==1){
+	  			  pci_write_config_dword(dev, BaseAddr, RT2880_PCI_SLOT2_1_BASE);
+				  res->start = RT2880_PCI_SLOT2_1_BASE;
+				  //res->size = 1<<j;
+				  res->end = RT2880_PCI_SLOT2_1_BASE + (1<<j) -1;
+				 }
+				}
+
+				pci_read_config_dword(dev, BaseAddr, &data);
+				//printk("start = 0x%08x, end = 0x%08x\n", res->start, res->end);
+		    		//printk(" ********* %x\n", data);
+				mem_cnt++;
+              		  }//if(data&1)
+          		}else{
+				printk("%s %s():%d   ",__FILE__,__FUNCTION__,__LINE__);
+				printk("baseaddr = %x\n", BaseAddr);
+			}//if(data!=0)
+		  }//for
+		}else{
+			printk(" slot =%d configuration space access error\n", devid);
+		}
+		if(devid == 0x11) {
+			dev->irq = 2;
+			pci_write_config_byte(dev, PCI_INTERRUPT_LINE, 2);
+			//pci_write_config_byte(dev, PCI_INTERRUPT_PIN, 2);
+		}else if(devid == 0x12) {
+			dev->irq = 15;
+			pci_write_config_byte(dev, PCI_INTERRUPT_LINE, 15);
+			//pci_write_config_byte(dev, PCI_INTERRUPT_PIN, 15);
+		}
+
+		}
+
+		return;
+
+}
+#endif
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+  u16 cmd;
+  u32 val;
+  struct resource *res;
+  int i;
+  if (dev->bus->number != 0) {
+    return 0;
+  }
+  slot = PCI_SLOT(dev->devfn);
+
+  if(slot == 0) {
+  	write_config(0, 0, 0, PCI_BASE_ADDRESS_0, 0x08000000);
+  	read_config(0, 0, 0, PCI_BASE_ADDRESS_0, &val);
+  	dev->irq = 0;
+    res = &dev->resource[0];
+    res->start = 0x08000000;
+    res->end   = 0x09ffffff;
+ 	printk("BAR0 at slot 0 = %x\n", val);
+  }else if(slot ==0x11){
+	dev->irq = 2;
+  }else if(slot==0x12){
+	dev->irq = 15;
+  }else{
+  	return 0;
+  }	
+
+  for(i=0;i<6;i++){
+    res = &dev->resource[i];
+    //printk("res[%d]->start = %x\n", i, res->start);
+    //printk("res[%d]->end = %x\n", i, res->end);
+  }
+
+  pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 0x14);  //configure cache line size 0x14
+  pci_write_config_byte(dev, PCI_LATENCY_TIMER, 0xFF);  //configure latency timer 0x10
+#if 1
+  pci_read_config_word(dev, PCI_COMMAND, &cmd);
+  cmd = cmd | PCI_COMMAND_MASTER | PCI_COMMAND_IO | PCI_COMMAND_MEMORY |
+  	PCI_COMMAND_INVALIDATE | PCI_COMMAND_FAST_BACK | PCI_COMMAND_SERR |
+  	PCI_COMMAND_WAIT | PCI_COMMAND_PARITY;
+  pci_write_config_word(dev, PCI_COMMAND, cmd);
+#endif
+  pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
+  //pci_write_config_byte(dev, PCI_INTERRUPT_PIN, dev->irq);
+  return (dev->irq);
+}
+
+int init_rt2880pci(void)
+{
+	unsigned long val = 0;
+	int i;
+
+
+	//pci_probe_only = 1;
+	RALINK_PCI_PCICFG_ADDR = 0;
+	for(i=0;i<0xfffff;i++);
+	RT2880_PCI_ARBCTL = 0x79;
+	//printk(" RT2880_PCI_ARBCTL = %x\n", RT2880_PCI_ARBCTL);
+
+/*
+	ioport_resource.start = rt2880_res_pci_io1.start;
+  	ioport_resource.end = rt2880_res_pci_io1.end;
+*/
+
+	RALINK_PCI_BAR0SETUP_ADDR = 0x07FF0001;//0x07ff0001;	//open 32M
+	//RALINK_PCI_BAR1SETUP_ADDR = 0;
+	RT2880_PCI_MEMBASE = RT2880_PCI_SLOT1_BASE;
+	RT2880_PCI_IOBASE = 0x00460000;
+	RALINK_PCI_IMBASEBAR0_ADDR = 0x08000000;
+
+	RT2880_PCI_ID = 0x08021814;
+	RT2880_PCI_CLASS = 0x00800001;
+	RT2880_PCI_SUBID = 0x28801814;
+
+	RALINK_PCI_PCIMSK_ADDR = 0x000c0000; // enable pci interrupt
+
+	write_config(0, 0, 0, PCI_BASE_ADDRESS_0, 0x08000000);
+	read_config(0, 0, 0, PCI_BASE_ADDRESS_0, &val);
+	printk("BAR0 at slot 0 = %x\n", val);
+/*
+	val = RALINK_PCI_PCIMSK_ADDR;
+	val |= 0x000C0000;
+	RALINK_PCI_PCIMSK_ADDR = val;
+*/
+	register_pci_controller(&rt2880_controller);
+	return 0;
+
+}
+#if 0
+void __init pcibios_fixup_irqs(void)
+{
+    struct pci_dev *dev;
+
+        pci_for_each_dev(dev) {
+                dev->irq = 2; // fix irq
+        }
+}
+#endif
+
+
+#if 0
+void __init rt2880_pcibios_init(void)
+{
+	//printk("\n pcibios_init is called ioport_resource = %08X\n",&ioport_resource);
+	//printk("\n pcibios_init is called iomem_resource = %08X\n",&iomem_resource);
+	
+	/* Reset PCI I/O and PCI MEM values */
+	/* Reset PCI I/O and PCI MEM values */
+	//ioport_resource.start = 0;//0xc0000000;
+	//ioport_resource.end   = 0;//0xc0000000 + 0x20000000 - 1;
+	//iomem_resource.start  = 0;//0xc0000000;
+	//iomem_resource.end    = 0;//0xc0000000 + 0x20000000 - 1;
+	
+	//printk("%s %s():%d\n",__FILE__,__FUNCTION__,__LINE__);
+	init_rt2880pci();
+		
+	pci_scan_bus(0, &rt2880_pci_ops, NULL);
+
+	//pci_scan(0x11);
+	//pci_scan(0x12);
+
+	//pcibios_fixup_irqs();
+}
+#endif
+
+arch_initcall(init_rt2880pci);
+
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
+struct pci_fixup pcibios_fixups[] = {
+//	{PCI_ANY_ID, PCI_ANY_ID, pcibios_fixup_resources },
+	{0}
+};
+//DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, pcibios_fixup_resources)
+#endif	/* CONFIG_PCI */
Index: linux-2.6.21/arch/mips/rt2880/power-button.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/power-button.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,419 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <asm/io.h>
+#include <asm/delay.h>
+#include <asm/page.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <asm/uaccess.h>
+
+#define jiffiespersec		HZ
+
+#define surf_standby		2
+#define surf_active		4
+#define surf_boot		5
+#define surf_halt		6
+#define surf_restore_settings	7
+#define surf_changing_state	8
+
+#define surf_ns_unknown		0
+#define surf_ns_must_halt	1
+#define surf_ns_must_not_halt	2
+
+//these times are in m-sec
+#define surf_halt_blink_rate			1000
+#define surf_boot_blink_rate			500
+#define surf_restore_settings_blink_rate	250
+
+//these times are in sec
+#define surf_halt_enable_time			2
+#define surf_boot_enable_time			10
+#define surf_restore_settings_enable_time	15
+#define surf_do_nothing_time			20
+#ifdef CONFIG_RALINK_FLASH_API
+#define FLASH_WRITE_LOCATION	0x10000
+#else
+#define FLASH_WRITE_LOCATION	0xbfc00000+0x10000
+#endif
+#define FLASH_ERASE_SECTOR	1
+#define SURF_BUTTON_INTERRUPT	4
+#define SURF_TIMER_INTERRUPT 	1
+
+#define SURF_TIMER_BASE		0x300100
+#define SURF_TMR_STAT		0x0
+#define SURF_TMR1LOAD		0x20
+#define SURF_TMR1CTL		0x28
+#define SURF_POWER_BUTTON_MASK	0x8
+#define TIMER_LOAD_VALUE	0xff
+
+#define SURF_PIO_BASE		0x300600
+#define SURF_BTNINT		0x40
+#define SURF_BTNRMASK		0x48
+#define SURF_BTNFMASK		0x4C
+#define SURF_PIODATA2		0x60
+#define SURF_PIOPOL2		0x64
+#define SURF_LEDCFG		0x68
+#define SURF_LED0_MASK		0x00010000
+#define SURF_BTN0_MASK		SURF_POWER_BUTTON_MASK
+#define SURF_LED0_USE_DATA_REGISTER	0x00000001
+
+#define INIT_CTL		"/dev/initctl"
+#define FIFO_FILE		"tmp/system"
+#define PROC_ENTRY		"surf_status"
+
+#define SURF_IN(base, reg, val) do { * ((unsigned int *)KSEG1ADDR( base + reg )) = val; } while(0)
+#define SURF_OUT(base, reg) *((unsigned int *)KSEG1ADDR( base + reg ))
+
+#define EnableTimer SURF_IN( SURF_TIMER_BASE, SURF_TMR1CTL, 0x9f )
+#define DisableTimer SURF_IN( SURF_TIMER_BASE, SURF_TMR1CTL, 0x1f ) 
+#define ActiveBoard  { 		unsigned int temp=SURF_OUT(SURF_PIO_BASE, SURF_PIODATA2) | SURF_LED0_MASK; \
+				SURF_IN( SURF_PIO_BASE, SURF_PIODATA2, temp ); \
+				surf_button_state=surf_board_state=surf_active; \
+				DisableTimer; }
+
+// static volatile unsigned int pio_btn_edge;
+static struct proc_dir_entry *button_dir, *status_file;
+static const char MODULE_NAME[]={"p-button"};
+static volatile int surf_board_state=surf_standby;
+static volatile int surf_button_state=surf_boot;
+static volatile int surf_btn_push_jiffies=-1;
+static void surf_events_bh(void *dummy);
+
+
+// Data structure written to flash memory 
+struct flashData 
+{
+	unsigned int boot_to_standby_prefrence;
+	unsigned int need_standby;
+} flash_data;
+
+
+int WriteToFlash(char *buff, int size) //return 0 for success
+{
+	if( FlashErase(FLASH_ERASE_SECTOR, FLASH_ERASE_SECTOR) != 0 )
+		return 0;
+	FlashWrite(buff, FLASH_WRITE_LOCATION, size);
+}
+
+void ReadFromFlash(char *buff, int size)
+{
+	memcpy(buff, FLASH_WRITE_LOCATION, size);
+}
+
+static struct tq_struct surf_events_task  = {
+        routine:        surf_events_bh,
+};
+
+static unsigned int should_boot_to_standby()
+{
+	ReadFromFlash(&flash_data, sizeof(flash_data));
+	return flash_data.boot_to_standby_prefrence;
+}
+
+struct init_request {
+	int	magic;			/* Magic number                 */
+	int	cmd;			/* What kind of request         */
+	int	runlevel;		/* Runlevel to change to        */
+	int	sleeptime;		/* Time between TERM and KILL   */
+	char 	data[368];
+};
+
+
+static int proc_read_status(char *page, char **start,
+                            off_t off, int count, 
+                            int *eof, void *data)
+{
+	return 0;
+}
+
+
+static int proc_write_status(struct file *file,
+                             const char *buffer,
+                             unsigned long count, 
+                             void *data)
+{
+	char lbuf[64];
+	int len=64;
+	if( count < len)
+		len = count;
+	
+	if(copy_from_user(lbuf, buffer, len))
+	{
+		return -EFAULT;
+	}
+
+	if( strncmp(lbuf, "reboot_complete", 15)==0)
+	{
+		ActiveBoard;
+	}
+	else if( strncmp(lbuf, "standby_on", 10)==0)
+	{
+		flash_data.boot_to_standby_prefrence=1;
+		WriteToFlash(&flash_data, sizeof(flash_data));	
+	}
+	else if( strncmp(lbuf, "standby_off", 11)==0)
+	{
+		flash_data.boot_to_standby_prefrence=0;
+		WriteToFlash(&flash_data, sizeof(flash_data));	
+	}
+	else printk("unknown message: %d\n", lbuf);
+
+        return len;
+}
+
+
+static int create_proc()
+{
+        int rv = 0;
+
+        /* create directory */
+        button_dir = proc_mkdir(MODULE_NAME, NULL);
+        if(button_dir == NULL)
+		return rv;
+        
+        button_dir->owner = THIS_MODULE;
+        
+        status_file = create_proc_entry(PROC_ENTRY, 0644, button_dir);
+        if(status_file == NULL)
+	{
+		remove_proc_entry(MODULE_NAME, NULL);
+		return rv;
+	}
+
+        status_file->read_proc = NULL;
+        status_file->write_proc = proc_write_status;
+        status_file->owner = THIS_MODULE;
+        
+        return rv;
+}
+
+static void surf_events_bh(void *dummy)
+{
+	switch( surf_button_state )
+	{
+		case surf_active:
+			ActiveBoard;
+			break;
+		case surf_halt:
+		case surf_boot:
+			flash_data.need_standby=(surf_button_state==surf_halt)?surf_ns_must_halt:surf_ns_must_not_halt;
+			WriteToFlash(&flash_data, sizeof(flash_data));
+			{
+				// init 6 - Reboot
+				struct file *filep = NULL;
+				struct init_request req;
+				req.magic=0x03091969;		//this magic number is needly exactly to enter run-level
+				req.cmd=0x1;			
+				req.runlevel='6';		//run level 6 requested
+				req.sleeptime=5;
+				bzero(req.data, sizeof(req.data));
+
+				//Now pass message to init controller
+				filep = filp_open(INIT_CTL, O_WRONLY, 0); 
+				if( filep != NULL )
+				{
+					filep->f_op->write(filep, &req, sizeof(req), &filep->f_pos);
+					filp_close(filep, NULL);
+				}
+			}
+			break;
+		case surf_restore_settings:
+			{
+				struct file *filep = NULL;
+				filep = filp_open(FIFO_FILE, O_WRONLY, 0); 
+				if( filep != NULL )
+				{
+					filep->f_op->write(filep, "restore_settings", 16, &filep->f_pos);
+					filp_close(filep, NULL);
+				}				
+			}
+			ActiveBoard;
+			break;
+	}
+}
+
+static void inline SetButtonInterrupt(unsigned int reg)
+{
+	SURF_IN( SURF_PIO_BASE, SURF_BTNRMASK, reg);
+	SURF_IN( SURF_PIO_BASE, SURF_BTNFMASK, reg);
+}
+
+static void inline button_released()
+{
+	surf_btn_push_jiffies=-1;
+	if( surf_board_state==surf_active)
+	{
+		surf_board_state=surf_changing_state;
+		schedule_task(&surf_events_task);
+	}
+}
+	
+
+static inline void update_LED()
+{
+	static unsigned int lastjiffies=0;
+	unsigned int ledstatus = SURF_OUT(SURF_PIO_BASE, SURF_PIODATA2);
+	int blink = 1;				//if this is set to 0 the blinking effect is disabled
+	int diff= jiffies - lastjiffies;
+	diff *= (1000 / jiffiespersec);		// diff now contains the number of milliseconds passed since last this function was called
+
+
+	//surf halt should blink every 1000ms, surf_boot should blink every 500ms and surf_restore_settings should blink every 250ms
+	switch( surf_button_state )
+	{
+		case surf_active:
+			blink=0;
+			break;
+		case surf_halt:
+			if ( diff < surf_halt_blink_rate) return; 
+			break;
+		case surf_boot:
+			if ( diff < surf_boot_blink_rate) return;
+			break;
+		case surf_restore_settings:
+			if ( diff < surf_restore_settings_blink_rate) return;
+			break;
+	}
+
+	//for alternate behaviour (blinking), toggle the ledstatus bit of 1st led
+	if( blink && (ledstatus & SURF_LED0_MASK) )
+		ledstatus &= (~SURF_LED0_MASK);
+	else
+		ledstatus |= SURF_LED0_MASK;
+	SURF_IN(SURF_PIO_BASE, SURF_PIODATA2, ledstatus);
+
+	lastjiffies = jiffies;
+}
+
+static void surf_timer_interrupt(int irq, void *dev, struct pt_regs *regs)
+{
+	int total_time;
+
+	//clear timer intstat
+	SURF_IN( SURF_TIMER_BASE, SURF_TMR_STAT, 0x2);	
+
+	DisableTimer;
+
+	if(surf_btn_push_jiffies != -1)
+	{
+		total_time = jiffies - surf_btn_push_jiffies;
+		total_time /= jiffiespersec;
+
+		// change button status based on the time passed since the button was bushed
+		if( total_time >= surf_do_nothing_time )
+			surf_btn_push_jiffies=jiffies;
+
+		else if( total_time >= surf_restore_settings_enable_time )
+		{
+			surf_button_state=surf_restore_settings;
+		}
+
+		else if( total_time >= surf_boot_enable_time )
+			surf_button_state=surf_boot;
+
+		else if( total_time >= surf_halt_enable_time )
+			surf_button_state=surf_halt;
+
+		else surf_button_state=surf_active;
+	}
+	
+	update_LED();
+	EnableTimer;
+}
+
+static inline void surf_button_interrupt(int irq, void *dev, struct pt_regs *regs)
+{
+	unsigned int pio_btn_data = SURF_OUT(SURF_PIO_BASE, SURF_PIODATA2); 
+
+	//clear btn instat
+	SURF_IN( SURF_PIO_BASE, SURF_BTNINT, 0xffffffff); 
+
+	switch( surf_board_state )
+	{
+		case surf_active:
+			if( pio_btn_data & SURF_POWER_BUTTON_MASK)
+			{
+				surf_btn_push_jiffies=jiffies;
+				EnableTimer;
+			}
+			else
+			{
+				button_released();
+			}
+			break;
+		case surf_standby:
+			surf_board_state=surf_changing_state;
+			break;
+	}
+}
+
+int power_button_init_module()
+{
+	int status;
+
+	//reset timer
+	SURF_IN(SURF_TIMER_BASE, SURF_TMR_STAT, 0x20);
+
+	//register interrupt
+	request_irq(SURF_BUTTON_INTERRUPT, surf_button_interrupt, SA_INTERRUPT, MODULE_NAME, NULL);
+	request_irq(SURF_TIMER_INTERRUPT, surf_timer_interrupt, SA_INTERRUPT, MODULE_NAME, NULL);
+
+	//initialize timer
+	SURF_IN( SURF_TIMER_BASE, SURF_TMR1LOAD, TIMER_LOAD_VALUE) ;
+
+	// enable interrupts on 4th button
+
+	SetButtonInterrupt(SURF_POWER_BUTTON_MASK);
+
+	//initialze led, use 1st led
+	status = SURF_OUT( SURF_PIO_BASE, SURF_BTNFMASK);
+	status &= (~SURF_LED0_MASK);
+	status |= SURF_LED0_USE_DATA_REGISTER;
+	SURF_IN( SURF_PIO_BASE, SURF_LEDCFG, status);
+
+	//set proper polarity values
+	status = SURF_OUT( SURF_PIO_BASE, SURF_PIOPOL2);
+	status |= (SURF_LED0_MASK | SURF_BTN0_MASK); 
+	SURF_IN( SURF_PIO_BASE, SURF_PIOPOL2, status);
+
+	//turn the led off
+	SURF_IN( SURF_PIO_BASE, SURF_PIODATA2, SURF_OUT(SURF_PIO_BASE, SURF_PIODATA2) & (~SURF_LED0_MASK) );
+
+	//check the flash register to ready boot to standy prefrence, in case of garbage value write default
+	ReadFromFlash(&flash_data, sizeof(flash_data));
+	if( flash_data.boot_to_standby_prefrence > 1)
+	{
+		flash_data.boot_to_standby_prefrence=1;
+	}
+	if( flash_data.need_standby==surf_ns_unknown && should_boot_to_standby() || flash_data.need_standby==surf_ns_must_halt)
+	{
+		printk("Press button to start booting...\n");
+		while (surf_board_state==surf_standby);
+	}
+	flash_data.need_standby=surf_ns_unknown;
+	WriteToFlash(&flash_data, sizeof(flash_data));
+
+	// Enable timer to show the light blinking (board is booting status)
+	EnableTimer;
+
+	// Create proc enteries, so as user processes can change boot prefrence	
+	if( create_proc() != 0)
+	{
+		printk("error creating proc enteries for surf_status\n");
+		ActiveBoard;	
+	}
+
+	return 0;	
+}
+
+void power_button_cleanup_module()
+{
+	//free IRQ
+	free_irq(SURF_TIMER_INTERRUPT, NULL);
+	free_irq(SURF_BUTTON_INTERRUPT, NULL);
+
+	//remove proc enteries
+        remove_proc_entry("surf_status", button_dir);
+        remove_proc_entry(MODULE_NAME, NULL);
+}
Index: linux-2.6.21/arch/mips/rt2880/printf.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/printf.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,120 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     prom_printf for Ralink RT2880 solution
+ *
+ *  Copyright 2007 Ralink Inc. (bruce_chang@ralinktech.com.tw)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2007 Bruce Chang
+ *
+ * Initial Release
+ *
+ *
+ *
+ **************************************************************************
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+//#include <linux/serial_reg.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include "serial_rt2880.h"
+
+#include <asm/rt2880/surfboard.h>
+#include <asm/rt2880/rt_mmap.h>
+
+static unsigned int uart_base;
+
+
+static inline unsigned int serial_in(int offset)
+{
+	//return inb(PORT(offset));
+//	return inb(uart_base + offset);
+	return inl( uart_base + offset);
+}
+
+static inline void serial_out(int offset, int value)
+{
+	//outb(value, PORT(offset));
+	//outb(value, uart_base + offset);
+	outl(value,  uart_base + offset);
+}
+
+int putPromChar(char c)
+{
+	while ((serial_in(UART_LSR) & UART_LSR_THRE) == 0)
+		;
+
+	serial_out(UART_TX, c);
+
+	return 1;
+}
+
+char getPromChar(void)
+{
+	while (!(serial_in(UART_LSR) & 1))
+		;
+
+	return serial_in(UART_RX);
+}
+
+void __init prom_setup_printf(int tty_no)
+{
+	if (tty_no == 1)
+		uart_base = RALINK_UART_LITE_BASE;
+	else	/* Default = ttys0 */
+		uart_base = RALINK_UART_BASE;
+}
+
+static spinlock_t con_lock = SPIN_LOCK_UNLOCKED;
+
+static char buf[1024];
+
+/* NOTE:  must call prom_setup_printf before using this function */
+void __init prom_printf(char *fmt, ...)
+{
+	va_list args;
+	int l;
+	char *p, *buf_end;
+	long flags;
+
+	int putPromChar(char);
+
+	spin_lock_irqsave(con_lock, flags);
+	va_start(args, fmt);
+	l = vsprintf(buf, fmt, args); /* hopefully i < sizeof(buf) */
+	va_end(args);
+
+	buf_end = buf + l;
+
+	for (p = buf; p < buf_end; p++) {
+		/* Crude cr/nl handling is better than none */
+		if (*p == '\n')
+			putPromChar('\r');
+		putPromChar(*p);
+	}
+	spin_unlock_irqrestore(con_lock, flags);
+}
Index: linux-2.6.21/arch/mips/rt2880/reset.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/reset.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,73 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     reboot/reset setting for Ralink RT2880 solution
+ *
+ *  Copyright 2007 Ralink Inc. (bruce_chang@ralinktech.com.tw)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2007 Bruce Chang
+ *
+ * Initial Release
+ *
+ *
+ *
+ **************************************************************************
+ */
+
+
+
+#include <asm/reboot.h>
+#include <asm/rt2880/generic.h>
+#include <linux/pm.h>
+
+static void mips_machine_restart(char *command);
+static void mips_machine_halt(void);
+static void mips_machine_power_off(void);
+
+static void mips_machine_restart(char *command)
+{
+	*(volatile unsigned int*)(SOFTRES_REG) = GORESET;
+}
+
+static void mips_machine_halt(void)
+{
+	*(volatile unsigned int*)(SOFTRES_REG) = GORESET;
+}
+
+static void mips_machine_power_off(void)
+{
+	*(volatile unsigned int*)(POWER_DIR_REG) = POWER_DIR_OUTPUT;
+	*(volatile unsigned int*)(POWER_POL_REG) = 0;
+	*(volatile unsigned int*)(POWEROFF_REG) = POWEROFF;
+}
+
+
+void mips_reboot_setup(void)
+{
+	_machine_restart = mips_machine_restart;
+	_machine_halt = mips_machine_halt;
+	//_machine_power_off = mips_machine_power_off;
+	pm_power_off = mips_machine_power_off;
+}
Index: linux-2.6.21/arch/mips/rt2880/rt_timer.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/rt_timer.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,136 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/rt2880/surfboardint.h>
+#include <linux/interrupt.h>
+#include "rt_timer.h"
+
+
+static int wdg_load_value;
+struct timer_list wdg_timer;
+
+void set_wdg_timer_ebl(unsigned int timer, unsigned int ebl)
+{
+    unsigned int result;
+
+    result = sysRegRead(timer);
+    if(ebl)
+		result |= (1<<7);
+    else
+		result &= ~(1<<7);
+    sysRegWrite(timer, result);
+
+#if defined (CONFIG_RALINK_RT2880)
+    if(timer == TMR1CTL)
+	{
+		result = sysRegRead(CLKCFG);
+		if(ebl)
+		    result |= (1<<9); /* SRAM_CS_N */
+		else
+		    result &= ~(1<<9);
+		sysRegWrite(CLKCFG,result);
+    }
+#elif defined (CONFIG_RALINK_RT3052_MP2) || defined(CONFIG_RALINK_RT2883)
+    if(timer==TMR1CTL)
+	{
+		result = sysRegRead(SYSCFG);
+		if(ebl)
+		    result |= (1<<2); /* SRAM_CS_MODE */
+		else
+			resukt &= ~(1<<2)
+		sysRegWrite(SYSCFG,result);
+    }
+#endif
+}
+
+
+static void
+set_wdg_timer_clock_prescale(unsigned int timer, enum timer_clock_freq prescale)
+{
+    unsigned int result;
+
+    result = sysRegRead(timer);
+    result &= ~0xF;
+    result = result | (prescale & 0xF);
+    sysRegWrite(timer,result);
+
+}
+
+static void
+set_wdg_timer_mode(unsigned int timer, enum timer_mode mode)
+{
+    unsigned int result;
+
+    result = sysRegRead(timer);
+    result &= ~(0x3<<4);
+    result = result | (mode << 4);
+    sysRegWrite(timer, result);
+
+}
+
+void setup_wdg_timer(struct timer_list * timer,
+	void (*function)(unsigned long),
+	unsigned long data)
+{
+    timer->function = function;
+    timer->data = data;
+    init_timer(timer);
+}
+
+void refresh_wdg_timer(unsigned long unused)
+{
+    sysRegWrite(TMR1LOAD, wdg_load_value);
+
+    wdg_timer.expires = jiffies + HZ * CONFIG_RALINK_WDG_REFRESH_INTERVAL;
+    add_timer(&wdg_timer);
+}
+
+
+int32_t __init timer_init_module(void)
+{
+    printk("Load RT2880 Timer Module(Wdg/Soft)\n");
+
+    /* 
+     * System Clock = CPU Clock/2
+     * For user easy configuration, We assume the unit of watch dog timer is 1s, 
+     * so we need to calculate the TMR1LOAD value.
+     *
+     * Unit= 1/(SysClk/65536), 1 Sec = (SysClk)/65536 
+     *
+     */
+
+#if defined (CONFIG_RALINK_TIMER_WDG)   
+    // initialize WDG timer (Timer1)
+    setup_wdg_timer(&wdg_timer, refresh_wdg_timer, 0);
+    set_wdg_timer_mode(TMR1CTL,WATCHDOG);
+    set_wdg_timer_clock_prescale(TMR1CTL,SYS_CLK_DIV65536);
+    wdg_load_value = CONFIG_RALINK_WDG_TIMER * (get_surfboard_sysclk()/65536);
+    refresh_wdg_timer(wdg_load_value);
+    set_wdg_timer_ebl(TMR1CTL,1);
+#endif
+
+    return 0;
+}
+
+void __exit timer_cleanup_module(void)
+{
+    printk("Unload RT2880 Timer Module(Wdg/Soft)\n");
+
+#if defined (CONFIG_RALINK_TIMER_WDG)   
+    set_wdg_timer_ebl(TMR1CTL,0);
+    del_timer_sync(&wdg_timer);
+#endif
+}
+
+module_init(timer_init_module);
+module_exit(timer_cleanup_module);
+
+
+MODULE_DESCRIPTION("Ralink Timer Module(Wdg/Soft)");
+MODULE_AUTHOR("Steven/Bob");
+MODULE_LICENSE("GPL");
Index: linux-2.6.21/arch/mips/rt2880/rt_timer.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/rt_timer.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,105 @@
+/*
+ ***************************************************************************
+ * Ralink Tech Inc.
+ * 4F, No. 2 Technology 5th Rd.
+ * Science-based Industrial Park
+ * Hsin-chu, Taiwan, R.O.C.
+ *
+ * (c) Copyright 2002-2006, Ralink Technology, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * ***************************************************************************
+
+    Module Name:
+    rt_timer.h
+
+    Abstract:
+
+    Revision History:
+    Who         When            What
+    --------    ----------      ----------------------------------------------
+    Name        Date            Modification logs
+    Steven Liu  2007-07-04      Initial version
+*/
+
+#include <asm/rt2880/rt_mmap.h>
+
+#ifndef _TIMER_WANTED
+#define _TIMER_WANTED
+
+#define PHYS_TO_K1(physaddr) KSEG1ADDR(physaddr)
+#define sysRegRead(phys) (*(volatile unsigned int *)PHYS_TO_K1(phys))
+#define sysRegWrite(phys, val)  ((*(volatile unsigned int *)PHYS_TO_K1(phys)) = (val))
+
+#define SYSCFG      RALINK_SYSCTL_BASE + 0x10  /* System Configuration Register */
+#define CLKCFG      RALINK_SYSCTL_BASE + 0x30  /* Clock Configuration Register */
+#define TMRSTAT     (RALINK_TIMER_BASE)  /* Timer Status Register */
+#define TMR0LOAD    (TMRSTAT + 0x10)  /* Timer0 Load Value */
+#define TMR0VAL     (TMRSTAT + 0x14)  /* Timer0 Counter Value */
+#define TMR0CTL     (TMRSTAT + 0x18)  /* Timer0 Control */
+#define TMR1LOAD    (TMRSTAT + 0x20)  /* Timer1 Load Value */
+#define TMR1VAL     (TMRSTAT + 0x24)  /* Timer1 Counter Value */
+#define TMR1CTL     (TMRSTAT + 0x28)  /* Timer1 Control */
+
+#define INTENA      (RALINK_INTCL_BASE + 0x34)  /* Interrupt Enable */
+
+struct timer0_data {
+	unsigned long expires;
+	unsigned long data;
+	void (*tmr0_callback_function)(unsigned long);
+	spinlock_t      tmr0_lock;
+};
+
+
+enum timer_mode {
+    FREE_RUNNING,
+    PERIODIC,
+    TIMEOUT,
+    WATCHDOG
+};
+
+enum timer_clock_freq {
+    SYS_CLK,          /* System clock     */
+    SYS_CLK_DIV4,     /* System clock /4  */
+    SYS_CLK_DIV8,     /* System clock /8  */
+    SYS_CLK_DIV16,    /* System clock /16 */
+    SYS_CLK_DIV32,    /* System clock /32 */
+    SYS_CLK_DIV64,    /* System clock /64 */
+    SYS_CLK_DIV128,   /* System clock /128 */
+    SYS_CLK_DIV256,   /* System clock /256 */
+    SYS_CLK_DIV512,   /* System clock /512 */
+    SYS_CLK_DIV1024,  /* System clock /1024 */
+    SYS_CLK_DIV2048,  /* System clock /2048 */
+    SYS_CLK_DIV4096,  /* System clock /4096 */
+    SYS_CLK_DIV8192,  /* System clock /8192 */
+    SYS_CLK_DIV16384, /* System clock /16384 */
+    SYS_CLK_DIV32768, /* System clock /32768 */
+    SYS_CLK_DIV65536  /* System clock /65536 */
+};
+
+int request_tmr_service(int interval, void (*function)(unsigned long), unsigned long data);
+int unregister_tmr_service(void);
+
+#endif
+
+
Index: linux-2.6.21/arch/mips/rt2880/serial_rt2880.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/serial_rt2880.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,402 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     serial port definition for Ralink RT2880 solution
+ *
+ *  Copyright 2007 Ralink Inc. (bruce_chang@ralinktech.com.tw)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2007 Bruce Chang
+ *
+ * Initial Release
+ *
+ *
+ *
+ **************************************************************************
+ */
+
+#if defined (CONFIG_RALINK_RT2880) || \
+    defined (CONFIG_RALINK_RT2883) || \
+    defined (CONFIG_RALINK_RT3052)
+
+#define UART_RX		0	/* In:  Receive buffer (DLAB=0) */
+
+#define UART_TX		4	/* Out: Transmit buffer (DLAB=0) */
+#define UART_TRG	4	/* (LCR=BF) FCTR bit 7 selects Rx or Tx
+				 * In: Fifo count
+				 * Out: Fifo custom trigger levels
+				 * XR16C85x only
+				 */
+
+#define UART_IER	8	/* Out: Interrupt Enable Register */
+#define UART_FCTR	8	/* (LCR=BF) Feature Control Register
+				 * XR16C85x only
+				 */
+
+#define UART_IIR	12	/* In:  Interrupt ID Register */
+#define UART_EFR	12	/* I/O: Extended Features Register */
+				/* (DLAB=1, 16C660 only) */
+
+#define UART_FCR	16	/* Out: FIFO Control Register */
+#define UART_LCR	20	/* Out: Line Control Register */
+#define UART_MCR	24	/* Out: Modem Control Register */
+#define UART_LSR	28	/* In:  Line Status Register */
+#define UART_MSR	32	/* In:  Modem Status Register */
+#define UART_SCR	36	/* I/O: Scratch Register */
+#define UART_DLL	40	/* Out: Divisor Latch Low (DLAB=1) */
+/* Since surfboard uart cannot be accessed by byte, using UART_DLM will cause
+ * unpredictable values to be written to the Divisor Latch
+ */
+#define UART_DLM	41	/* Out: Divisor Latch High (DLAB=1) */
+
+#else
+
+#define UART_RX		0	/* In:  Receive buffer */
+#define UART_TX		0	/* Out: Transmit buffer */
+#define UART_DLL	0	/* Out: Divisor Latch Low */
+#define UART_TRG	0	/* FCTR bit 7 selects Rx or Tx
+				 * In: Fifo count
+				 * Out: Fifo custom trigger levels */
+
+#define UART_DLM	1	/* Out: Divisor Latch High */
+#define UART_IER	1	/* Out: Interrupt Enable Register */
+#define UART_FCTR	1	/* Feature Control Register */
+
+#define UART_IIR	2	/* In:  Interrupt ID Register */
+#define UART_FCR	2	/* Out: FIFO Control Register */
+#define UART_EFR	2	/* I/O: Extended Features Register */
+
+#define UART_LCR	3	/* Out: Line Control Register */
+#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_SCR	7	/* I/O: Scratch Register */
+#define UART_EMSR	7	/* Extended Mode Select Register */
+
+#endif
+/*
+ * DLAB=0
+ */
+//#define UART_IER	1	/* Out: Interrupt Enable Register */
+#define UART_IER_MSI		0x08 /* Enable Modem status interrupt */
+#define UART_IER_RLSI		0x04 /* Enable receiver line status interrupt */
+#define UART_IER_THRI		0x02 /* Enable Transmitter holding register int. */
+#define UART_IER_RDI		0x01 /* Enable receiver data interrupt */
+/*
+ * Sleep mode for ST16650 and TI16750.  For the ST16650, EFR[4]=1
+ */
+#define UART_IERX_SLEEP		0x10 /* Enable sleep mode */
+
+//#define UART_IIR	2	/* In:  Interrupt ID Register */
+#define UART_IIR_NO_INT		0x01 /* No interrupts pending */
+#define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
+#define UART_IIR_MSI		0x00 /* Modem status interrupt */
+#define UART_IIR_THRI		0x02 /* Transmitter holding register empty */
+#define UART_IIR_RDI		0x04 /* Receiver data interrupt */
+#define UART_IIR_RLSI		0x06 /* Receiver line status interrupt */
+
+//#define UART_FCR	2	/* Out: FIFO Control Register */
+#define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
+#define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
+#define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
+#define UART_FCR_DMA_SELECT	0x08 /* For DMA applications */
+/*
+ * Note: The FIFO trigger levels are chip specific:
+ *	RX:76 = 00  01  10  11	TX:54 = 00  01  10  11
+ * PC16550D:	 1   4   8  14		xx  xx  xx  xx
+ * TI16C550A:	 1   4   8  14          xx  xx  xx  xx
+ * TI16C550C:	 1   4   8  14          xx  xx  xx  xx
+ * ST16C550:	 1   4   8  14		xx  xx  xx  xx
+ * ST16C650:	 8  16  24  28		16   8  24  30	PORT_16650V2
+ * NS16C552:	 1   4   8  14		xx  xx  xx  xx
+ * ST16C654:	 8  16  56  60		 8  16  32  56	PORT_16654
+ * TI16C750:	 1  16  32  56		xx  xx  xx  xx	PORT_16750
+ * TI16C752:	 8  16  56  60		 8  16  32  56
+ */
+#define UART_FCR_R_TRIG_00	0x00
+#define UART_FCR_R_TRIG_01	0x40
+#define UART_FCR_R_TRIG_10	0x80
+#define UART_FCR_R_TRIG_11	0xc0
+#define UART_FCR_T_TRIG_00	0x00
+#define UART_FCR_T_TRIG_01	0x10
+#define UART_FCR_T_TRIG_10	0x20
+#define UART_FCR_T_TRIG_11	0x30
+
+#define UART_FCR_TRIGGER_MASK	0xC0 /* Mask for the FIFO trigger range */
+#define UART_FCR_TRIGGER_1	0x00 /* Mask for trigger set at 1 */
+#define UART_FCR_TRIGGER_4	0x40 /* Mask for trigger set at 4 */
+#define UART_FCR_TRIGGER_8	0x80 /* Mask for trigger set at 8 */
+#define UART_FCR_TRIGGER_14	0xC0 /* Mask for trigger set at 14 */
+/* 16650 definitions */
+#define UART_FCR6_R_TRIGGER_8	0x00 /* Mask for receive trigger set at 1 */
+#define UART_FCR6_R_TRIGGER_16	0x40 /* Mask for receive trigger set at 4 */
+#define UART_FCR6_R_TRIGGER_24  0x80 /* Mask for receive trigger set at 8 */
+#define UART_FCR6_R_TRIGGER_28	0xC0 /* Mask for receive trigger set at 14 */
+#define UART_FCR6_T_TRIGGER_16	0x00 /* Mask for transmit trigger set at 16 */
+#define UART_FCR6_T_TRIGGER_8	0x10 /* Mask for transmit trigger set at 8 */
+#define UART_FCR6_T_TRIGGER_24  0x20 /* Mask for transmit trigger set at 24 */
+#define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
+#define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
+
+//#define UART_LCR	3	/* Out: Line Control Register */
+/*
+ * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
+ * UART_LCR_STOP will select 1.5 stop bits, not 2 stop bits.
+ */
+#define UART_LCR_DLAB		0x80 /* Divisor latch access bit */
+#define UART_LCR_SBC		0x40 /* Set break control */
+#define UART_LCR_SPAR		0x20 /* Stick parity (?) */
+#define UART_LCR_EPAR		0x10 /* Even parity select */
+#define UART_LCR_PARITY		0x08 /* Parity Enable */
+#define UART_LCR_STOP		0x04 /* Stop bits: 0=1 bit, 1=2 bits */
+#define UART_LCR_WLEN5		0x00 /* Wordlength: 5 bits */
+#define UART_LCR_WLEN6		0x01 /* Wordlength: 6 bits */
+#define UART_LCR_WLEN7		0x02 /* Wordlength: 7 bits */
+#define UART_LCR_WLEN8		0x03 /* Wordlength: 8 bits */
+
+//#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_MCR_CLKSEL		0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
+#define UART_MCR_TCRTLR		0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
+#define UART_MCR_XONANY		0x20 /* Enable Xon Any (TI16C752, EFR[4]=1) */
+#define UART_MCR_AFE		0x20 /* Enable auto-RTS/CTS (TI16C550C/TI16C750) */
+#define UART_MCR_LOOP		0x10 /* Enable loopback test mode */
+#define UART_MCR_OUT2		0x08 /* Out2 complement */
+#define UART_MCR_OUT1		0x04 /* Out1 complement */
+#define UART_MCR_RTS		0x02 /* RTS complement */
+#define UART_MCR_DTR		0x01 /* DTR complement */
+
+//#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_LSR_TEMT		0x40 /* Transmitter empty */
+#define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
+#define UART_LSR_BI		0x10 /* Break interrupt indicator */
+#define UART_LSR_FE		0x08 /* Frame error indicator */
+#define UART_LSR_PE		0x04 /* Parity error indicator */
+#define UART_LSR_OE		0x02 /* Overrun error indicator */
+#define UART_LSR_DR		0x01 /* Receiver data ready */
+
+//#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_MSR_DCD		0x80 /* Data Carrier Detect */
+#define UART_MSR_RI		0x40 /* Ring Indicator */
+#define UART_MSR_DSR		0x20 /* Data Set Ready */
+#define UART_MSR_CTS		0x10 /* Clear to Send */
+#define UART_MSR_DDCD		0x08 /* Delta DCD */
+#define UART_MSR_TERI		0x04 /* Trailing edge ring indicator */
+#define UART_MSR_DDSR		0x02 /* Delta DSR */
+#define UART_MSR_DCTS		0x01 /* Delta CTS */
+#define UART_MSR_ANY_DELTA	0x0F /* Any of the delta bits! */
+
+//#define UART_SCR	7	/* I/O: Scratch Register */
+
+/*
+ * DLAB=1
+ */
+//#define UART_DLL	0	/* Out: Divisor Latch Low */
+//#define UART_DLM	1	/* Out: Divisor Latch High */
+
+/*
+ * LCR=0xBF (or DLAB=1 for 16C660)
+ */
+//#define UART_EFR	2	/* I/O: Extended Features Register */
+#define UART_EFR_CTS		0x80 /* CTS flow control */
+#define UART_EFR_RTS		0x40 /* RTS flow control */
+#define UART_EFR_SCD		0x20 /* Special character detect */
+#define UART_EFR_ECB		0x10 /* Enhanced control bit */
+/*
+ * the low four bits control software flow control
+ */
+
+/*
+ * LCR=0xBF, TI16C752, ST16650, ST16650A, ST16654
+ */
+#define UART_XON1	4	/* I/O: Xon character 1 */
+#define UART_XON2	5	/* I/O: Xon character 2 */
+#define UART_XOFF1	6	/* I/O: Xoff character 1 */
+#define UART_XOFF2	7	/* I/O: Xoff character 2 */
+
+/*
+ * EFR[4]=1 MCR[6]=1, TI16C752
+ */
+#define UART_TI752_TCR	6	/* I/O: transmission control register */
+#define UART_TI752_TLR	7	/* I/O: trigger level register */
+
+/*
+ * LCR=0xBF, XR16C85x
+ */
+//#define UART_TRG	0	/* FCTR bit 7 selects Rx or Tx
+//				 * In: Fifo count
+//				 * Out: Fifo custom trigger levels */
+/*
+ * These are the definitions for the Programmable Trigger Register
+ */
+#define UART_TRG_1		0x01
+#define UART_TRG_4		0x04
+#define UART_TRG_8		0x08
+#define UART_TRG_16		0x10
+#define UART_TRG_32		0x20
+#define UART_TRG_64		0x40
+#define UART_TRG_96		0x60
+#define UART_TRG_120		0x78
+#define UART_TRG_128		0x80
+
+//#define UART_FCTR	1	/* Feature Control Register */
+#define UART_FCTR_RTS_NODELAY	0x00  /* RTS flow control delay */
+#define UART_FCTR_RTS_4DELAY	0x01
+#define UART_FCTR_RTS_6DELAY	0x02
+#define UART_FCTR_RTS_8DELAY	0x03
+#define UART_FCTR_IRDA		0x04  /* IrDa data encode select */
+#define UART_FCTR_TX_INT	0x08  /* Tx interrupt type select */
+#define UART_FCTR_TRGA		0x00  /* Tx/Rx 550 trigger table select */
+#define UART_FCTR_TRGB		0x10  /* Tx/Rx 650 trigger table select */
+#define UART_FCTR_TRGC		0x20  /* Tx/Rx 654 trigger table select */
+#define UART_FCTR_TRGD		0x30  /* Tx/Rx 850 programmable trigger select */
+#define UART_FCTR_SCR_SWAP	0x40  /* Scratch pad register swap */
+#define UART_FCTR_RX		0x00  /* Programmable trigger mode select */
+#define UART_FCTR_TX		0x80  /* Programmable trigger mode select */
+
+/*
+ * LCR=0xBF, FCTR[6]=1
+ */
+//#define UART_EMSR	7	/* Extended Mode Select Register */
+#define UART_EMSR_FIFO_COUNT	0x01  /* Rx/Tx select */
+#define UART_EMSR_ALT_COUNT	0x02  /* Alternating count select */
+
+/*
+ * The Intel XScale on-chip UARTs define these bits
+ */
+#define UART_IER_DMAE	0x80	/* DMA Requests Enable */
+#define UART_IER_UUE	0x40	/* UART Unit Enable */
+#define UART_IER_NRZE	0x20	/* NRZ coding Enable */
+#define UART_IER_RTOIE	0x10	/* Receiver Time Out Interrupt Enable */
+
+#define UART_IIR_TOD	0x08	/* Character Timeout Indication Detected */
+
+#define UART_FCR_PXAR1	0x00	/* receive FIFO treshold = 1 */
+#define UART_FCR_PXAR8	0x40	/* receive FIFO treshold = 8 */
+#define UART_FCR_PXAR16	0x80	/* receive FIFO treshold = 16 */
+#define UART_FCR_PXAR32	0xc0	/* receive FIFO treshold = 32 */
+
+
+
+
+/*
+ * These register definitions are for the 16C950
+ */
+#define UART_ASR	0x01	/* Additional Status Register */
+#define UART_RFL	0x03	/* Receiver FIFO level */
+#define UART_TFL 	0x04	/* Transmitter FIFO level */
+#define UART_ICR	0x05	/* Index Control Register */
+
+/* The 16950 ICR registers */
+#define UART_ACR	0x00	/* Additional Control Register */
+#define UART_CPR	0x01	/* Clock Prescalar Register */
+#define UART_TCR	0x02	/* Times Clock Register */
+#define UART_CKS	0x03	/* Clock Select Register */
+#define UART_TTL	0x04	/* Transmitter Interrupt Trigger Level */
+#define UART_RTL	0x05	/* Receiver Interrupt Trigger Level */
+#define UART_FCL	0x06	/* Flow Control Level Lower */
+#define UART_FCH	0x07	/* Flow Control Level Higher */
+#define UART_ID1	0x08	/* ID #1 */
+#define UART_ID2	0x09	/* ID #2 */
+#define UART_ID3	0x0A	/* ID #3 */
+#define UART_REV	0x0B	/* Revision */
+#define UART_CSR	0x0C	/* Channel Software Reset */
+#define UART_NMR	0x0D	/* Nine-bit Mode Register */
+#define UART_CTR	0xFF
+
+/*
+ * The 16C950 Additional Control Reigster
+ */
+#define UART_ACR_RXDIS	0x01	/* Receiver disable */
+#define UART_ACR_TXDIS	0x02	/* Receiver disable */
+#define UART_ACR_DSRFC	0x04	/* DSR Flow Control */
+#define UART_ACR_TLENB	0x20	/* 950 trigger levels enable */
+#define UART_ACR_ICRRD	0x40	/* ICR Read enable */
+#define UART_ACR_ASREN	0x80	/* Additional status enable */
+
+
+
+/*
+ * These definitions are for the RSA-DV II/S card, from
+ *
+ * Kiyokazu SUTO <suto@ks-and-ks.ne.jp>
+ */
+
+#define UART_RSA_BASE (-8)
+
+#define UART_RSA_MSR ((UART_RSA_BASE) + 0) /* I/O: Mode Select Register */
+
+#define UART_RSA_MSR_SWAP (1 << 0) /* Swap low/high 8 bytes in I/O port addr */
+#define UART_RSA_MSR_FIFO (1 << 2) /* Enable the external FIFO */
+#define UART_RSA_MSR_FLOW (1 << 3) /* Enable the auto RTS/CTS flow control */
+#define UART_RSA_MSR_ITYP (1 << 4) /* Level (1) / Edge triger (0) */
+
+#define UART_RSA_IER ((UART_RSA_BASE) + 1) /* I/O: Interrupt Enable Register */
+
+#define UART_RSA_IER_Rx_FIFO_H (1 << 0) /* Enable Rx FIFO half full int. */
+#define UART_RSA_IER_Tx_FIFO_H (1 << 1) /* Enable Tx FIFO half full int. */
+#define UART_RSA_IER_Tx_FIFO_E (1 << 2) /* Enable Tx FIFO empty int. */
+#define UART_RSA_IER_Rx_TOUT (1 << 3) /* Enable char receive timeout int */
+#define UART_RSA_IER_TIMER (1 << 4) /* Enable timer interrupt */
+
+#define UART_RSA_SRR ((UART_RSA_BASE) + 2) /* IN: Status Read Register */
+
+#define UART_RSA_SRR_Tx_FIFO_NEMP (1 << 0) /* Tx FIFO is not empty (1) */
+#define UART_RSA_SRR_Tx_FIFO_NHFL (1 << 1) /* Tx FIFO is not half full (1) */
+#define UART_RSA_SRR_Tx_FIFO_NFUL (1 << 2) /* Tx FIFO is not full (1) */
+#define UART_RSA_SRR_Rx_FIFO_NEMP (1 << 3) /* Rx FIFO is not empty (1) */
+#define UART_RSA_SRR_Rx_FIFO_NHFL (1 << 4) /* Rx FIFO is not half full (1) */
+#define UART_RSA_SRR_Rx_FIFO_NFUL (1 << 5) /* Rx FIFO is not full (1) */
+#define UART_RSA_SRR_Rx_TOUT (1 << 6) /* Character reception timeout occurred (1) */
+#define UART_RSA_SRR_TIMER (1 << 7) /* Timer interrupt occurred */
+
+#define UART_RSA_FRR ((UART_RSA_BASE) + 2) /* OUT: FIFO Reset Register */
+
+#define UART_RSA_TIVSR ((UART_RSA_BASE) + 3) /* I/O: Timer Interval Value Set Register */
+
+#define UART_RSA_TCR ((UART_RSA_BASE) + 4) /* OUT: Timer Control Register */
+
+#define UART_RSA_TCR_SWITCH (1 << 0) /* Timer on */
+
+/*
+ * The RSA DSV/II board has two fixed clock frequencies.  One is the
+ * standard rate, and the other is 8 times faster.
+ */
+#define SERIAL_RSA_BAUD_BASE (921600)
+#define SERIAL_RSA_BAUD_BASE_LO (SERIAL_RSA_BAUD_BASE / 8)
+
+/*
+ * Extra serial register definitions for the internal UARTs
+ * in TI OMAP processors.
+ */
+#define UART_OMAP_MDR1		0x08	/* Mode definition register */
+#define UART_OMAP_MDR2		0x09	/* Mode definition register 2 */
+#define UART_OMAP_SCR		0x10	/* Supplementary control register */
+#define UART_OMAP_SSR		0x11	/* Supplementary status register */
+#define UART_OMAP_EBLR		0x12	/* BOF length register */
+#define UART_OMAP_OSC_12M_SEL	0x13	/* OMAP1510 12MHz osc select */
+#define UART_OMAP_MVER		0x14	/* Module version register */
+#define UART_OMAP_SYSC		0x15	/* System configuration register */
+#define UART_OMAP_SYSS		0x16	/* System status register */
+
+
Index: linux-2.6.21/arch/mips/rt2880/setup.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/setup.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,152 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     board setup for Ralink RT2880 solution
+ *
+ *  Copyright 2007 Ralink Inc. (bruce_chang@ralinktech.com.tw)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2007 Bruce Chang
+ *
+ * Initial Release
+ *
+ *
+ *
+ **************************************************************************
+ */
+
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/mc146818rtc.h>
+#include <linux/ioport.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/rt2880/generic.h>
+#include <asm/rt2880/prom.h>
+#include <asm/rt2880/surfboardint.h>
+#include <asm/time.h>
+#include <asm/traps.h>
+
+#if defined(CONFIG_SERIAL_CONSOLE) || defined(CONFIG_PROM_CONSOLE)
+extern void console_setup(char *, int *);
+char serial_console[20];
+#endif
+
+#ifdef CONFIG_KGDB
+extern void rs_kgdb_hook(int);
+extern void saa9730_kgdb_hook(void);
+extern void breakpoint(void);
+int remote_debug = 0;
+#endif
+
+//extern struct rtc_ops no_rtc_ops;
+
+extern void mips_reboot_setup(void);
+
+const char *get_system_type(void)
+{
+	return "Ralink SoC";
+}
+
+extern void mips_time_init(void);
+extern void mips_timer_setup(struct irqaction *irq);
+
+void __init rt2880_setup(void)
+{
+#ifdef CONFIG_KGDB
+	int rs_putDebugChar(char);
+	char rs_getDebugChar(void);
+	int saa9730_putDebugChar(char);
+	char saa9730_getDebugChar(void);
+	extern int (*generic_putDebugChar)(char);
+	extern char (*generic_getDebugChar)(void);
+#endif
+	char *argptr;
+
+	iomem_resource.start = 0;
+	iomem_resource.end= ~0;
+	ioport_resource.start= 0;
+	ioport_resource.end = ~0;
+#ifdef CONFIG_SERIAL_CONSOLE
+	argptr = prom_getcmdline();
+	if ((argptr = strstr(argptr, "console=ttyS")) == NULL) {
+		int i = 0;
+		char *s = prom_getenv("modetty0");
+		while(s[i] >= '0' && s[i] <= '9')
+			i++;
+		strcpy(serial_console, "ttyS0,");
+		strncpy(serial_console + 6, s, i);
+		prom_printf("Config serial console: %s\n", serial_console);
+		console_setup(serial_console, NULL);
+	}
+#endif
+
+#ifdef CONFIG_KGDB
+	argptr = prom_getcmdline();
+	if ((argptr = strstr(argptr, "kgdb=ttyS")) != NULL) {
+		int line;
+		argptr += strlen("kgdb=ttyS");
+		if (*argptr != '0' && *argptr != '1')
+			printk("KGDB: Uknown serial line /dev/ttyS%c, "
+			       "falling back to /dev/ttyS1\n", *argptr);
+		line = *argptr == '0' ? 0 : 1;
+		printk("KGDB: Using serial line /dev/ttyS%d for session\n",
+		       line ? 1 : 0);
+
+		if(line == 0) {
+			rs_kgdb_hook(line);
+			generic_putDebugChar = rs_putDebugChar;
+			generic_getDebugChar = rs_getDebugChar;
+		} else {
+			saa9730_kgdb_hook();
+			generic_putDebugChar = saa9730_putDebugChar;
+			generic_getDebugChar = saa9730_getDebugChar;
+		}
+
+		prom_printf("KGDB: Using serial line /dev/ttyS%d for session, "
+			    "please connect your debugger\n", line ? 1 : 0);
+
+		remote_debug = 1;
+		/* Breakpoints and stuff are in surfboard_irq_setup() */
+	}
+#endif
+	argptr = prom_getcmdline();
+
+	if ((argptr = strstr(argptr, "nofpu")) != NULL)
+		cpu_data[0].options &= ~MIPS_CPU_FPU;
+
+	//rtc_ops = &no_rtc_ops;
+	board_time_init = mips_time_init;
+	//board_timer_setup = mips_timer_setup;
+
+	mips_reboot_setup();
+}
+
+void __init plat_mem_setup(void)
+{
+  rt2880_setup();
+}
Index: linux-2.6.21/arch/mips/rt2880/time.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/mips/rt2880/time.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,171 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     timer setup for Ralink RT2880 solution
+ *
+ *  Copyright 2007 Ralink Inc. (bruce_chang@ralinktech.com.tw)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2007 Bruce Chang
+ *
+ * Initial Release
+ *
+ *
+ *
+ **************************************************************************
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+
+#include <asm/mipsregs.h>
+#include <asm/ptrace.h>
+#include <asm/hardirq.h>
+#include <asm/div64.h>
+#include <asm/cpu.h>
+#include <asm/time.h>
+
+#include <linux/interrupt.h>
+#include <linux/timex.h>
+
+#include <asm/rt2880/generic.h>
+#include <asm/rt2880/prom.h>
+#include <asm/rt2880/rt_mmap.h>
+#include <asm/rt2880/surfboardint.h>
+
+unsigned long surfboard_sysclk;	/* initialized by prom_init_sysclk() */
+
+static unsigned int r4k_offset; /* Amount to increment compare reg each time */
+static unsigned int r4k_cur;    /* What counter should be at next timer irq */
+
+extern unsigned int mips_hpt_frequency;
+extern u32 mips_cpu_feq;
+
+#define ALLINTS (IE_IRQ0 | IE_IRQ1 | IE_IRQ2 | IE_IRQ3 | IE_IRQ4 | IE_IRQ5)
+
+/*
+#if defined(CONFIG_RALINK_RT2880)
+static char display_string[] = "      LINUX ON RALINK RT2880 SOC     ";
+#elif defined (CONFIG_RALINK_RT2883)
+static char display_string[] = "      LINUX ON RALINK RT2883 SOC     ";
+#elif defined (CONFIG_RALINK_RT3052)
+static char display_string[] = "      LINUX ON RALINK RT3052 SOC     ";
+#endif
+static unsigned int display_count = 0;
+#define MAX_DISPLAY_COUNT (sizeof(display_string) - 8)
+
+static unsigned int timer_tick_count=0;
+
+*/
+
+static inline void ack_r4ktimer(unsigned int newval)
+{
+	write_c0_compare(newval);
+}
+
+void mips_timer_interrupt(void)
+{
+	/*
+	if ((timer_tick_count++ % HZ) == 0) {
+		mips_display_message(&display_string[display_count++]);
+		if (display_count == MAX_DISPLAY_COUNT)
+		        display_count = 0;
+
+	}
+	*/
+
+	ll_timer_interrupt(RALINK_CPU_TIMER_IRQ);
+}
+
+/*
+ * Figure out the r4k offset, the amount to increment the compare
+ * register for each time tick.
+ * For SURFBOARD, since there is no RTC present, use the value surfboard_sysclk.
+ * surfboard_sysclk by default is set to SURFBOARD_SYSTEM_CLOCK, defined in the
+ * file include/asm/surfboard/surfboard.h.  It can be overridden by the using
+ * kernel command line option 'sysclk='.
+ */
+static unsigned int __init cal_r4koff(void)
+{
+	unsigned long count;
+	count = mips_cpu_feq;;
+	return (count / HZ);
+}
+
+void __init mips_time_init(void)
+{
+        unsigned long flags;
+        unsigned int est_freq;
+
+	local_irq_save(flags);
+
+	mips_hpt_frequency = mips_cpu_feq/2;
+
+	printk("calculating r4koff... ");
+	r4k_offset = cal_r4koff();
+	printk("%08x(%d)\n", r4k_offset, r4k_offset);
+
+#if 0
+        if ((read_c0_prid() & 0xffff00) ==
+	    (PRID_COMP_MIPS | PRID_IMP_20KC))
+		est_freq = r4k_offset*HZ;
+	else
+		est_freq = 2*r4k_offset*HZ;
+#endif
+
+	
+	est_freq = r4k_offset*HZ;
+	est_freq += 5000;    /* round */
+	est_freq -= est_freq%10000;
+	printk("CPU frequency %d.%02d MHz\n", est_freq/1000000,
+	       (est_freq%1000000)*100/1000000);
+
+	local_irq_restore(flags);
+}
+
+#if 1
+void __init plat_timer_setup(struct irqaction *irq)
+#else
+void __init mips_timer_setup(struct irqaction *irq)
+#endif
+{
+	/* we are using the cpu counter for timer interrupts */
+	//irq->handler = no_action;     /* we use our own handler */
+	setup_irq(RALINK_CPU_TIMER_IRQ, irq);
+
+        /* to generate the first timer interrupt */
+	r4k_cur = (read_c0_count() + r4k_offset);
+	write_c0_compare(r4k_cur);
+	set_c0_status(ALLINTS);
+}
+
+u32 get_surfboard_sysclk(void) 
+{
+    return surfboard_sysclk;
+}
+
+EXPORT_SYMBOL(get_surfboard_sysclk);
Index: linux-2.6.21/drivers/char/Kconfig
===================================================================
--- linux-2.6.21.orig/drivers/char/Kconfig	2009-11-30 12:44:56.000000000 +0100
+++ linux-2.6.21/drivers/char/Kconfig	2009-11-30 12:44:56.000000000 +0100
@@ -4,6 +4,75 @@
 
 menu "Character devices"
 
+config RALINK_GPIO
+	bool "Ralink GPIO Support"
+	default y
+
+config RALINK_GPIO_LED
+	bool "Ralink GPIO LED Support"
+	depends on RALINK_GPIO
+	default y
+
+config RALINK_GDMA
+	tristate "Ralink GDMA Support"
+	default n
+choice
+        prompt "GDMA Channel Allocation Mode"
+	depends on RALINK_GDMA
+	default GDMA_EVERYBODY
+
+	config GDMA_PCM_ONLY
+	        bool "All for PCM0/PCM1"
+	
+	config GDMA_PCM_I2S_OTHERS
+	        bool "4Ch for PCM0 / 2Ch for I2S / 2Ch for Everybody"
+
+	config GDMA_EVERYBODY
+	        bool "All for Everybody"
+	
+	config GDMA_DEBUG
+	        bool "Debug Mode 0->1..7->0->1..7.."
+endchoice
+
+config RALINK_SPI
+	tristate "Ralink RT2880 SPI Support"
+	default n
+
+	
+config RALINK_I2C
+	tristate "Ralink RT2880 I2C Support"
+	default n
+
+config RALINK_PCM
+	tristate "Ralink PCM Support"
+	default n
+		
+config RALINK_I2S
+	tristate "Ralink I2S Support"
+	select RALINK_I2C
+	select RALINK_GDMA
+	default n
+
+config I2S_IN_CLK
+        bool "Use Internal Reference Clock"
+	depends on RALINK_I2S
+	default n
+config I2S_MS_MODE
+        bool "Ralink SoC as I2S Master Device"
+	depends on RALINK_I2S
+	default n
+choice
+        prompt "Audio Codec MCLK Setting"
+        depends on RALINK_I2S
+        default I2S_MCLK_12MHZ
+	
+	config I2S_MCLK_12MHZ
+	        bool "MCLK is 12Mhz"
+
+	config I2S_MCLK_12P288MHZ
+	        bool "MCLK is 12.288Mhz"
+endchoice
+
 config VT
 	bool "Virtual terminal" if EMBEDDED
 	select INPUT
@@ -372,19 +441,17 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called istallion.
 
-config AU1000_UART
-	bool "Enable Au1000 UART Support"
-	depends on SERIAL_NONSTANDARD && MIPS
-	help
-	  If you have an Alchemy AU1000 processor (MIPS based) and you want
-	  to use serial ports, say Y.  Otherwise, say N.
-
-config AU1000_SERIAL_CONSOLE
-	bool "Enable Au1000 serial console"
-	depends on AU1000_UART
-	help
-	  If you have an Alchemy AU1000 processor (MIPS based) and you want
-	  to use a console on a serial port, say Y.  Otherwise, say N.
+config AU1X00_GPIO
+	tristate "Alchemy Au1000 GPIO device support"
+	depends on MIPS && SOC_AU1X00
+
+config SIBYTE_SB1250_DUART
+	bool "Support for BCM1xxx onchip DUART"
+	depends on MIPS && SIBYTE_SB1xxx_SOC=y
+
+config SIBYTE_SB1250_DUART_CONSOLE
+	bool "Console on BCM1xxx DUART"
+	depends on SIBYTE_SB1250_DUART
 
 config SERIAL_DEC
 	bool "DECstation serial support"
Index: linux-2.6.21/drivers/char/Makefile
===================================================================
--- linux-2.6.21.orig/drivers/char/Makefile	2009-11-30 12:44:56.000000000 +0100
+++ linux-2.6.21/drivers/char/Makefile	2009-11-30 12:44:56.000000000 +0100
@@ -9,6 +9,11 @@
 
 obj-y	 += mem.o random.o tty_io.o n_tty.o tty_ioctl.o
 
+obj-$(CONFIG_RALINK_GPIO)	+= ralink_gpio.o
+obj-$(CONFIG_RALINK_GDMA)	+= ralink_gdma.o 
+obj-$(CONFIG_RALINK_SPI) 	+= spi_drv.o 
+obj-$(CONFIG_RALINK_I2C) 	+= i2c_drv.o
+
 obj-$(CONFIG_LEGACY_PTYS)	+= pty.o
 obj-$(CONFIG_UNIX98_PTYS)	+= pty.o
 obj-y				+= misc.o
@@ -32,6 +37,7 @@
 obj-$(CONFIG_ATARI_DSP56K)	+= dsp56k.o
 obj-$(CONFIG_MOXA_SMARTIO)	+= mxser.o
 obj-$(CONFIG_MOXA_SMARTIO_NEW)	+= mxser_new.o
+obj-$(CONFIG_SIBYTE_SB1250_DUART) += sb1250_duart.o
 obj-$(CONFIG_COMPUTONE)		+= ip2/
 obj-$(CONFIG_RISCOM8)		+= riscom8.o
 obj-$(CONFIG_ISI)		+= isicom.o
@@ -55,6 +61,7 @@
 obj-$(CONFIG_VIOTAPE)		+= viotape.o
 obj-$(CONFIG_HVCS)		+= hvcs.o
 obj-$(CONFIG_SGI_MBCS)		+= mbcs.o
+obj-$(CONFIG_SERIAL_DEC)	+= decserial.o
 obj-$(CONFIG_BRIQ_PANEL)	+= briq_panel.o
 
 obj-$(CONFIG_PRINTER)		+= lp.o
@@ -83,6 +90,7 @@
 obj-$(CONFIG_DS1620)		+= ds1620.o
 obj-$(CONFIG_HW_RANDOM)		+= hw_random/
 obj-$(CONFIG_COBALT_LCD)	+= lcd.o
+obj-$(CONFIG_AU1000_GPIO)	+= au1000_gpio.o
 obj-$(CONFIG_PPDEV)		+= ppdev.o
 obj-$(CONFIG_NWBUTTON)		+= nwbutton.o
 obj-$(CONFIG_NWFLASH)		+= nwflash.o
@@ -105,6 +113,9 @@
 obj-$(CONFIG_HANGCHECK_TIMER)	+= hangcheck-timer.o
 obj-$(CONFIG_TCG_TPM)		+= tpm/
 
+obj-$(CONFIG_RALINK_PCM)	+= pcm/
+obj-$(CONFIG_RALINK_I2S)	+= i2s/
+
 # Files generated that shall be removed upon make clean
 clean-files := consolemap_deftbl.c defkeymap.c
 
Index: linux-2.6.21/drivers/char/ralink_gpio.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/drivers/char/ralink_gpio.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,199 @@
+/*
+ ***************************************************************************
+ * Ralink Tech Inc.
+ * 4F, No. 2 Technology 5th Rd.
+ * Science-based Industrial Park
+ * Hsin-chu, Taiwan, R.O.C.
+ *
+ * (c) Copyright, Ralink Technology, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ ***************************************************************************
+ *
+ */
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include "ralink_gpio.h"
+
+#include <asm/rt2880/surfboardint.h>
+
+
+#define NAME			"ralink_gpio"
+int ralink_gpio_major = 252;
+u32 ralink_gpio_intp = 0;
+int ralink_gpio_irqnum = 0;
+u32 ralink_gpio_edge = 0;
+ralink_gpio_reg_info ralink_gpio_info[RALINK_GPIO_NUMBER];
+extern unsigned long volatile jiffies;
+
+ralink_gpio_reg_info info;
+
+
+
+/*
+ * send a signal(SIGUSR1) to the registered user process whenever any gpio
+ * interrupt comes
+ * (called by interrupt handler)
+ */
+void ralink_gpio_notify_user(int usr)
+{
+	struct task_struct *p = NULL;
+
+	if (ralink_gpio_irqnum < 0 || RALINK_GPIO_NUMBER <= ralink_gpio_irqnum) {
+		printk(KERN_ERR NAME ": gpio irq number out of range\n");
+		return;
+	}
+
+	//don't send any signal if pid is 0 or 1
+	if ((int)ralink_gpio_info[ralink_gpio_irqnum].pid < 2)
+		return;
+	p = find_task_by_pid(ralink_gpio_info[ralink_gpio_irqnum].pid);
+	if (NULL == p) {
+		printk(KERN_ERR NAME ": no registered process to notify\n");
+		return;
+	}
+
+	if (usr == 1) {
+		printk(KERN_NOTICE NAME ": sending a SIGUSR1 to process %d\n",
+				ralink_gpio_info[ralink_gpio_irqnum].pid);
+		send_sig(SIGUSR1, p, 0);
+	}
+	else if (usr == 2) {
+		printk(KERN_NOTICE NAME ": sending a SIGUSR2 to process %d\n",
+				ralink_gpio_info[ralink_gpio_irqnum].pid);
+		send_sig(SIGUSR2, p, 0);
+	}
+}
+
+/*
+ * 1. save the PIOINT and PIOEDGE value
+ * 2. clear PIOINT by writing 1
+ * (called by interrupt handler)
+ */
+void ralink_gpio_save_clear_intp(void)
+{
+	ralink_gpio_intp = le32_to_cpu(*(volatile u32 *)(RALINK_REG_PIOINT));
+	ralink_gpio_edge = le32_to_cpu(*(volatile u32 *)(RALINK_REG_PIOEDGE));
+	*(volatile u32 *)(RALINK_REG_PIOINT) = cpu_to_le32(0x00FFFFFF);
+	*(volatile u32 *)(RALINK_REG_PIOEDGE) = cpu_to_le32(0x00FFFFFF);
+}
+
+irqreturn_t ralink_gpio_irq_handler(int irq, void *irqaction)
+{
+	struct gpio_time_record {
+		unsigned long falling;
+		unsigned long rising;
+	};
+	static struct gpio_time_record record[RALINK_GPIO_NUMBER];
+	unsigned long now;
+	int i;
+
+	ralink_gpio_save_clear_intp();
+	now = jiffies;
+	for (i = 0; i < RALINK_GPIO_NUMBER; i++) {
+		if (! (ralink_gpio_intp & (1 << i)))
+			continue;
+		ralink_gpio_irqnum = i;
+		if (ralink_gpio_edge & (1 << i)) { //rising edge
+			if (record[i].rising != 0 && time_before_eq(now,
+						record[i].rising + 30L)) {
+				/*
+				 * If the interrupt comes in a short period,
+				 * it might be floating. We ignore it.
+				 */
+			}
+			else {
+				record[i].rising = now;
+				if (time_before(now, record[i].falling + 200L)) {
+					//one click
+					ralink_gpio_notify_user(1);
+				}
+				else {
+					//press for several seconds
+					ralink_gpio_notify_user(2);
+				}
+			}
+		}
+		else { //falling edge
+			record[i].falling = now;
+		}
+		break;
+	}
+
+	return IRQ_HANDLED;
+
+}
+
+struct irqaction ralink_gpio_irqaction = {
+	.handler = ralink_gpio_irq_handler,
+	.flags = SA_INTERRUPT,
+	.mask = 0,
+	.name = "ralink_gpio",
+};
+
+void __init ralink_gpio_init_irq(void)
+{
+	setup_irq(SURFBOARDINT_GPIO, &ralink_gpio_irqaction);
+}
+
+int __init
+ralink_gpio_init(void)
+{
+	unsigned int i;
+	u32 gpiomode;
+
+	// GPIO pin mode
+	gpiomode = le32_to_cpu(*(volatile u32 *)(RALINK_REG_GPIOMODE));
+	gpiomode |= RALINK_GPIOMODE_DFT;
+	*(volatile u32 *)(RALINK_REG_GPIOMODE) = cpu_to_le32(gpiomode);
+
+	// Enable irqs
+	*(volatile u32 *)(RALINK_REG_INTENA) = cpu_to_le32(RALINK_INTCTL_PIO);
+	for(i = 0; i < RALINK_GPIO_NUMBER; i++)
+	{
+		ralink_gpio_info[i].irq = i;
+		ralink_gpio_info[i].pid = 0;
+	}
+
+	printk("ra_gpio: done\n");
+
+	return 0;
+}
+
+void __exit
+ralink_gpio_exit(void)
+{
+}
+
+
+module_init(ralink_gpio_init);
+module_exit(ralink_gpio_exit);
+
+MODULE_DESCRIPTION("Ralink SoC GPIO Driver");
+MODULE_AUTHOR("Winfred Lu <winfred_lu@ralinktech.com.tw>");
+MODULE_LICENSE("GPL");
Index: linux-2.6.21/drivers/char/ralink_gpio.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/drivers/char/ralink_gpio.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,187 @@
+/*
+ ***************************************************************************
+ * Ralink Tech Inc.
+ * 4F, No. 2 Technology 5th Rd.
+ * Science-based Industrial Park
+ * Hsin-chu, Taiwan, R.O.C.
+ *
+ * (c) Copyright, Ralink Technology, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ ***************************************************************************
+ */
+
+#ifndef __RALINK_GPIO_H__
+#define __RALINK_GPIO_H__
+
+#include <asm/rt2880/rt_mmap.h>
+
+/*
+ * ioctl commands
+ */
+#define	RALINK_GPIO_SET_DIR		0x01
+#define RALINK_GPIO_SET_DIR_IN		0x11
+#define RALINK_GPIO_SET_DIR_OUT		0x12
+#define	RALINK_GPIO_READ		0x02
+#define	RALINK_GPIO_WRITE		0x03
+#define	RALINK_GPIO_SET			0x21
+#define	RALINK_GPIO_CLEAR		0x31
+#define	RALINK_GPIO_READ_BIT		0x04
+#define	RALINK_GPIO_WRITE_BIT		0x05
+#define	RALINK_GPIO_READ_BYTE		0x06
+#define	RALINK_GPIO_WRITE_BYTE		0x07
+#define	RALINK_GPIO_READ_INT		0x02 //same as read
+#define	RALINK_GPIO_WRITE_INT		0x03 //same as write
+#define	RALINK_GPIO_SET_INT		0x21 //same as set
+#define	RALINK_GPIO_CLEAR_INT		0x31 //same as clear
+#define RALINK_GPIO_ENABLE_INTP		0x08
+#define RALINK_GPIO_DISABLE_INTP	0x09
+#define RALINK_GPIO_REG_IRQ		0x0A
+#define RALINK_GPIO_LED_SET		0x41
+
+
+/*
+ * Address of RALINK_ Registers
+ */
+#define RALINK_SYSCTL_ADDR		RALINK_SYSCTL_BASE	// system control
+#define RALINK_REG_GPIOMODE		(RALINK_SYSCTL_ADDR + 0x60)
+
+#define RALINK_IRQ_ADDR			RALINK_INTCL_BASE
+#define RALINK_REG_INTENA		(RALINK_IRQ_ADDR + 0x34)
+#define RALINK_REG_INTDIS		(RALINK_IRQ_ADDR + 0x38)
+
+#define RALINK_PRGIO_ADDR		RALINK_PIO_BASE // Programmable I/O
+#define RALINK_REG_PIOINT		(RALINK_PRGIO_ADDR + 0)
+#define RALINK_REG_PIOEDGE		(RALINK_PRGIO_ADDR + 0x04)
+#define RALINK_REG_PIORENA		(RALINK_PRGIO_ADDR + 0x08)
+#define RALINK_REG_PIOFENA		(RALINK_PRGIO_ADDR + 0x0C)
+#define RALINK_REG_PIODATA		(RALINK_PRGIO_ADDR + 0x20)
+#define RALINK_REG_PIODIR		(RALINK_PRGIO_ADDR + 0x24)
+#define RALINK_REG_PIOSET		(RALINK_PRGIO_ADDR + 0x2C)
+#define RALINK_REG_PIORESET		(RALINK_PRGIO_ADDR + 0x30)
+#define RALINK_REG_PIOTOGGLE		(RALINK_PRGIO_ADDR + 0x34)
+#define RALINK_REG_PIO3924INT		(RALINK_PRGIO_ADDR + 0x38)
+#define RALINK_REG_PIO3924EDGE		(RALINK_PRGIO_ADDR + 0x3C)
+#define RALINK_REG_PIO3924RENA		(RALINK_PRGIO_ADDR + 0x40)
+#define RALINK_REG_PIO3924FENA		(RALINK_PRGIO_ADDR + 0x44)
+#define RALINK_REG_PIO3924DATA		(RALINK_PRGIO_ADDR + 0x48)
+#define RALINK_REG_PIO3924DIR		(RALINK_PRGIO_ADDR + 0x4C)
+#define RALINK_REG_PIO3924SET		(RALINK_PRGIO_ADDR + 0x54)
+#define RALINK_REG_PIO3924RESET		(RALINK_PRGIO_ADDR + 0x58)
+#define RALINK_REG_PIO3924TOGGLE	(RALINK_PRGIO_ADDR + 0x5C)
+#define RALINK_REG_PIO5140INT		(RALINK_PRGIO_ADDR + 0x60)
+#define RALINK_REG_PIO5140EDGE		(RALINK_PRGIO_ADDR + 0x64)
+#define RALINK_REG_PIO5140RENA		(RALINK_PRGIO_ADDR + 0x68)
+#define RALINK_REG_PIO5140FENA		(RALINK_PRGIO_ADDR + 0x6C)
+#define RALINK_REG_PIO5140DATA		(RALINK_PRGIO_ADDR + 0x70)
+#define RALINK_REG_PIO5140DIR		(RALINK_PRGIO_ADDR + 0x74)
+#define RALINK_REG_PIO5140SET		(RALINK_PRGIO_ADDR + 0x7C)
+#define RALINK_REG_PIO5140RESET		(RALINK_PRGIO_ADDR + 0x80)
+#define RALINK_REG_PIO5140TOGGLE	(RALINK_PRGIO_ADDR + 0x84)
+
+
+/*
+ * Values for the GPIOMODE Register
+ */
+#ifdef CONFIG_RALINK_RT2880
+#define RALINK_GPIOMODE_I2C		0x01
+#define RALINK_GPIOMODE_UARTF		0x02
+#define RALINK_GPIOMODE_SPI		0x04
+#define RALINK_GPIOMODE_UARTL		0x08
+#define RALINK_GPIOMODE_JTAG		0x10
+#define RALINK_GPIOMODE_MDIO		0x20
+#define RALINK_GPIOMODE_SDRAM		0x40
+#define RALINK_GPIOMODE_PCI		0x80
+#elif defined (CONFIG_RALINK_RT3052) || defined (CONFIG_RALINK_RT2883)
+#define RALINK_GPIOMODE_I2C		0x01
+#define RALINK_GPIOMODE_SPI		0x02
+#define RALINK_GPIOMODE_UARTF		0x1C
+#define RALINK_GPIOMODE_UARTL		0x20
+#define RALINK_GPIOMODE_JTAG		0x40
+#define RALINK_GPIOMODE_MDIO		0x80
+#define RALINK_GPIOMODE_SDRAM		0x100
+#define RALINK_GPIOMODE_RGMII		0x200
+#endif
+
+// if you would like to enable GPIO mode for other pins, please modify this value
+// !! Warning: changing this value may make other features(MDIO, PCI, etc) lose efficacy
+#define RALINK_GPIOMODE_DFT		(RALINK_GPIOMODE_UARTF)
+
+/*
+ * bit is the unit of length
+ */
+#define RALINK_GPIO_NUMBER		24
+#define RALINK_GPIO_DATA_MASK		0x00FFFFFF
+#define RALINK_GPIO_DATA_LEN		24
+#define RALINK_GPIO_DIR_IN		0
+#define RALINK_GPIO_DIR_OUT		1
+#define RALINK_GPIO_DIR_ALLIN		0
+#define RALINK_GPIO_DIR_ALLOUT		0x00FFFFFF
+
+/*
+ * structure used at regsitration
+ */
+typedef struct {
+	unsigned int irq;		//request irq pin number
+	pid_t pid;			//process id to notify
+} ralink_gpio_reg_info;
+
+#define RALINK_GPIO_LED_LOW_ACT		1
+#define RALINK_GPIO_LED_INFINITY	4000
+typedef struct {
+	int gpio;			//gpio number (0 ~ 23)
+	unsigned int on;		//interval of led on
+	unsigned int off;		//interval of led off
+	unsigned int blinks;		//number of blinking cycles
+	unsigned int rests;		//number of break cycles
+	unsigned int times;		//blinking times
+} ralink_gpio_led_info;
+
+
+#define RALINK_GPIO_0			0x00000001
+#define RALINK_GPIO_1			0x00000002
+#define RALINK_GPIO_2			0x00000004
+#define RALINK_GPIO_3			0x00000008
+#define RALINK_GPIO_4			0x00000010
+#define RALINK_GPIO_5			0x00000020
+#define RALINK_GPIO_6			0x00000040
+#define RALINK_GPIO_7			0x00000080
+#define RALINK_GPIO_8			0x00000100
+#define RALINK_GPIO_9			0x00000200
+#define RALINK_GPIO_10			0x00000400
+#define RALINK_GPIO_11			0x00000800
+#define RALINK_GPIO_12			0x00001000
+#define RALINK_GPIO_13			0x00002000
+#define RALINK_GPIO_14			0x00004000
+#define RALINK_GPIO_15			0x00008000
+#define RALINK_GPIO_16			0x00010000
+#define RALINK_GPIO_17			0x00020000
+#define RALINK_GPIO_18			0x00040000
+#define RALINK_GPIO_19			0x00080000
+#define RALINK_GPIO_20			0x00100000
+#define RALINK_GPIO_21			0x00200000
+#define RALINK_GPIO_22			0x00400000
+#define RALINK_GPIO_23			0x00800000
+#define RALINK_GPIO(x)			(1 << x)
+
+#endif
Index: linux-2.6.21/drivers/mtd/chips/cfi_cmdset_0002.c
===================================================================
--- linux-2.6.21.orig/drivers/mtd/chips/cfi_cmdset_0002.c	2009-11-30 12:44:55.000000000 +0100
+++ linux-2.6.21/drivers/mtd/chips/cfi_cmdset_0002.c	2009-11-30 12:44:56.000000000 +0100
@@ -13,11 +13,13 @@
  * XIP support hooks by Vitaly Wool (based on code for Intel flash
  * by Nicolas Pitre)
  *
+ * 25/09/2008 Christopher Moore: TopBottom fixup for many Macronix with CFI V1.0
+ *
  * Occasionally maintained by Thayne Harbaugh tharbaugh at lnxi dot com
  *
  * This code is GPL
  *
- * $Id: cfi_cmdset_0002.c,v 1.122 2005/11/07 11:14:22 gleixner Exp $
+ * $Id: cfi_cmdset_0002.c,v 1.10.2.1 2009-03-18 09:19:56 steven Exp $
  *
  */
 
@@ -46,6 +48,7 @@
 
 #define MANUFACTURER_AMD	0x0001
 #define MANUFACTURER_ATMEL	0x001F
+#define MANUFACTURER_MACRONIX	0x00C2
 #define MANUFACTURER_SST	0x00BF
 #define SST49LF004B	        0x0060
 #define SST49LF040B	        0x0050
@@ -148,12 +151,44 @@
 
 	if (((major << 8) | minor) < 0x3131) {
 		/* CFI version 1.0 => don't trust bootloc */
+
+		DEBUG(MTD_DEBUG_LEVEL1,
+			"%s: JEDEC Vendor ID is 0x%02X Device ID is 0x%02X\n",
+			map->name, cfi->mfr, cfi->id);
+
+		/* AFAICS all 29LV400 with a bottom boot block have a device ID
+		 * of 0x22BA in 16-bit mode and 0xBA in 8-bit mode.
+		 * These were badly detected as they have the 0x80 bit set
+		 * so treat them as a special case.
+		 */
+		if (((cfi->id == 0xBA) || (cfi->id == 0x22BA)) &&
+
+			/* Macronix added CFI to their 2nd generation
+			 * MX29LV400C B/T but AFAICS no other 29LV400 (AMD,
+			 * Fujitsu, Spansion, EON, ESI and older Macronix)
+			 * has CFI.
+			 *
+			 * Therefore also check the manufacturer.
+			 * This reduces the risk of false detection due to
+			 * the 8-bit device ID.
+			 */
+			(cfi->mfr == MANUFACTURER_MACRONIX)) {
+			DEBUG(MTD_DEBUG_LEVEL1,
+				"%s: Macronix MX29LV400C with bottom boot block"
+				" detected\n", map->name);
+			extp->TopBottom = 2;	/* bottom boot */
+		} else
 		if (cfi->id & 0x80) {
 			printk(KERN_WARNING "%s: JEDEC Device ID is 0x%02X. Assuming broken CFI table.\n", map->name, cfi->id);
 			extp->TopBottom = 3;	/* top boot */
 		} else {
 			extp->TopBottom = 2;	/* bottom boot */
 		}
+
+		DEBUG(MTD_DEBUG_LEVEL1,
+			"%s: AMD CFI PRI V%c.%c has no boot block field;"
+			" deduced %s from Device ID\n", map->name, major, minor,
+			extp->TopBottom == 2 ? "bottom" : "top");
 	}
 }
 #endif
@@ -182,10 +217,22 @@
 	if (atmel_pri.Features & 0x02)
 		extp->EraseSuspend = 2;
 
-	if (atmel_pri.BottomBoot)
-		extp->TopBottom = 2;
-	else
-		extp->TopBottom = 3;
+	/* Some chips got it backwards... */
+	if (cfi->id == AT49BV6416) {
+		if (atmel_pri.BottomBoot)
+			extp->TopBottom = 3;
+		else
+			extp->TopBottom = 2;
+	} else {
+		if (atmel_pri.BottomBoot)
+			extp->TopBottom = 2;
+		else
+			extp->TopBottom = 3;
+	}
+
+	/* burst write mode not supported */
+	cfi->cfiq->BufWriteTimeoutTyp = 0;
+	cfi->cfiq->BufWriteTimeoutMax = 0;
 }
 
 static void fixup_use_secsi(struct mtd_info *mtd, void *param)
@@ -217,9 +264,33 @@
 	mtd->flags |= MTD_STUPID_LOCK;
 }
 
+static void fixup_s29gl064n_sectors(struct mtd_info *mtd, void *param)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+
+	if ((cfi->cfiq->EraseRegionInfo[0] & 0xffff) == 0x003f) {
+		cfi->cfiq->EraseRegionInfo[0] |= 0x0040;
+		printk(KERN_WARNING "%s: Bad S29GL064N CFI data, adjust from 64 to 128 sectors\n", mtd->name);
+	}
+}
+
+static void fixup_s29gl032n_sectors(struct mtd_info *mtd, void *param)
+{
+	struct map_info *map = mtd->priv;
+	struct cfi_private *cfi = map->fldrv_priv;
+
+	if ((cfi->cfiq->EraseRegionInfo[1] & 0xffff) == 0x007e) {
+		cfi->cfiq->EraseRegionInfo[1] &= ~0x0040;
+		printk(KERN_WARNING "%s: Bad S29GL032N CFI data, adjust from 127 to 63 sectors\n", mtd->name);
+	}
+}
+
 static struct cfi_fixup cfi_fixup_table[] = {
+	{ CFI_MFR_ATMEL, CFI_ID_ANY, fixup_convert_atmel_pri, NULL },
 #ifdef AMD_BOOTLOC_BUG
 	{ CFI_MFR_AMD, CFI_ID_ANY, fixup_amd_bootblock, NULL },
+	{ MANUFACTURER_MACRONIX, CFI_ID_ANY, fixup_amd_bootblock, NULL },
 #endif
 	{ CFI_MFR_AMD, 0x0050, fixup_use_secsi, NULL, },
 	{ CFI_MFR_AMD, 0x0053, fixup_use_secsi, NULL, },
@@ -227,6 +298,10 @@
 	{ CFI_MFR_AMD, 0x0056, fixup_use_secsi, NULL, },
 	{ CFI_MFR_AMD, 0x005C, fixup_use_secsi, NULL, },
 	{ CFI_MFR_AMD, 0x005F, fixup_use_secsi, NULL, },
+	{ CFI_MFR_AMD, 0x0c01, fixup_s29gl064n_sectors, NULL, },
+	{ CFI_MFR_AMD, 0x1301, fixup_s29gl064n_sectors, NULL, },
+	{ CFI_MFR_AMD, 0x1a00, fixup_s29gl032n_sectors, NULL, },
+	{ CFI_MFR_AMD, 0x1a01, fixup_s29gl032n_sectors, NULL, },
 #if !FORCE_WORD_WRITE
 	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_use_write_buffers, NULL, },
 #endif
@@ -252,6 +327,15 @@
 };
 
 
+static void cfi_fixup_major_minor(struct cfi_private *cfi, 
+				  struct cfi_pri_amdstd *extp)
+{
+   if (cfi->mfr == CFI_MFR_SAMSUNG && cfi->id == 0x257e &&
+	    extp->MajorVersion == '0')
+	extp->MajorVersion = '1';
+}
+
+
 struct mtd_info *cfi_cmdset_0002(struct map_info *map, int primary)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -293,6 +377,8 @@
 			return NULL;
 		}
 
+		cfi_fixup_major_minor(cfi, extp);
+
 		if (extp->MajorVersion != '1' ||
 		    (extp->MinorVersion < '0' || extp->MinorVersion > '4')) {
 		        if (cfi->mfr == MANUFACTURER_SAMSUNG &&
@@ -381,6 +467,7 @@
 {
 	struct map_info *map = mtd->priv;
 	struct cfi_private *cfi = map->fldrv_priv;
+	struct flchip *chip;
 	unsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;
 	unsigned long offset = 0;
 	int i,j;
@@ -407,6 +494,13 @@
 			mtd->erasesize = ersize;
 		}
 		for (j=0; j<cfi->numchips; j++) {
+			/* 
+			 * patch for Numonyx Flash
+			 * -> send reset command first by Steven
+			 */
+			chip=&cfi->chips[j];
+			map_write( map, CMD(0xF0), chip->start);
+
 			mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].offset = (j*devsize)+offset;
 			mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].erasesize = ersize;
 			mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].numblocks = ernum;
@@ -1306,7 +1400,7 @@
 
 	INVALIDATE_CACHE_UDELAY(map, chip,
 				adr, map_bankwidth(map),
-				chip->word_write_time);
+				chip->buffer_write_time*5);
 
 	timeo = jiffies + uWriteTimeout;
 
@@ -1498,8 +1592,16 @@
 			chip->erase_suspended = 0;
 		}
 
-		if (chip_ready(map, adr))
-			break;
+		if (chip_ready(map, adr)) {
+
+		    /* We have to make sure sector erease is successful because
+		     * Spansion will report wrong status - FIXME */ 
+		    if(!chip_good(map, adr, map_word_ff(map))) {
+			continue;
+		    }
+
+		    break;
+		}
 
 		if (time_after(jiffies, timeo)) {
 			printk(KERN_WARNING "MTD %s(): software timeout\n",
@@ -1587,8 +1689,15 @@
 		}
 
 		if (chip_ready(map, adr)) {
-			xip_enable(map, chip, adr);
-			break;
+		   
+		    /* We have to make sure sector erease is successful because
+		     * Spansion will report wrong status - FIXME */ 
+		    if(!chip_good(map, adr, map_word_ff(map))) {
+			continue;
+		    }
+
+		    xip_enable(map, chip, adr);
+		    break;
 		}
 
 		if (time_after(jiffies, timeo)) {
@@ -1765,6 +1874,7 @@
 
 		default:
 			/* Not an idle state */
+			set_current_state(TASK_UNINTERRUPTIBLE);
 			add_wait_queue(&chip->wq, &wait);
 
 			spin_unlock(chip->mutex);
Index: linux-2.6.21/drivers/mtd/mtdpart.c
===================================================================
--- linux-2.6.21.orig/drivers/mtd/mtdpart.c	2009-11-30 12:44:55.000000000 +0100
+++ linux-2.6.21/drivers/mtd/mtdpart.c	2009-11-30 12:44:56.000000000 +0100
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id: mtdpart.c,v 1.55 2005/11/07 11:14:20 gleixner Exp $
+ * $Id: mtdpart.c,v 1.1.1.1 2007-05-25 06:50:07 bruce Exp $
  *
  * 	02-21-2002	Thomas Gleixner <gleixner@autronix.de>
  *			added support for read_oob, write_oob
@@ -505,7 +505,7 @@
 		goto out;
 	}
 
-	if (*((u32 *) buf) != SQUASHFS_MAGIC) {
+	if (*((u32 *) buf) != 0x71736873){ //SQUASHFS_MAGIC) {
 		printk(KERN_ALERT "split_squasfs: no squashfs found in \"%s\"\n",
 			master->name);
 		ret=0;
Index: linux-2.6.21/drivers/net/pppox.c
===================================================================
--- linux-2.6.21.orig/drivers/net/pppox.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/drivers/net/pppox.c	2009-11-30 12:44:56.000000000 +0100
@@ -114,6 +114,13 @@
 		goto out;
 
 	rc = -EPROTONOSUPPORT;
+#ifdef CONFIG_KMOD
+	if (!pppox_protos[protocol]) {
+		char buffer[32];
+		sprintf(buffer, "pppox-proto-%d", protocol);
+		request_module(buffer);
+	}
+#endif
 	if (!pppox_protos[protocol] ||
 	    !try_module_get(pppox_protos[protocol]->owner))
 		goto out;
Index: linux-2.6.21/drivers/net/wireless/Makefile
===================================================================
--- linux-2.6.21.orig/drivers/net/wireless/Makefile	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/drivers/net/wireless/Makefile	2009-11-30 12:44:56.000000000 +0100
@@ -43,3 +43,11 @@
 obj-$(CONFIG_PCMCIA_WL3501)	+= wl3501_cs.o
 
 obj-$(CONFIG_USB_ZD1201)	+= zd1201.o
+
+#obj-$(CONFIG_RT2860V2_AP)       += rt2860v2_ap/
+#obj-$(CONFIG_RT2860V2_STA)      += rt2860v2_sta/
+#obj-$(CONFIG_RT2880v2_INIC_MII) += iNIC/mii/
+#obj-$(CONFIG_RT2880v2_INIC_PCI) += iNIC/pci/
+
+#obj-$(CONFIG_RT305x_INIC_MII) += iNIC_RT305x/mii/
+#obj-$(CONFIG_RT305x_INIC_USB) += iNIC_RT305x/usb/
Index: linux-2.6.21/drivers/serial/8250.c
===================================================================
--- linux-2.6.21.orig/drivers/serial/8250.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/drivers/serial/8250.c	2009-11-30 12:44:56.000000000 +0100
@@ -12,7 +12,7 @@
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- *  $Id: 8250.c,v 1.90 2002/07/28 10:03:27 rmk Exp $
+ *  $Id: 8250.c,v 1.3 2007-11-14 07:41:47 steven Exp $
  *
  * A note about mapbase / membase
  *
@@ -326,7 +326,13 @@
 			return readb(up->port.membase + offset);
 
 	default:
+#if defined (CONFIG_RALINK_RT2880) || \
+    defined (CONFIG_RALINK_RT2883) || \
+    defined (CONFIG_RALINK_RT3052)
+		return (*(int*)(up->port.iobase + offset));
+#else
 		return inb(up->port.iobase + offset);
+#endif
 	}
 }
 
@@ -360,7 +366,13 @@
 		break;
 
 	default:
+#if defined (CONFIG_RALINK_RT2880) || \
+    defined (CONFIG_RALINK_RT2883) || \
+    defined (CONFIG_RALINK_RT3052)
+		*(int*)(up->port.iobase + offset) = value;
+#else
 		outb(value, up->port.iobase + offset);
+#endif
 	}
 }
 
@@ -403,22 +415,18 @@
 	serial_outp(up, UART_DLM, value >> 8 & 0xff);
 }
 
-#ifdef CONFIG_SERIAL_8250_AU1X00
-/* Au1x00 haven't got a standard divisor latch */
+#if defined (CONFIG_RALINK_RT2880) || \
+    defined (CONFIG_RALINK_RT2883) || \
+    defined (CONFIG_RALINK_RT3052)
+/* Ralink haven't got a standard divisor latch */
 static int serial_dl_read(struct uart_8250_port *up)
 {
-	if (up->port.iotype == UPIO_AU)
-		return __raw_readl(up->port.membase + 0x28);
-	else
-		return _serial_dl_read(up);
+	return serial_inp(up, UART_DLL);
 }
 
 static void serial_dl_write(struct uart_8250_port *up, int value)
 {
-	if (up->port.iotype == UPIO_AU)
-		__raw_writel(value, up->port.membase + 0x28);
-	else
-		_serial_dl_write(up, value);
+	serial_outp(up, UART_DLL, value);
 }
 #else
 #define serial_dl_read(up) _serial_dl_read(up)
@@ -595,9 +603,21 @@
 {
 	unsigned char old_dll, old_dlm, old_lcr;
 	unsigned int id;
+#if defined (CONFIG_RALINK_RT2880) || \
+    defined (CONFIG_RALINK_RT2883) || \
+    defined (CONFIG_RALINK_RT3052)
+	unsigned short old_dl;
+
+	old_dl = serial_dl_read(p);
+	serial_dl_write(p, 0);
+	id = serial_dl_read(p);
+	serial_dl_write(p, old_dl);
 
 	old_lcr = serial_inp(p, UART_LCR);
 	serial_outp(p, UART_LCR, UART_LCR_DLAB);
+#else
+	old_lcr = serial_inp(p, UART_LCR);
+	serial_outp(p, UART_LCR, UART_LCR_DLAB);
 
 	old_dll = serial_inp(p, UART_DLL);
 	old_dlm = serial_inp(p, UART_DLM);
@@ -609,6 +629,7 @@
 
 	serial_outp(p, UART_DLL, old_dll);
 	serial_outp(p, UART_DLM, old_dlm);
+#endif
 	serial_outp(p, UART_LCR, old_lcr);
 
 	return id;
@@ -2740,7 +2761,7 @@
 	if (nr_uarts > UART_NR)
 		nr_uarts = UART_NR;
 
-	printk(KERN_INFO "Serial: 8250/16550 driver $Revision: 1.90 $ "
+	printk(KERN_INFO "Serial: 8250/16550 driver $Revision: 1.3 $ "
 		"%d ports, IRQ sharing %sabled\n", nr_uarts,
 		share_irqs ? "en" : "dis");
 
@@ -2801,7 +2822,7 @@
 EXPORT_SYMBOL(serial8250_resume_port);
 
 MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("Generic 8250/16x50 serial driver $Revision: 1.90 $");
+MODULE_DESCRIPTION("Generic 8250/16x50 serial driver $Revision: 1.3 $");
 
 module_param(share_irqs, uint, 0644);
 MODULE_PARM_DESC(share_irqs, "Share IRQs with other non-8250/16x50 devices"
Index: linux-2.6.21/drivers/serial/8250_early.c
===================================================================
--- linux-2.6.21.orig/drivers/serial/8250_early.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/drivers/serial/8250_early.c	2009-11-30 12:44:56.000000000 +0100
@@ -103,11 +103,21 @@
 
 	lcr = serial_in(port, UART_LCR);
 	serial_out(port, UART_LCR, lcr | UART_LCR_DLAB);
+#if defined (CONFIG_RALINK_RT2880) || \
+    defined (CONFIG_RALINK_RT2883) || \
+    defined (CONFIG_RALINK_RT3052)
+	quot= serial_in(port, UART_DLL);
+#else
 	dll = serial_in(port, UART_DLL);
 	dlm = serial_in(port, UART_DLM);
+#endif
 	serial_out(port, UART_LCR, lcr);
 
+#if defined (CONFIG_RALINK_RT2880) || \
+    defined (CONFIG_RALINK_RT2883) || \
+    defined (CONFIG_RALINK_RT3052)
 	quot = (dlm << 8) | dll;
+#endif
 	return (port->uartclk / 16) / quot;
 }
 
Index: linux-2.6.21/drivers/serial/ip22zilog.c
===================================================================
--- linux-2.6.21.orig/drivers/serial/ip22zilog.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/drivers/serial/ip22zilog.c	2009-11-30 12:44:56.000000000 +0100
@@ -862,6 +862,7 @@
 	up->cflag = termios->c_cflag;
 
 	ip22zilog_maybe_update_regs(up, ZILOG_CHANNEL_FROM_PORT(port));
+	uart_update_timeout(port, termios->c_cflag, baud);
 
 	spin_unlock_irqrestore(&up->port.lock, flags);
 }
@@ -1017,6 +1018,8 @@
 	}
 
 	con->cflag = cflag | CS8;			/* 8N1 */
+
+	uart_update_timeout(&ip22zilog_port_table[con->index].port, cflag, baud);
 }
 
 static int __init ip22zilog_console_setup(struct console *con, char *options)
Index: linux-2.6.21/drivers/serial/serial_core.c
===================================================================
--- linux-2.6.21.orig/drivers/serial/serial_core.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/drivers/serial/serial_core.c	2009-11-30 12:44:56.000000000 +0100
@@ -414,6 +414,11 @@
 		quot = port->custom_divisor;
 	else
 		quot = (port->uartclk + (8 * baud)) / (16 * baud);
+#if defined (CONFIG_RALINK_RT2880) || \
+	defined (CONFIG_RALINK_RT2883) || \
+	defined (CONFIG_RALINK_RT3052)
+	quot = port->custom_divisor;
+#endif
 
 	return quot;
 }
Index: linux-2.6.21/fs/aio.c
===================================================================
--- linux-2.6.21.orig/fs/aio.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/fs/aio.c	2009-11-30 12:44:56.000000000 +0100
@@ -35,6 +35,8 @@
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
 
+#ifdef CONFIG_AIO
+
 #if DEBUG > 1
 #define dprintk		printk
 #else
@@ -1766,3 +1768,54 @@
 EXPORT_SYMBOL(aio_complete);
 EXPORT_SYMBOL(aio_put_req);
 EXPORT_SYMBOL(wait_on_sync_kiocb);
+
+#else
+
+ssize_t fastcall wait_on_sync_kiocb(struct kiocb *iocb)
+{
+	return 0;
+}
+
+void fastcall exit_aio(struct mm_struct *mm)
+{
+}
+
+void fastcall __put_ioctx(struct kioctx *ctx)
+{
+}
+
+int fastcall aio_put_req(struct kiocb *req)
+{
+	return 0;
+}
+
+struct kioctx *lookup_ioctx(unsigned long ctx_id)
+{
+	return 0;
+}
+
+void fastcall kick_iocb(struct kiocb *iocb)
+{
+}
+
+int fastcall aio_complete(struct kiocb *iocb, long res, long res2)
+{
+	return 0;
+}
+
+int fastcall io_submit_one(struct kioctx *ctx, struct iocb __user *user_iocb,
+		struct iocb *iocb)
+{
+	return -EINVAL;
+}
+
+struct kiocb *lookup_kiocb(struct kioctx *ctx, struct iocb *iocb, u32 key)
+{
+	return 0;
+}
+
+EXPORT_SYMBOL(aio_complete);
+EXPORT_SYMBOL(aio_put_req);
+EXPORT_SYMBOL(wait_on_sync_kiocb);
+
+#endif
Index: linux-2.6.21/fs/binfmt_elf.c
===================================================================
--- linux-2.6.21.orig/fs/binfmt_elf.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/fs/binfmt_elf.c	2009-11-30 12:44:56.000000000 +0100
@@ -44,7 +44,9 @@
 #include <asm/page.h>
 
 static int load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs);
+#ifdef CONFIG_BINFMT_ELF_AOUT
 static int load_elf_library(struct file *);
+#endif
 static unsigned long elf_map (struct file *, unsigned long, struct elf_phdr *, int, int);
 
 /*
@@ -74,7 +76,11 @@
 static struct linux_binfmt elf_format = {
 		.module		= THIS_MODULE,
 		.load_binary	= load_elf_binary,
+#ifdef CONFIG_BINFMT_ELF_AOUT
 		.load_shlib	= load_elf_library,
+#else
+		.load_shlib	= NULL,
+#endif
 		.core_dump	= elf_core_dump,
 		.min_coredump	= ELF_EXEC_PAGESIZE,
 		.hasvdso	= 1
@@ -451,6 +457,7 @@
 	return error;
 }
 
+#ifdef CONFIG_BINFMT_ELF_AOUT
 static unsigned long load_aout_interp(struct exec *interp_ex,
 		struct file *interpreter)
 {
@@ -496,6 +503,7 @@
 out:
 	return elf_entry;
 }
+#endif
 
 /*
  * These are the functions used to load ELF style executables and shared
@@ -503,7 +511,9 @@
  */
 
 #define INTERPRETER_NONE 0
+#ifdef CONFIG_BINFMT_ELF_AOUT
 #define INTERPRETER_AOUT 1
+#endif
 #define INTERPRETER_ELF 2
 
 #ifndef STACK_RND_MASK
@@ -543,7 +553,9 @@
 	unsigned long elf_entry, interp_load_addr = 0;
 	unsigned long start_code, end_code, start_data, end_data;
 	unsigned long reloc_func_desc = 0;
+#ifdef CONFIG_BINFMT_ELF_AOUT
 	char passed_fileno[6];
+#endif
 	struct files_struct *files;
 	int executable_stack = EXSTACK_DEFAULT;
 	unsigned long def_flags = 0;
@@ -720,12 +732,14 @@
 
 	/* Some simple consistency checks for the interpreter */
 	if (elf_interpreter) {
+#ifdef CONFIG_BINFMT_ELF_AOUT
 		interpreter_type = INTERPRETER_ELF | INTERPRETER_AOUT;
 
 		/* Now figure out which format our binary is */
 		if ((N_MAGIC(loc->interp_ex) != OMAGIC) &&
 		    (N_MAGIC(loc->interp_ex) != ZMAGIC) &&
 		    (N_MAGIC(loc->interp_ex) != QMAGIC))
+#endif
 			interpreter_type = INTERPRETER_ELF;
 
 		if (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)
@@ -735,6 +749,7 @@
 		if (!interpreter_type)
 			goto out_free_dentry;
 
+#ifdef CONFIG_BINFMT_ELF_AOUT
 		/* Make sure only one type was selected */
 		if ((interpreter_type & INTERPRETER_ELF) &&
 		     interpreter_type != INTERPRETER_ELF) {
@@ -742,6 +757,7 @@
 			// printk(KERN_WARNING "ELF: Ambiguous type, using ELF\n");
 			interpreter_type = INTERPRETER_ELF;
 		}
+#endif
 		/* Verify the interpreter has a valid arch */
 		if ((interpreter_type == INTERPRETER_ELF) &&
 		    !elf_check_arch(&loc->interp_elf_ex))
@@ -753,6 +769,7 @@
 
 	/* OK, we are done with that, now set up the arg stuff,
 	   and then start this sucker up */
+#ifdef CONFIG_BINFMT_ELF_AOUT
 	if ((!bprm->sh_bang) && (interpreter_type == INTERPRETER_AOUT)) {
 		char *passed_p = passed_fileno;
 		sprintf(passed_fileno, "%d", elf_exec_fileno);
@@ -764,6 +781,7 @@
 			bprm->argc++;
 		}
 	}
+#endif
 
 	/* Flush all traces of the currently running executable */
 	retval = flush_old_exec(bprm);
@@ -941,10 +959,12 @@
 	}
 
 	if (elf_interpreter) {
+#ifdef CONFIG_BINFMT_ELF_AOUT
 		if (interpreter_type == INTERPRETER_AOUT)
 			elf_entry = load_aout_interp(&loc->interp_ex,
 						     interpreter);
 		else
+#endif
 			elf_entry = load_elf_interp(&loc->interp_elf_ex,
 						    interpreter,
 						    &interp_load_addr);
@@ -970,7 +990,9 @@
 
 	kfree(elf_phdata);
 
+#ifdef CONFIG_BINFMT_ELF_AOUT
 	if (interpreter_type != INTERPRETER_AOUT)
+#endif
 		sys_close(elf_exec_fileno);
 
 	set_binfmt(&elf_format);
@@ -985,12 +1007,16 @@
 
 	compute_creds(bprm);
 	current->flags &= ~PF_FORKNOEXEC;
+#ifdef CONFIG_BINFMT_ELF_AOUT
 	create_elf_tables(bprm, &loc->elf_ex,
 			  (interpreter_type == INTERPRETER_AOUT),
 			  load_addr, interp_load_addr);
 	/* N.B. passed_fileno might not be initialized? */
 	if (interpreter_type == INTERPRETER_AOUT)
 		current->mm->arg_start += strlen(passed_fileno) + 1;
+#else
+	create_elf_tables(bprm, &loc->elf_ex, 0, load_addr, interp_load_addr);
+#endif
 	current->mm->end_code = end_code;
 	current->mm->start_code = start_code;
 	current->mm->start_data = start_data;
@@ -1052,6 +1078,7 @@
 	goto out;
 }
 
+#ifdef CONFIG_BINFMT_ELF_AOUT
 /* This is really simpleminded and specialized - we are loading an
    a.out library that is given an ELF header. */
 static int load_elf_library(struct file *file)
@@ -1135,6 +1162,7 @@
 out:
 	return error;
 }
+#endif
 
 /*
  * Note that some platforms still use traditional core dumps and not
Index: linux-2.6.21/fs/buffer.c
===================================================================
--- linux-2.6.21.orig/fs/buffer.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/fs/buffer.c	2009-11-30 12:44:56.000000000 +0100
@@ -571,7 +571,11 @@
 /*
  * The buffer's backing address_space's private_lock must be held
  */
+#ifdef CONFIG_LINUXTINY_DO_UNINLINE
+static void __remove_assoc_queue(struct buffer_head *bh)
+#else
 static inline void __remove_assoc_queue(struct buffer_head *bh)
+#endif
 {
 	list_del_init(&bh->b_assoc_buffers);
 	WARN_ON(!bh->b_assoc_map);
Index: linux-2.6.21/fs/exec.c
===================================================================
--- linux-2.6.21.orig/fs/exec.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/fs/exec.c	2009-11-30 12:44:56.000000000 +0100
@@ -124,6 +124,7 @@
  */
 asmlinkage long sys_uselib(const char __user * library)
 {
+#if defined(CONFIG_BINFMT_AOUT) || defined(CONFIG_BINFMT_AOUT_MODULE) || defined(CONFIG_BINFMT_ELF_AOUT)
 	struct file * file;
 	struct nameidata nd;
 	int error;
@@ -171,6 +172,9 @@
 	release_open_intent(&nd);
 	path_release(&nd);
 	goto out;
+#else
+	return -ENOSYS;
+#endif
 }
 
 /*
Index: linux-2.6.21/fs/Kconfig
===================================================================
--- linux-2.6.21.orig/fs/Kconfig	2009-11-30 12:44:56.000000000 +0100
+++ linux-2.6.21/fs/Kconfig	2009-11-30 12:44:56.000000000 +0100
@@ -1375,6 +1375,71 @@
 
 	  If unsure, say N.
 
+config SQUASHFS
+	tristate "SquashFS 3.2 - Squashed file system support"
+	select ZLIB_INFLATE
+	help
+	  Saying Y here includes support for SquashFS 3.2 (a Compressed Read-Only File
+	  System).  Squashfs is a highly compressed read-only filesystem for Linux.
+	  It uses zlib compression to compress both files, inodes and directories.
+	  Inodes in the system are very small and all blocks are packed to minimise
+	  data overhead. Block sizes greater than 4K are supported up to a maximum of 64K.
+	  SquashFS 3.1 supports 64 bit filesystems and files (larger than 4GB), full
+	  uid/gid information, hard links and timestamps.
+
+	  Squashfs is intended for general read-only filesystem use, for archival
+	  use (i.e. in cases where a .tar.gz file may be used), and in embedded
+	  systems where low overhead is needed.  Further information and filesystem tools
+	  are available from http://squashfs.sourceforge.net.
+
+	  If you want to compile this as a module ( = code which can be
+	  inserted in and removed from the running kernel whenever you want),
+	  say M here and read <file:Documentation/modules.txt>.  The module
+	  will be called squashfs.  Note that the root file system (the one
+	  containing the directory /) cannot be compiled as a module.
+
+	  If unsure, say N.
+
+config SQUASHFS_EMBEDDED
+
+	bool "Additional options for memory-constrained systems" 
+	depends on SQUASHFS
+	default n
+	help
+	  Saying Y here allows you to specify cache sizes and how Squashfs
+	  allocates memory.  This is only intended for memory constrained
+	  systems.
+
+	  If unsure, say N.
+
+config SQUASHFS_FRAGMENT_CACHE_SIZE
+	int "Number of fragments cached" if SQUASHFS_EMBEDDED
+	depends on SQUASHFS
+	default "3"
+	help
+	  By default SquashFS caches the last 3 fragments read from
+	  the filesystem.  Increasing this amount may mean SquashFS
+	  has to re-read fragments less often from disk, at the expense
+	  of extra system memory.  Decreasing this amount will mean
+	  SquashFS uses less memory at the expense of extra reads from disk.
+
+	  Note there must be at least one cached fragment.  Anything
+	  much more than three will probably not make much difference.
+
+config SQUASHFS_VMALLOC
+	bool "Use Vmalloc rather than Kmalloc" if SQUASHFS_EMBEDDED
+	depends on SQUASHFS
+	default n
+	help
+	  By default SquashFS uses kmalloc to obtain fragment cache memory.
+	  Kmalloc memory is the standard kernel allocator, but it can fail
+	  on memory constrained systems.  Because of the way Vmalloc works,
+	  Vmalloc can succeed when kmalloc fails.  Specifying this option
+	  will make SquashFS always use Vmalloc to allocate the
+	  fragment cache memory.
+
+	  If unsure, say N.
+
 config VXFS_FS
 	tristate "FreeVxFS file system support (VERITAS VxFS(TM) compatible)"
 	depends on BLOCK
@@ -1532,7 +1597,7 @@
 
 config NFS_FS
 	tristate "NFS file system support"
-	depends on INET
+	depends on INET && FILE_LOCKING
 	select LOCKD
 	select SUNRPC
 	select NFS_ACL_SUPPORT if NFS_V3_ACL
Index: linux-2.6.21/fs/Makefile
===================================================================
--- linux-2.6.21.orig/fs/Makefile	2009-11-30 12:44:56.000000000 +0100
+++ linux-2.6.21/fs/Makefile	2009-11-30 12:44:56.000000000 +0100
@@ -7,9 +7,9 @@
 
 obj-y :=	open.o read_write.o file_table.o super.o \
 		char_dev.o stat.o exec.o pipe.o namei.o fcntl.o \
-		ioctl.o readdir.o select.o fifo.o locks.o dcache.o inode.o \
+		ioctl.o readdir.o select.o fifo.o dcache.o inode.o \
 		attr.o bad_inode.o file.o filesystems.o namespace.o aio.o \
-		seq_file.o xattr.o libfs.o fs-writeback.o \
+		seq_file.o libfs.o fs-writeback.o \
 		pnode.o drop_caches.o splice.o sync.o utimes.o \
 		stack.o
 
@@ -21,6 +21,8 @@
 
 obj-$(CONFIG_INOTIFY)		+= inotify.o
 obj-$(CONFIG_INOTIFY_USER)	+= inotify_user.o
+obj-$(CONFIG_FILE_LOCKING)	+= locks.o
+obj-$(CONFIG_XATTR)		+= xattr.o
 obj-$(CONFIG_EPOLL)		+= eventpoll.o
 obj-$(CONFIG_COMPAT)		+= compat.o compat_ioctl.o
 
@@ -68,6 +70,7 @@
 obj-$(CONFIG_JBD2)		+= jbd2/
 obj-$(CONFIG_EXT2_FS)		+= ext2/
 obj-$(CONFIG_CRAMFS)		+= cramfs/
+obj-$(CONFIG_SQUASHFS)		+= squashfs/
 obj-$(CONFIG_RAMFS)		+= ramfs/
 obj-$(CONFIG_HUGETLBFS)		+= hugetlbfs/
 obj-$(CONFIG_CODA_FS)		+= coda/
Index: linux-2.6.21/fs/namei.c
===================================================================
--- linux-2.6.21.orig/fs/namei.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/fs/namei.c	2009-11-30 12:44:56.000000000 +0100
@@ -608,7 +608,11 @@
 		char *s = nd_get_link(nd);
 		error = 0;
 		if (s)
+#ifdef CONFIG_LINUXTINY_DO_UNINLINE
+			error = vfs_follow_link(nd, s);
+#else
 			error = __vfs_follow_link(nd, s);
+#endif
 		if (dentry->d_inode->i_op->put_link)
 			dentry->d_inode->i_op->put_link(dentry, nd, cookie);
 	}
@@ -625,7 +629,11 @@
  * Without that kind of total limit, nasty chains of consecutive
  * symlinks can cause almost arbitrarily long lookups. 
  */
+#ifdef CONFIG_LINUXTINY_DO_UNINLINE
+static int do_follow_link(struct path *path, struct nameidata *nd)
+#else
 static inline int do_follow_link(struct path *path, struct nameidata *nd)
+#endif
 {
 	int err = -ELOOP;
 	if (current->link_count >= MAX_NESTED_LINKS)
@@ -1421,8 +1429,13 @@
  *  3. We should have write and exec permissions on dir
  *  4. We can't do it if dir is immutable (done in permission())
  */
+#ifdef CONFIG_LINUXTINY_DO_UNINLINE
+static int may_create(struct inode *dir, struct dentry *child,
+			     struct nameidata *nd)
+#else
 static inline int may_create(struct inode *dir, struct dentry *child,
 			     struct nameidata *nd)
+#endif
 {
 	if (child->d_inode)
 		return -EEXIST;
Index: linux-2.6.21/fs/nfs/nfsroot.c
===================================================================
--- linux-2.6.21.orig/fs/nfs/nfsroot.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/fs/nfs/nfsroot.c	2009-11-30 12:44:56.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- *  $Id: nfsroot.c,v 1.45 1998/03/07 10:44:46 mj Exp $
+ *  $Id: nfsroot.c,v 1.1.1.1 2007-05-25 06:50:16 bruce Exp $
  *
  *  Copyright (C) 1995, 1996  Gero Kuhlmann <gero@gkminix.han.de>
  *
Index: linux-2.6.21/fs/open.c
===================================================================
--- linux-2.6.21.orig/fs/open.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/fs/open.c	2009-11-30 12:44:56.000000000 +0100
@@ -204,8 +204,14 @@
 	if (length < 0)
 		return -EINVAL;
 
+	 
+
 	newattrs.ia_size = length;
+	
+
 	newattrs.ia_valid = ATTR_SIZE | time_attrs;
+
+	
 	if (filp) {
 		newattrs.ia_file = filp;
 		newattrs.ia_valid |= ATTR_FILE;
@@ -1060,6 +1066,7 @@
 	rcu_assign_pointer(fdt->fd[fd], NULL);
 	FD_CLR(fd, fdt->close_on_exec);
 	__put_unused_fd(files, fd);
+
 	spin_unlock(&files->file_lock);
 	retval = filp_close(filp, files);
 
Index: linux-2.6.21/fs/proc/proc_misc.c
===================================================================
--- linux-2.6.21.orig/fs/proc/proc_misc.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/fs/proc/proc_misc.c	2009-11-30 12:44:56.000000000 +0100
@@ -616,6 +616,7 @@
 	return proc_calc_metrics(page, start, off, count, eof, len);
 }
 
+#ifdef CONFIG_FILE_LOCKING
 static int locks_read_proc(char *page, char **start, off_t off,
 				 int count, int *eof, void *data)
 {
@@ -625,6 +626,7 @@
 		*eof = 1;
 	return len;
 }
+#endif
 
 static int execdomains_read_proc(char *page, char **start, off_t off,
 				 int count, int *eof, void *data)
@@ -683,7 +685,9 @@
 #endif
 		{"filesystems",	filesystems_read_proc},
 		{"cmdline",	cmdline_read_proc},
+#ifdef CONFIG_FILE_LOCKING
 		{"locks",	locks_read_proc},
+#endif
 		{"execdomains",	execdomains_read_proc},
 		{NULL,}
 	};
Index: linux-2.6.21/fs/squashfs/inode.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/fs/squashfs/inode.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,2431 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * inode.c
+ */
+
+#include <linux/squashfs_fs.h>
+#include <linux/module.h>
+#include <linux/zlib.h>
+#include <linux/fs.h>
+#include <linux/squashfs_fs_sb.h>
+#include <linux/squashfs_fs_i.h>
+#include <linux/buffer_head.h>
+#include <linux/vfs.h>
+#include <linux/vmalloc.h>
+#include <linux/smp_lock.h>
+
+#include "squashfs.h"
+#include <linux/sqlzma.h>
+#include <linux/sqmagic.h>
+
+#undef KeepPreemptive
+#if defined(CONFIG_PREEMPT) && !defined(UnsquashNoPreempt)
+#define KeepPreemptive
+#endif
+
+struct sqlzma {
+#ifdef KeepPreemptive
+	struct mutex mtx;
+#endif
+	unsigned char read_data[SQUASHFS_FILE_MAX_SIZE];
+	struct sqlzma_un un;
+};
+static DEFINE_PER_CPU(struct sqlzma *, sqlzma);
+
+#define dpri(fmt, args...) /* printk("%s:%d: " fmt, __func__, __LINE__, ##args) */
+#define dpri_un(un)	dpri("un{%d, {%d %p}, {%d %p}, {%d %p}}\n", \
+			     (un)->un_lzma, (un)->un_a[0].sz, (un)->un_a[0].buf, \
+			     (un)->un_a[1].sz, (un)->un_a[1].buf, \
+			     (un)->un_a[2].sz, (un)->un_a[2].buf)
+
+static void vfs_read_inode(struct inode *i);
+static struct dentry *squashfs_get_parent(struct dentry *child);
+static int squashfs_read_inode(struct inode *i, squashfs_inode_t inode);
+static int squashfs_statfs(struct dentry *, struct kstatfs *);
+static int squashfs_symlink_readpage(struct file *file, struct page *page);
+static long long read_blocklist(struct inode *inode, int index,
+				int readahead_blks, char *block_list,
+				unsigned short **block_p, unsigned int *bsize);
+static int squashfs_readpage(struct file *file, struct page *page);
+static int squashfs_readpage4K(struct file *file, struct page *page);
+static int squashfs_readdir(struct file *, void *, filldir_t);
+static struct dentry *squashfs_lookup(struct inode *, struct dentry *,
+				struct nameidata *);
+static int squashfs_remount(struct super_block *s, int *flags, char *data);
+static void squashfs_put_super(struct super_block *);
+static int squashfs_get_sb(struct file_system_type *,int, const char *, void *,
+				struct vfsmount *);
+static struct inode *squashfs_alloc_inode(struct super_block *sb);
+static void squashfs_destroy_inode(struct inode *inode);
+static int init_inodecache(void);
+static void destroy_inodecache(void);
+
+static struct file_system_type squashfs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "squashfs",
+	.get_sb = squashfs_get_sb,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV
+};
+
+static const unsigned char squashfs_filetype_table[] = {
+	DT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK
+};
+
+static struct super_operations squashfs_super_ops = {
+	.alloc_inode = squashfs_alloc_inode,
+	.destroy_inode = squashfs_destroy_inode,
+	.statfs = squashfs_statfs,
+	.put_super = squashfs_put_super,
+	.remount_fs = squashfs_remount
+};
+
+static struct super_operations squashfs_export_super_ops = {
+	.alloc_inode = squashfs_alloc_inode,
+	.destroy_inode = squashfs_destroy_inode,
+	.statfs = squashfs_statfs,
+	.put_super = squashfs_put_super,
+	.read_inode = vfs_read_inode
+};
+
+static struct export_operations squashfs_export_ops = {
+	.get_parent = squashfs_get_parent
+};
+
+SQSH_EXTERN const struct address_space_operations squashfs_symlink_aops = {
+	.readpage = squashfs_symlink_readpage
+};
+
+SQSH_EXTERN const struct address_space_operations squashfs_aops = {
+	.readpage = squashfs_readpage
+};
+
+SQSH_EXTERN const struct address_space_operations squashfs_aops_4K = {
+	.readpage = squashfs_readpage4K
+};
+
+static const struct file_operations squashfs_dir_ops = {
+	.read = generic_read_dir,
+	.readdir = squashfs_readdir
+};
+
+SQSH_EXTERN struct inode_operations squashfs_dir_inode_ops = {
+	.lookup = squashfs_lookup
+};
+
+
+static struct buffer_head *get_block_length(struct super_block *s,
+				int *cur_index, int *offset, int *c_byte)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	unsigned short temp;
+	struct buffer_head *bh;
+
+	if (!(bh = sb_bread(s, *cur_index)))
+		goto out;
+
+	if (msblk->devblksize - *offset == 1) {
+		if (msblk->swap)
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				(bh->b_data + *offset));
+		else
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				(bh->b_data + *offset));
+		brelse(bh);
+		if (!(bh = sb_bread(s, ++(*cur_index))))
+			goto out;
+		if (msblk->swap)
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				bh->b_data); 
+		else
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				bh->b_data); 
+		*c_byte = temp;
+		*offset = 1;
+	} else {
+		if (msblk->swap) {
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				(bh->b_data + *offset));
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				(bh->b_data + *offset + 1)); 
+		} else {
+			((unsigned char *) &temp)[0] = *((unsigned char *)
+				(bh->b_data + *offset));
+			((unsigned char *) &temp)[1] = *((unsigned char *)
+				(bh->b_data + *offset + 1)); 
+		}
+		*c_byte = temp;
+		*offset += 2;
+	}
+
+	if (SQUASHFS_CHECK_DATA(msblk->sblk.flags)) {
+		if (*offset == msblk->devblksize) {
+			brelse(bh);
+			if (!(bh = sb_bread(s, ++(*cur_index))))
+				goto out;
+			*offset = 0;
+		}
+		if (*((unsigned char *) (bh->b_data + *offset)) !=
+						SQUASHFS_MARKER_BYTE) {
+			ERROR("Metadata block marker corrupt @ %x\n",
+						*cur_index);
+			brelse(bh);
+			goto out;
+		}
+		(*offset)++;
+	}
+	return bh;
+
+out:
+	return NULL;
+}
+
+
+SQSH_EXTERN unsigned int squashfs_read_data(struct super_block *s, char *buffer,
+			long long index, unsigned int length,
+			long long *next_index, int srclength)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	struct buffer_head *bh[((SQUASHFS_FILE_MAX_SIZE - 1) >>
+			msblk->devblksize_log2) + 2];
+	unsigned int offset = index & ((1 << msblk->devblksize_log2) - 1);
+	unsigned int cur_index = index >> msblk->devblksize_log2;
+	int bytes, avail_bytes, b = 0, k = 0;
+	unsigned int compressed;
+	unsigned int c_byte = length;
+
+	if (c_byte) {
+		bytes = msblk->devblksize - offset;
+		compressed = SQUASHFS_COMPRESSED_BLOCK(c_byte);
+		c_byte = SQUASHFS_COMPRESSED_SIZE_BLOCK(c_byte);
+
+		TRACE("Block @ 0x%llx, %scompressed size %d, src size %d\n", index, compressed
+					? "" : "un", (unsigned int) c_byte, srclength);
+
+		if (c_byte > srclength || index < 0 || (index + c_byte) > sblk->bytes_used)
+			goto read_failure;
+
+		if (!(bh[0] = sb_getblk(s, cur_index)))
+			goto block_release;
+
+		for (b = 1; bytes < c_byte; b++) {
+			if (!(bh[b] = sb_getblk(s, ++cur_index)))
+				goto block_release;
+			bytes += msblk->devblksize;
+		}
+		ll_rw_block(READ, b, bh);
+	} else {
+		if (index < 0 || (index + 2) > sblk->bytes_used)
+			goto read_failure;
+
+		if (!(bh[0] = get_block_length(s, &cur_index, &offset,
+								&c_byte)))
+			goto read_failure;
+
+		bytes = msblk->devblksize - offset;
+		compressed = SQUASHFS_COMPRESSED(c_byte);
+		c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
+
+		TRACE("Block @ 0x%llx, %scompressed size %d\n", index, compressed
+					? "" : "un", (unsigned int) c_byte);
+
+		if (c_byte > srclength || (index + c_byte) > sblk->bytes_used)
+			goto read_failure;
+
+		for (b = 1; bytes < c_byte; b++) {
+			if (!(bh[b] = sb_getblk(s, ++cur_index)))
+				goto block_release;
+			bytes += msblk->devblksize;
+		}
+		ll_rw_block(READ, b - 1, bh + 1);
+	}
+
+	if (compressed) {
+		int zlib_err = Z_STREAM_END;
+		int rest, start;
+		enum {Src, Dst};
+		struct sized_buf sbuf[2];
+		struct sqlzma *percpu;
+
+		/*
+	 	* uncompress block
+	 	*/
+		for (k = 0; k < b; k++) {
+			wait_on_buffer(bh[k]);
+			if (!buffer_uptodate(bh[k]))
+				goto block_release;
+		}
+
+		avail_bytes = 0;
+		for (k = 0; !avail_bytes && k < b; k++) {
+			avail_bytes = msblk->devblksize - offset;
+			if (c_byte < avail_bytes)
+				avail_bytes = c_byte;
+			if (avail_bytes)
+				break;
+			offset = 0;
+			brelse(bh[k]);
+		}
+		bytes = 0;
+		if (!avail_bytes)
+			goto block_release; // nothing to be process
+
+		start = k;
+		/* it disables preemption */
+		percpu = get_cpu_var(sqlzma);
+#ifdef KeepPreemptive
+		put_cpu_var(sqlzma);
+		mutex_lock(&percpu->mtx);
+#endif
+
+		for (; k < b; k++) {
+			memcpy(percpu->read_data + bytes, bh[k]->b_data + offset,
+			       avail_bytes);
+			bytes += avail_bytes;
+			offset = 0;
+			brelse(bh[k]);
+			avail_bytes = msblk->devblksize - offset;
+			rest = c_byte - bytes;
+			if (rest < avail_bytes)
+				avail_bytes = rest;
+		}
+
+		sbuf[Src].buf = percpu->read_data;
+		sbuf[Src].sz = bytes;
+		sbuf[Dst].buf = buffer;
+		sbuf[Dst].sz = srclength;
+		dpri_un(&percpu->un);
+		dpri("src %d %p, dst %d %p\n", sbuf[Src].sz, sbuf[Src].buf,
+		     sbuf[Dst].sz, sbuf[Dst].buf);
+		zlib_err = sqlzma_un(&percpu->un, sbuf + Src, sbuf + Dst);
+		bytes = percpu->un.un_reslen;
+
+#ifdef KeepPreemptive
+		mutex_unlock(&percpu->mtx);
+#else
+		put_cpu_var(sqlzma);
+#endif
+		if (unlikely(zlib_err)) {
+			dpri("zlib_err %d\n", zlib_err);
+			goto release_mutex;
+		}
+	} else {
+		int i;
+
+		for(i = 0; i < b; i++) {
+			wait_on_buffer(bh[i]);
+			if(!buffer_uptodate(bh[i]))
+				goto block_release;
+		}
+
+		for (bytes = 0; k < b; k++) {
+			avail_bytes = (c_byte - bytes) > (msblk->devblksize - offset) ?
+					msblk->devblksize - offset :
+					c_byte - bytes;
+			memcpy(buffer + bytes, bh[k]->b_data + offset, avail_bytes);
+			bytes += avail_bytes;
+			offset = 0;
+			brelse(bh[k]);
+		}
+	}
+
+	if (next_index)
+		*next_index = index + c_byte + (length ? 0 :
+				(SQUASHFS_CHECK_DATA(msblk->sblk.flags)
+				 ? 3 : 2));
+	return bytes;
+
+release_mutex:
+	//mutex_unlock(&msblk->read_data_mutex);
+
+block_release:
+	for (; k < b; k++)
+		brelse(bh[k]);
+
+read_failure:
+	ERROR("sb_bread failed reading block 0x%x\n", cur_index);
+	return 0;
+}
+
+
+SQSH_EXTERN int squashfs_get_cached_block(struct super_block *s, char *buffer,
+				long long block, unsigned int offset,
+				int length, long long *next_block,
+				unsigned int *next_offset)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	int n, i, bytes, return_length = length;
+	long long next_index;
+
+	TRACE("Entered squashfs_get_cached_block [%llx:%x]\n", block, offset);
+
+	while ( 1 ) {
+		for (i = 0; i < SQUASHFS_CACHED_BLKS; i++) 
+			if (msblk->block_cache[i].block == block)
+				break; 
+		
+		mutex_lock(&msblk->block_cache_mutex);
+
+		if (i == SQUASHFS_CACHED_BLKS) {
+			/* read inode header block */
+			for (i = msblk->next_cache, n = SQUASHFS_CACHED_BLKS;
+					n ; n --, i = (i + 1) %
+					SQUASHFS_CACHED_BLKS)
+				if (msblk->block_cache[i].block !=
+							SQUASHFS_USED_BLK)
+					break;
+
+			if (n == 0) {
+				wait_queue_t wait;
+
+				init_waitqueue_entry(&wait, current);
+				add_wait_queue(&msblk->waitq, &wait);
+				set_current_state(TASK_UNINTERRUPTIBLE);
+ 				mutex_unlock(&msblk->block_cache_mutex);
+				schedule();
+				set_current_state(TASK_RUNNING);
+				remove_wait_queue(&msblk->waitq, &wait);
+				continue;
+			}
+			msblk->next_cache = (i + 1) % SQUASHFS_CACHED_BLKS;
+
+			if (msblk->block_cache[i].block ==
+							SQUASHFS_INVALID_BLK) {
+				if (!(msblk->block_cache[i].data =
+						kmalloc(SQUASHFS_METADATA_SIZE,
+						GFP_KERNEL))) {
+					ERROR("Failed to allocate cache"
+							"block\n");
+					mutex_unlock(&msblk->block_cache_mutex);
+					goto out;
+				}
+			}
+	
+			msblk->block_cache[i].block = SQUASHFS_USED_BLK;
+			mutex_unlock(&msblk->block_cache_mutex);
+
+			msblk->block_cache[i].length = squashfs_read_data(s,
+				msblk->block_cache[i].data, block, 0, &next_index, SQUASHFS_METADATA_SIZE);
+			if (msblk->block_cache[i].length == 0) {
+				ERROR("Unable to read cache block [%llx:%x]\n",
+						block, offset);
+				mutex_lock(&msblk->block_cache_mutex);
+				msblk->block_cache[i].block = SQUASHFS_INVALID_BLK;
+				kfree(msblk->block_cache[i].data);
+				wake_up(&msblk->waitq);
+				mutex_unlock(&msblk->block_cache_mutex);
+				goto out;
+			}
+
+			mutex_lock(&msblk->block_cache_mutex);
+			wake_up(&msblk->waitq);
+			msblk->block_cache[i].block = block;
+			msblk->block_cache[i].next_index = next_index;
+			TRACE("Read cache block [%llx:%x]\n", block, offset);
+		}
+
+		if (msblk->block_cache[i].block != block) {
+			mutex_unlock(&msblk->block_cache_mutex);
+			continue;
+		}
+
+		bytes = msblk->block_cache[i].length - offset;
+
+		if (bytes < 1) {
+			mutex_unlock(&msblk->block_cache_mutex);
+			goto out;
+		} else if (bytes >= length) {
+			if (buffer)
+				memcpy(buffer, msblk->block_cache[i].data +
+						offset, length);
+			if (msblk->block_cache[i].length - offset == length) {
+				*next_block = msblk->block_cache[i].next_index;
+				*next_offset = 0;
+			} else {
+				*next_block = block;
+				*next_offset = offset + length;
+			}
+			mutex_unlock(&msblk->block_cache_mutex);
+			goto finish;
+		} else {
+			if (buffer) {
+				memcpy(buffer, msblk->block_cache[i].data +
+						offset, bytes);
+				buffer += bytes;
+			}
+			block = msblk->block_cache[i].next_index;
+			mutex_unlock(&msblk->block_cache_mutex);
+			length -= bytes;
+			offset = 0;
+		}
+	}
+
+finish:
+	return return_length;
+out:
+	return 0;
+}
+
+
+static int get_fragment_location(struct super_block *s, unsigned int fragment,
+				long long *fragment_start_block,
+				unsigned int *fragment_size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start_block =
+		msblk->fragment_index[SQUASHFS_FRAGMENT_INDEX(fragment)];
+	int offset = SQUASHFS_FRAGMENT_INDEX_OFFSET(fragment);
+	struct squashfs_fragment_entry fragment_entry;
+
+	if (msblk->swap) {
+		struct squashfs_fragment_entry sfragment_entry;
+
+		if (!squashfs_get_cached_block(s, (char *) &sfragment_entry,
+					start_block, offset,
+					sizeof(sfragment_entry), &start_block,
+					&offset))
+			goto out;
+		SQUASHFS_SWAP_FRAGMENT_ENTRY(&fragment_entry, &sfragment_entry);
+	} else
+		if (!squashfs_get_cached_block(s, (char *) &fragment_entry,
+					start_block, offset,
+					sizeof(fragment_entry), &start_block,
+					&offset))
+			goto out;
+
+	*fragment_start_block = fragment_entry.start_block;
+	*fragment_size = fragment_entry.size;
+
+	return 1;
+
+out:
+	return 0;
+}
+
+
+SQSH_EXTERN void release_cached_fragment(struct squashfs_sb_info *msblk, struct
+					squashfs_fragment_cache *fragment)
+{
+	mutex_lock(&msblk->fragment_mutex);
+	fragment->locked --;
+	wake_up(&msblk->fragment_wait_queue);
+	mutex_unlock(&msblk->fragment_mutex);
+}
+
+
+SQSH_EXTERN struct squashfs_fragment_cache *get_cached_fragment(struct super_block
+					*s, long long start_block,
+					int length)
+{
+	int i, n;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	while ( 1 ) {
+		mutex_lock(&msblk->fragment_mutex);
+
+		for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS &&
+				msblk->fragment[i].block != start_block; i++);
+
+		if (i == SQUASHFS_CACHED_FRAGMENTS) {
+			for (i = msblk->next_fragment, n =
+				SQUASHFS_CACHED_FRAGMENTS; n &&
+				msblk->fragment[i].locked; n--, i = (i + 1) %
+				SQUASHFS_CACHED_FRAGMENTS);
+
+			if (n == 0) {
+				wait_queue_t wait;
+
+				init_waitqueue_entry(&wait, current);
+				add_wait_queue(&msblk->fragment_wait_queue,
+									&wait);
+				set_current_state(TASK_UNINTERRUPTIBLE);
+				mutex_unlock(&msblk->fragment_mutex);
+				schedule();
+				set_current_state(TASK_RUNNING);
+				remove_wait_queue(&msblk->fragment_wait_queue,
+									&wait);
+				continue;
+			}
+			msblk->next_fragment = (msblk->next_fragment + 1) %
+				SQUASHFS_CACHED_FRAGMENTS;
+			
+			if (msblk->fragment[i].data == NULL)
+				if (!(msblk->fragment[i].data = SQUASHFS_ALLOC
+						(SQUASHFS_FILE_MAX_SIZE))) {
+					ERROR("Failed to allocate fragment "
+							"cache block\n");
+					mutex_unlock(&msblk->fragment_mutex);
+					goto out;
+				}
+
+			msblk->fragment[i].block = SQUASHFS_INVALID_BLK;
+			msblk->fragment[i].locked = 1;
+			mutex_unlock(&msblk->fragment_mutex);
+
+			if (!(msblk->fragment[i].length = squashfs_read_data(s,
+						msblk->fragment[i].data,
+						start_block, length, NULL, sblk->block_size))) {
+				ERROR("Unable to read fragment cache block "
+							"[%llx]\n", start_block);
+				msblk->fragment[i].locked = 0;
+				smp_mb();
+				goto out;
+			}
+
+			mutex_lock(&msblk->fragment_mutex);
+			msblk->fragment[i].block = start_block;
+			TRACE("New fragment %d, start block %lld, locked %d\n",
+						i, msblk->fragment[i].block,
+						msblk->fragment[i].locked);
+			mutex_unlock(&msblk->fragment_mutex);
+			break;
+		}
+
+		msblk->fragment[i].locked++;
+		mutex_unlock(&msblk->fragment_mutex);
+		TRACE("Got fragment %d, start block %lld, locked %d\n", i,
+						msblk->fragment[i].block,
+						msblk->fragment[i].locked);
+		break;
+	}
+
+	return &msblk->fragment[i];
+
+out:
+	return NULL;
+}
+
+
+static void squashfs_new_inode(struct squashfs_sb_info *msblk, struct inode *i,
+		struct squashfs_base_inode_header *inodeb)
+{
+	i->i_ino = inodeb->inode_number;
+	i->i_mtime.tv_sec = inodeb->mtime;
+	i->i_atime.tv_sec = inodeb->mtime;
+	i->i_ctime.tv_sec = inodeb->mtime;
+	i->i_uid = msblk->uid[inodeb->uid];
+	i->i_mode = inodeb->mode;
+	i->i_size = 0;
+	if (inodeb->guid == SQUASHFS_GUIDS)
+		i->i_gid = i->i_uid;
+	else
+		i->i_gid = msblk->guid[inodeb->guid];
+}
+
+
+static squashfs_inode_t squashfs_inode_lookup(struct super_block *s, int ino)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start = msblk->inode_lookup_table[SQUASHFS_LOOKUP_BLOCK(ino - 1)];
+	int offset = SQUASHFS_LOOKUP_BLOCK_OFFSET(ino - 1);
+	squashfs_inode_t inode;
+
+	TRACE("Entered squashfs_inode_lookup, inode_number = %d\n", ino);
+
+	if (msblk->swap) {
+		squashfs_inode_t sinode;
+
+		if (!squashfs_get_cached_block(s, (char *) &sinode, start, offset,
+					sizeof(sinode), &start, &offset))
+			goto out;
+		SQUASHFS_SWAP_INODE_T((&inode), &sinode);
+	} else if (!squashfs_get_cached_block(s, (char *) &inode, start, offset,
+					sizeof(inode), &start, &offset))
+			goto out;
+
+	TRACE("squashfs_inode_lookup, inode = 0x%llx\n", inode);
+
+	return inode;
+
+out:
+	return SQUASHFS_INVALID_BLK;
+}
+	
+
+static void vfs_read_inode(struct inode *i)
+{
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	squashfs_inode_t inode = squashfs_inode_lookup(i->i_sb, i->i_ino);
+
+	TRACE("Entered vfs_read_inode\n");
+
+	if(inode != SQUASHFS_INVALID_BLK)
+		(msblk->read_inode)(i, inode);
+}
+
+
+static struct dentry *squashfs_get_parent(struct dentry *child)
+{
+	struct inode *i = child->d_inode;
+	struct inode *parent = iget(i->i_sb, SQUASHFS_I(i)->u.s2.parent_inode);
+	struct dentry *rv;
+
+	TRACE("Entered squashfs_get_parent\n");
+
+	if(parent == NULL) {
+		rv = ERR_PTR(-EACCES);
+		goto out;
+	}
+
+	rv = d_alloc_anon(parent);
+	if(rv == NULL)
+		rv = ERR_PTR(-ENOMEM);
+
+out:
+	return rv;
+}
+
+	
+SQSH_EXTERN struct inode *squashfs_iget(struct super_block *s, squashfs_inode_t inode, unsigned int inode_number)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct inode *i = iget_locked(s, inode_number);
+
+	TRACE("Entered squashfs_iget\n");
+
+	if(i && (i->i_state & I_NEW)) {
+		(msblk->read_inode)(i, inode);
+		unlock_new_inode(i);
+	}
+
+	return i;
+}
+
+
+static int squashfs_read_inode(struct inode *i, squashfs_inode_t inode)
+{
+	struct super_block *s = i->i_sb;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long block = SQUASHFS_INODE_BLK(inode) +
+		sblk->inode_table_start;
+	unsigned int offset = SQUASHFS_INODE_OFFSET(inode);
+	long long next_block;
+	unsigned int next_offset;
+	union squashfs_inode_header id, sid;
+	struct squashfs_base_inode_header *inodeb = &id.base,
+					  *sinodeb = &sid.base;
+
+	TRACE("Entered squashfs_read_inode\n");
+
+	if (msblk->swap) {
+		if (!squashfs_get_cached_block(s, (char *) sinodeb, block,
+					offset, sizeof(*sinodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+		SQUASHFS_SWAP_BASE_INODE_HEADER(inodeb, sinodeb,
+					sizeof(*sinodeb));
+	} else
+		if (!squashfs_get_cached_block(s, (char *) inodeb, block,
+					offset, sizeof(*inodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+
+	squashfs_new_inode(msblk, i, inodeb);
+
+	switch(inodeb->inode_type) {
+		case SQUASHFS_FILE_TYPE: {
+			unsigned int frag_size;
+			long long frag_blk;
+			struct squashfs_reg_inode_header *inodep = &id.reg;
+			struct squashfs_reg_inode_header *sinodep = &sid.reg;
+				
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_REG_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG &&
+					!get_fragment_location(s,
+					inodep->fragment, &frag_blk, &frag_size))
+				goto failed_read;
+				
+			i->i_nlink = 1;
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			if (sblk->block_size > 4096)
+				i->i_data.a_ops = &squashfs_aops;
+			else
+				i->i_data.a_ops = &squashfs_aops_4K;
+
+			TRACE("File inode %x:%x, start_block %llx, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_LREG_TYPE: {
+			unsigned int frag_size;
+			long long frag_blk;
+			struct squashfs_lreg_inode_header *inodep = &id.lreg;
+			struct squashfs_lreg_inode_header *sinodep = &sid.lreg;
+				
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LREG_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG &&
+					!get_fragment_location(s,
+					inodep->fragment, &frag_blk, &frag_size))
+				goto failed_read;
+				
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			if (sblk->block_size > 4096)
+				i->i_data.a_ops = &squashfs_aops;
+			else
+				i->i_data.a_ops = &squashfs_aops_4K;
+
+			TRACE("File inode %x:%x, start_block %llx, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_DIR_TYPE: {
+			struct squashfs_dir_inode_header *inodep = &id.dir;
+			struct squashfs_dir_inode_header *sinodep = &sid.dir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DIR_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops;
+			i->i_fop = &squashfs_dir_ops;
+			i->i_mode |= S_IFDIR;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = 0;
+			SQUASHFS_I(i)->u.s2.parent_inode = inodep->parent_inode;
+
+			TRACE("Directory inode %x:%x, start_block %x, offset "
+					"%x\n", SQUASHFS_INODE_BLK(inode),
+					offset, inodep->start_block,
+					inodep->offset);
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			struct squashfs_ldir_inode_header *inodep = &id.ldir;
+			struct squashfs_ldir_inode_header *sinodep = &sid.ldir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LDIR_INODE_HEADER(inodep,
+						sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops;
+			i->i_fop = &squashfs_dir_ops;
+			i->i_mode |= S_IFDIR;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_start = next_block;
+			SQUASHFS_I(i)->u.s2.directory_index_offset =
+								next_offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count =
+								inodep->i_count;
+			SQUASHFS_I(i)->u.s2.parent_inode = inodep->parent_inode;
+
+			TRACE("Long directory inode %x:%x, start_block %x, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, inodep->offset);
+			break;
+		}
+		case SQUASHFS_SYMLINK_TYPE: {
+			struct squashfs_symlink_inode_header *inodep =
+								&id.symlink;
+			struct squashfs_symlink_inode_header *sinodep =
+								&sid.symlink;
+	
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER(inodep,
+								sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->symlink_size;
+			i->i_op = &page_symlink_inode_operations;
+			i->i_data.a_ops = &squashfs_symlink_aops;
+			i->i_mode |= S_IFLNK;
+			SQUASHFS_I(i)->start_block = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+
+			TRACE("Symbolic link inode %x:%x, start_block %llx, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					next_block, next_offset);
+			break;
+		 }
+		 case SQUASHFS_BLKDEV_TYPE:
+		 case SQUASHFS_CHRDEV_TYPE: {
+			struct squashfs_dev_inode_header *inodep = &id.dev;
+			struct squashfs_dev_inode_header *sinodep = &sid.dev;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DEV_INODE_HEADER(inodep, sinodep);
+			} else	
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_mode |= (inodeb->inode_type ==
+					SQUASHFS_CHRDEV_TYPE) ?  S_IFCHR :
+					S_IFBLK;
+			init_special_inode(i, i->i_mode,
+					old_decode_dev(inodep->rdev));
+
+			TRACE("Device inode %x:%x, rdev %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->rdev);
+			break;
+		 }
+		 case SQUASHFS_FIFO_TYPE:
+		 case SQUASHFS_SOCKET_TYPE: {
+			struct squashfs_ipc_inode_header *inodep = &id.ipc;
+			struct squashfs_ipc_inode_header *sinodep = &sid.ipc;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_IPC_INODE_HEADER(inodep, sinodep);
+			} else	
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_mode |= (inodeb->inode_type == SQUASHFS_FIFO_TYPE)
+							? S_IFIFO : S_IFSOCK;
+			init_special_inode(i, i->i_mode, 0);
+			break;
+		 }
+		 default:
+			ERROR("Unknown inode type %d in squashfs_iget!\n",
+					inodeb->inode_type);
+			goto failed_read1;
+	}
+	
+	return 1;
+
+failed_read:
+	ERROR("Unable to read inode [%llx:%x]\n", block, offset);
+
+failed_read1:
+	make_bad_inode(i);
+	return 0;
+}
+
+
+static int read_inode_lookup_table(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned int length = SQUASHFS_LOOKUP_BLOCK_BYTES(sblk->inodes);
+
+	TRACE("In read_inode_lookup_table, length %d\n", length);
+
+	/* Allocate inode lookup table */
+	if (!(msblk->inode_lookup_table = kmalloc(length, GFP_KERNEL))) {
+		ERROR("Failed to allocate inode lookup table\n");
+		return 0;
+	}
+   
+	if (!squashfs_read_data(s, (char *) msblk->inode_lookup_table,
+			sblk->lookup_table_start, length |
+			SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, length)) {
+		ERROR("unable to read inode lookup table\n");
+		return 0;
+	}
+
+	if (msblk->swap) {
+		int i;
+		long long block;
+
+		for (i = 0; i < SQUASHFS_LOOKUP_BLOCKS(sblk->inodes); i++) {
+			SQUASHFS_SWAP_LOOKUP_BLOCKS((&block),
+						&msblk->inode_lookup_table[i], 1);
+			msblk->inode_lookup_table[i] = block;
+		}
+	}
+
+	return 1;
+}
+
+
+static int read_fragment_index_table(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned int length = SQUASHFS_FRAGMENT_INDEX_BYTES(sblk->fragments);
+
+	if(length == 0)
+		return 1;
+
+	/* Allocate fragment index table */
+	if (!(msblk->fragment_index = kmalloc(length, GFP_KERNEL))) {
+		ERROR("Failed to allocate fragment index table\n");
+		return 0;
+	}
+   
+	if (!squashfs_read_data(s, (char *) msblk->fragment_index,
+			sblk->fragment_table_start, length |
+			SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, length)) {
+		ERROR("unable to read fragment index table\n");
+		return 0;
+	}
+
+	if (msblk->swap) {
+		int i;
+		long long fragment;
+
+		for (i = 0; i < SQUASHFS_FRAGMENT_INDEXES(sblk->fragments); i++) {
+			SQUASHFS_SWAP_FRAGMENT_INDEXES((&fragment),
+						&msblk->fragment_index[i], 1);
+			msblk->fragment_index[i] = fragment;
+		}
+	}
+
+	return 1;
+}
+
+
+static int supported_squashfs_filesystem(struct squashfs_sb_info *msblk, int silent)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	msblk->read_inode = squashfs_read_inode;
+	msblk->read_blocklist = read_blocklist;
+	msblk->read_fragment_index_table = read_fragment_index_table;
+
+	if (sblk->s_major == 1) {
+		if (!squashfs_1_0_supported(msblk)) {
+			SERROR("Major/Minor mismatch, Squashfs 1.0 filesystems "
+				"are unsupported\n");
+			SERROR("Please recompile with "
+				"Squashfs 1.0 support enabled\n");
+			return 0;
+		}
+	} else if (sblk->s_major == 2) {
+		if (!squashfs_2_0_supported(msblk)) {
+			SERROR("Major/Minor mismatch, Squashfs 2.0 filesystems "
+				"are unsupported\n");
+			SERROR("Please recompile with "
+				"Squashfs 2.0 support enabled\n");
+			return 0;
+		}
+	} else if(sblk->s_major != SQUASHFS_MAJOR || sblk->s_minor >
+			SQUASHFS_MINOR) {
+		SERROR("Major/Minor mismatch, trying to mount newer %d.%d "
+				"filesystem\n", sblk->s_major, sblk->s_minor);
+		SERROR("Please update your kernel\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+
+static int squashfs_fill_super(struct super_block *s, void *data, int silent)
+{
+	struct squashfs_sb_info *msblk;
+	struct squashfs_super_block *sblk;
+	int i, err;
+	char b[BDEVNAME_SIZE];
+	struct inode *root;
+	void *label;
+
+	TRACE("Entered squashfs_read_superblock\n");
+
+	err = -ENOMEM;
+	if (!(s->s_fs_info = kmalloc(sizeof(struct squashfs_sb_info),
+						GFP_KERNEL))) {
+		ERROR("Failed to allocate superblock\n");
+		goto failure;
+	}
+	label = &&out_fsinfo;
+	memset(s->s_fs_info, 0, sizeof(struct squashfs_sb_info));
+	msblk = s->s_fs_info;
+	sblk = &msblk->sblk;
+	
+	msblk->devblksize = sb_min_blocksize(s, BLOCK_SIZE);
+	msblk->devblksize_log2 = ffz(~msblk->devblksize);
+
+	//mutex_init(&msblk->read_data_mutex);
+	mutex_init(&msblk->read_page_mutex);
+	mutex_init(&msblk->block_cache_mutex);
+	mutex_init(&msblk->fragment_mutex);
+	mutex_init(&msblk->meta_index_mutex);
+	
+	init_waitqueue_head(&msblk->waitq);
+	init_waitqueue_head(&msblk->fragment_wait_queue);
+
+	err = -EINVAL;
+	sblk->bytes_used = sizeof(struct squashfs_super_block);
+	if (!squashfs_read_data(s, (char *) sblk, SQUASHFS_START,
+					sizeof(struct squashfs_super_block) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, sizeof(struct squashfs_super_block))) {
+		SERROR("unable to read superblock\n");
+		goto *label;
+	}
+
+	/* Check it is a SQUASHFS superblock */
+	s->s_magic = sblk->s_magic;
+	msblk->swap = 0;
+	dpri("magic 0x%x\n", sblk->s_magic);
+	switch (sblk->s_magic) {
+		struct squashfs_super_block ssblk;
+
+	case SQUASHFS_MAGIC_SWAP:
+		/*FALLTHROUGH*/
+	case SQUASHFS_MAGIC_LZMA_SWAP:
+		WARNING("Mounting a different endian SQUASHFS "
+			"filesystem on %s\n", bdevname(s->s_bdev, b));
+
+		SQUASHFS_SWAP_SUPER_BLOCK(&ssblk, sblk);
+		memcpy(sblk, &ssblk, sizeof(struct squashfs_super_block));
+		msblk->swap = 1;
+		/*FALLTHROUGH*/
+	case SQUASHFS_MAGIC:
+	case SQUASHFS_MAGIC_LZMA:
+		break;
+	default:
+		SERROR("Can't find a SQUASHFS superblock on %s\n",
+		       bdevname(s->s_bdev, b));
+		goto *label;
+	}
+
+	{
+		struct sqlzma *p;
+		dpri("block_size %d\n", sblk->block_size);
+		BUG_ON(sblk->block_size > sizeof(p->read_data));
+	}
+
+	/* Check the MAJOR & MINOR versions */
+	err = -EINVAL;
+	if(!supported_squashfs_filesystem(msblk, silent))
+		goto *label;
+
+	/* Check the filesystem does not extend beyond the end of the
+	   block device */
+	if(sblk->bytes_used < 0 || sblk->bytes_used > i_size_read(s->s_bdev->bd_inode))
+		goto *label;
+
+	/* Check the root inode for sanity */
+	if (SQUASHFS_INODE_OFFSET(sblk->root_inode) > SQUASHFS_METADATA_SIZE)
+		goto *label;
+
+	TRACE("Found valid superblock on %s\n", bdevname(s->s_bdev, b));
+	TRACE("Inodes are %scompressed\n",
+					SQUASHFS_UNCOMPRESSED_INODES
+					(sblk->flags) ? "un" : "");
+	TRACE("Data is %scompressed\n",
+					SQUASHFS_UNCOMPRESSED_DATA(sblk->flags)
+					? "un" : "");
+	TRACE("Check data is %s present in the filesystem\n",
+					SQUASHFS_CHECK_DATA(sblk->flags) ?
+					"" : "not");
+	TRACE("Filesystem size %lld bytes\n", sblk->bytes_used);
+	TRACE("Block size %d\n", sblk->block_size);
+	TRACE("Number of inodes %d\n", sblk->inodes);
+	if (sblk->s_major > 1)
+		TRACE("Number of fragments %d\n", sblk->fragments);
+	TRACE("Number of uids %d\n", sblk->no_uids);
+	TRACE("Number of gids %d\n", sblk->no_guids);
+	TRACE("sblk->inode_table_start %llx\n", sblk->inode_table_start);
+	TRACE("sblk->directory_table_start %llx\n", sblk->directory_table_start);
+	if (sblk->s_major > 1)
+		TRACE("sblk->fragment_table_start %llx\n",
+					sblk->fragment_table_start);
+	TRACE("sblk->uid_start %llx\n", sblk->uid_start);
+
+	s->s_flags |= MS_RDONLY;
+	s->s_op = &squashfs_super_ops;
+
+	/* Init inode_table block pointer array */
+	err = -ENOMEM;
+	if (!(msblk->block_cache = kmalloc(sizeof(struct squashfs_cache) *
+					SQUASHFS_CACHED_BLKS, GFP_KERNEL))) {
+		ERROR("Failed to allocate block cache\n");
+		goto *label;
+	}
+	label = &&out_block_cache;
+
+	for (i = 0; i < SQUASHFS_CACHED_BLKS; i++)
+		msblk->block_cache[i].block = SQUASHFS_INVALID_BLK;
+
+	msblk->next_cache = 0;
+
+	/* Allocate read_page block */
+	if (!(msblk->read_page = kmalloc(sblk->block_size, GFP_KERNEL))) {
+		ERROR("Failed to allocate read_page block\n");
+		goto *label;
+	}
+	label = &&out_read_page;
+
+	/* Allocate uid and gid tables */
+	if (!(msblk->uid = kmalloc((sblk->no_uids + sblk->no_guids) *
+					sizeof(unsigned int), GFP_KERNEL))) {
+		ERROR("Failed to allocate uid/gid table\n");
+		goto *label;
+	}
+	label = &&out_uid;
+	msblk->guid = msblk->uid + sblk->no_uids;
+   
+	dpri("swap %d\n", msblk->swap);
+	err = -EINVAL;
+	if (msblk->swap) {
+		unsigned int suid[sblk->no_uids + sblk->no_guids];
+
+		if (!squashfs_read_data(s, (char *) &suid, sblk->uid_start,
+					((sblk->no_uids + sblk->no_guids) *
+					 sizeof(unsigned int)) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, (sblk->no_uids + sblk->no_guids) * sizeof(unsigned int))) {
+			ERROR("unable to read uid/gid table\n");
+			goto *label;
+		}
+
+		SQUASHFS_SWAP_DATA(msblk->uid, suid, (sblk->no_uids +
+			sblk->no_guids), (sizeof(unsigned int) * 8));
+	} else
+		if (!squashfs_read_data(s, (char *) msblk->uid, sblk->uid_start,
+					((sblk->no_uids + sblk->no_guids) *
+					 sizeof(unsigned int)) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, (sblk->no_uids + sblk->no_guids) * sizeof(unsigned int))) {
+			ERROR("unable to read uid/gid table\n");
+			goto *label;
+		}
+
+
+	if (sblk->s_major == 1 && squashfs_1_0_supported(msblk))
+		goto allocate_root;
+
+	err = -ENOMEM;
+	if (!(msblk->fragment = kmalloc(sizeof(struct squashfs_fragment_cache) *
+				SQUASHFS_CACHED_FRAGMENTS, GFP_KERNEL))) {
+		ERROR("Failed to allocate fragment block cache\n");
+		goto *label;
+	}
+	label = &&out_fragment;
+
+	for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++) {
+		msblk->fragment[i].locked = 0;
+		msblk->fragment[i].block = SQUASHFS_INVALID_BLK;
+		msblk->fragment[i].data = NULL;
+	}
+
+	msblk->next_fragment = 0;
+
+	/* Allocate and read fragment index table */
+	if (msblk->read_fragment_index_table(s) == 0)
+		goto *label;
+
+	if(sblk->s_major < 3 || sblk->lookup_table_start == SQUASHFS_INVALID_BLK)
+		goto allocate_root;
+
+	/* Allocate and read inode lookup table */
+	if (read_inode_lookup_table(s) == 0)
+		goto failed_mount;
+
+	s->s_op = &squashfs_export_super_ops;
+	s->s_export_op = &squashfs_export_ops;
+
+allocate_root:
+	dpri("alloate_root\n");
+	root = new_inode(s);
+	if ((msblk->read_inode)(root, sblk->root_inode) == 0) {
+		iput(root);
+		goto failed_mount;
+	}
+	insert_inode_hash(root);
+
+	if ((s->s_root = d_alloc_root(root)) == NULL) {
+		ERROR("Root inode create failed\n");
+		iput(root);
+		goto failed_mount;
+	}
+
+	TRACE("Leaving squashfs_read_super\n");
+	return 0;
+
+failed_mount:
+	kfree(msblk->inode_lookup_table);
+	kfree(msblk->fragment_index);
+	kfree(msblk->fragment_index_2);
+ out_fragment:
+	kfree(msblk->fragment);
+ out_uid:
+	kfree(msblk->uid);
+ out_read_page:
+	kfree(msblk->read_page);
+ out_block_cache:
+	kfree(msblk->block_cache);
+ out_fsinfo:
+	kfree(s->s_fs_info);
+	s->s_fs_info = NULL;
+ failure:
+	return err;
+}
+
+
+static int squashfs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct squashfs_sb_info *msblk = dentry->d_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	TRACE("Entered squashfs_statfs\n");
+
+	buf->f_type = sblk->s_magic;
+	buf->f_bsize = sblk->block_size;
+	buf->f_blocks = ((sblk->bytes_used - 1) >> sblk->block_log) + 1;
+	buf->f_bfree = buf->f_bavail = 0;
+	buf->f_files = sblk->inodes;
+	buf->f_ffree = 0;
+	buf->f_namelen = SQUASHFS_NAME_LEN;
+
+	return 0;
+}
+
+
+static int squashfs_symlink_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	int index = page->index << PAGE_CACHE_SHIFT, length, bytes;
+	long long block = SQUASHFS_I(inode)->start_block;
+	int offset = SQUASHFS_I(inode)->offset;
+	void *pageaddr = kmap(page);
+
+	TRACE("Entered squashfs_symlink_readpage, page index %ld, start block "
+				"%llx, offset %x\n", page->index,
+				SQUASHFS_I(inode)->start_block,
+				SQUASHFS_I(inode)->offset);
+
+	for (length = 0; length < index; length += bytes) {
+		if (!(bytes = squashfs_get_cached_block(inode->i_sb, NULL,
+				block, offset, PAGE_CACHE_SIZE, &block,
+				&offset))) {
+			ERROR("Unable to read symbolic link [%llx:%x]\n", block,
+					offset);
+			goto skip_read;
+		}
+	}
+
+	if (length != index) {
+		ERROR("(squashfs_symlink_readpage) length != index\n");
+		bytes = 0;
+		goto skip_read;
+	}
+
+	bytes = (i_size_read(inode) - length) > PAGE_CACHE_SIZE ? PAGE_CACHE_SIZE :
+					i_size_read(inode) - length;
+
+	if (!(bytes = squashfs_get_cached_block(inode->i_sb, pageaddr, block,
+					offset, bytes, &block, &offset)))
+		ERROR("Unable to read symbolic link [%llx:%x]\n", block, offset);
+
+skip_read:
+	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
+	kunmap(page);
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	return 0;
+}
+
+
+struct meta_index *locate_meta_index(struct inode *inode, int index, int offset)
+{
+	struct meta_index *meta = NULL;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	int i;
+
+	mutex_lock(&msblk->meta_index_mutex);
+
+	TRACE("locate_meta_index: index %d, offset %d\n", index, offset);
+
+	if(msblk->meta_index == NULL)
+		goto not_allocated;
+
+	for (i = 0; i < SQUASHFS_META_NUMBER; i ++)
+		if (msblk->meta_index[i].inode_number == inode->i_ino &&
+				msblk->meta_index[i].offset >= offset &&
+				msblk->meta_index[i].offset <= index &&
+				msblk->meta_index[i].locked == 0) {
+			TRACE("locate_meta_index: entry %d, offset %d\n", i,
+					msblk->meta_index[i].offset);
+			meta = &msblk->meta_index[i];
+			offset = meta->offset;
+		}
+
+	if (meta)
+		meta->locked = 1;
+
+not_allocated:
+	mutex_unlock(&msblk->meta_index_mutex);
+
+	return meta;
+}
+
+
+struct meta_index *empty_meta_index(struct inode *inode, int offset, int skip)
+{
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct meta_index *meta = NULL;
+	int i;
+
+	mutex_lock(&msblk->meta_index_mutex);
+
+	TRACE("empty_meta_index: offset %d, skip %d\n", offset, skip);
+
+	if(msblk->meta_index == NULL) {
+		if (!(msblk->meta_index = kmalloc(sizeof(struct meta_index) *
+					SQUASHFS_META_NUMBER, GFP_KERNEL))) {
+			ERROR("Failed to allocate meta_index\n");
+			goto failed;
+		}
+		for(i = 0; i < SQUASHFS_META_NUMBER; i++) {
+			msblk->meta_index[i].inode_number = 0;
+			msblk->meta_index[i].locked = 0;
+		}
+		msblk->next_meta_index = 0;
+	}
+
+	for(i = SQUASHFS_META_NUMBER; i &&
+			msblk->meta_index[msblk->next_meta_index].locked; i --)
+		msblk->next_meta_index = (msblk->next_meta_index + 1) %
+			SQUASHFS_META_NUMBER;
+
+	if(i == 0) {
+		TRACE("empty_meta_index: failed!\n");
+		goto failed;
+	}
+
+	TRACE("empty_meta_index: returned meta entry %d, %p\n",
+			msblk->next_meta_index,
+			&msblk->meta_index[msblk->next_meta_index]);
+
+	meta = &msblk->meta_index[msblk->next_meta_index];
+	msblk->next_meta_index = (msblk->next_meta_index + 1) %
+			SQUASHFS_META_NUMBER;
+
+	meta->inode_number = inode->i_ino;
+	meta->offset = offset;
+	meta->skip = skip;
+	meta->entries = 0;
+	meta->locked = 1;
+
+failed:
+	mutex_unlock(&msblk->meta_index_mutex);
+	return meta;
+}
+
+
+void release_meta_index(struct inode *inode, struct meta_index *meta)
+{
+	meta->locked = 0;
+	smp_mb();
+}
+
+
+static int read_block_index(struct super_block *s, int blocks, char *block_list,
+		long long *start_block, int *offset)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	unsigned int *block_listp;
+	int block = 0;
+	
+	if (msblk->swap) {
+		char sblock_list[blocks << 2];
+
+		if (!squashfs_get_cached_block(s, sblock_list, *start_block,
+				*offset, blocks << 2, start_block, offset)) {
+			ERROR("Unable to read block list [%llx:%x]\n",
+				*start_block, *offset);
+			goto failure;
+		}
+		SQUASHFS_SWAP_INTS(((unsigned int *)block_list),
+				((unsigned int *)sblock_list), blocks);
+	} else
+		if (!squashfs_get_cached_block(s, block_list, *start_block,
+				*offset, blocks << 2, start_block, offset)) {
+			ERROR("Unable to read block list [%llx:%x]\n",
+				*start_block, *offset);
+			goto failure;
+		}
+
+	for (block_listp = (unsigned int *) block_list; blocks;
+				block_listp++, blocks --)
+		block += SQUASHFS_COMPRESSED_SIZE_BLOCK(*block_listp);
+
+	return block;
+
+failure:
+	return -1;
+}
+
+
+#define SIZE 256
+
+static inline int calculate_skip(int blocks) {
+	int skip = (blocks - 1) / ((SQUASHFS_SLOTS * SQUASHFS_META_ENTRIES + 1) * SQUASHFS_META_INDEXES);
+	return skip >= 7 ? 7 : skip + 1;
+}
+
+
+static int get_meta_index(struct inode *inode, int index,
+		long long *index_block, int *index_offset,
+		long long *data_block, char *block_list)
+{
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int skip = calculate_skip(i_size_read(inode) >> sblk->block_log);
+	int offset = 0;
+	struct meta_index *meta;
+	struct meta_entry *meta_entry;
+	long long cur_index_block = SQUASHFS_I(inode)->u.s1.block_list_start;
+	int cur_offset = SQUASHFS_I(inode)->offset;
+	long long cur_data_block = SQUASHFS_I(inode)->start_block;
+	int i;
+ 
+	index /= SQUASHFS_META_INDEXES * skip;
+
+	while ( offset < index ) {
+		meta = locate_meta_index(inode, index, offset + 1);
+
+		if (meta == NULL) {
+			if ((meta = empty_meta_index(inode, offset + 1,
+							skip)) == NULL)
+				goto all_done;
+		} else {
+			if(meta->entries == 0)
+				goto failed;
+			offset = index < meta->offset + meta->entries ? index :
+				meta->offset + meta->entries - 1;
+			meta_entry = &meta->meta_entry[offset - meta->offset];
+			cur_index_block = meta_entry->index_block + sblk->inode_table_start;
+			cur_offset = meta_entry->offset;
+			cur_data_block = meta_entry->data_block;
+			TRACE("get_meta_index: offset %d, meta->offset %d, "
+				"meta->entries %d\n", offset, meta->offset,
+				meta->entries);
+			TRACE("get_meta_index: index_block 0x%llx, offset 0x%x"
+				" data_block 0x%llx\n", cur_index_block,
+				cur_offset, cur_data_block);
+		}
+
+		for (i = meta->offset + meta->entries; i <= index &&
+				i < meta->offset + SQUASHFS_META_ENTRIES; i++) {
+			int blocks = skip * SQUASHFS_META_INDEXES;
+
+			while (blocks) {
+				int block = blocks > (SIZE >> 2) ? (SIZE >> 2) :
+					blocks;
+				int res = read_block_index(inode->i_sb, block,
+					block_list, &cur_index_block,
+					&cur_offset);
+
+				if (res == -1)
+					goto failed;
+
+				cur_data_block += res;
+				blocks -= block;
+			}
+
+			meta_entry = &meta->meta_entry[i - meta->offset];
+			meta_entry->index_block = cur_index_block - sblk->inode_table_start;
+			meta_entry->offset = cur_offset;
+			meta_entry->data_block = cur_data_block;
+			meta->entries ++;
+			offset ++;
+		}
+
+		TRACE("get_meta_index: meta->offset %d, meta->entries %d\n",
+				meta->offset, meta->entries);
+
+		release_meta_index(inode, meta);
+	}
+
+all_done:
+	*index_block = cur_index_block;
+	*index_offset = cur_offset;
+	*data_block = cur_data_block;
+
+	return offset * SQUASHFS_META_INDEXES * skip;
+
+failed:
+	release_meta_index(inode, meta);
+	return -1;
+}
+
+
+static long long read_blocklist(struct inode *inode, int index,
+				int readahead_blks, char *block_list,
+				unsigned short **block_p, unsigned int *bsize)
+{
+	long long block_ptr;
+	int offset;
+	long long block;
+	int res = get_meta_index(inode, index, &block_ptr, &offset, &block,
+		block_list);
+
+	TRACE("read_blocklist: res %d, index %d, block_ptr 0x%llx, offset"
+		       " 0x%x, block 0x%llx\n", res, index, block_ptr, offset,
+		       block);
+
+	if(res == -1)
+		goto failure;
+
+	index -= res;
+
+	while ( index ) {
+		int blocks = index > (SIZE >> 2) ? (SIZE >> 2) : index;
+		int res = read_block_index(inode->i_sb, blocks, block_list,
+			&block_ptr, &offset);
+		if (res == -1)
+			goto failure;
+		block += res;
+		index -= blocks;
+	}
+
+	if (read_block_index(inode->i_sb, 1, block_list,
+			&block_ptr, &offset) == -1)
+		goto failure;
+	*bsize = *((unsigned int *) block_list);
+
+	return block;
+
+failure:
+	return 0;
+}
+
+
+static int squashfs_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned char *block_list;
+	long long block;
+	unsigned int bsize, i = 0, bytes = 0, byte_offset = 0;
+	int index = page->index >> (sblk->block_log - PAGE_CACHE_SHIFT);
+ 	void *pageaddr;
+	struct squashfs_fragment_cache *fragment = NULL;
+	char *data_ptr = msblk->read_page;
+	
+	int mask = (1 << (sblk->block_log - PAGE_CACHE_SHIFT)) - 1;
+	int start_index = page->index & ~mask;
+	int end_index = start_index | mask;
+
+	TRACE("Entered squashfs_readpage, page index %lx, start block %llx\n",
+					page->index,
+					SQUASHFS_I(inode)->start_block);
+
+	if (!(block_list = kmalloc(SIZE, GFP_KERNEL))) {
+		ERROR("Failed to allocate block_list\n");
+		goto skip_read;
+	}
+
+	if (page->index >= ((i_size_read(inode) + PAGE_CACHE_SIZE - 1) >>
+					PAGE_CACHE_SHIFT))
+		goto skip_read;
+
+	if (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK
+					|| index < (i_size_read(inode) >>
+					sblk->block_log)) {
+		if ((block = (msblk->read_blocklist)(inode, index, 1,
+					block_list, NULL, &bsize)) == 0)
+			goto skip_read;
+
+		mutex_lock(&msblk->read_page_mutex);
+		
+		if (!(bytes = squashfs_read_data(inode->i_sb, msblk->read_page,
+					block, bsize, NULL, sblk->block_size))) {
+			ERROR("Unable to read page, block %llx, size %x\n", block,
+					bsize);
+			mutex_unlock(&msblk->read_page_mutex);
+			goto skip_read;
+		}
+	} else {
+		if ((fragment = get_cached_fragment(inode->i_sb,
+					SQUASHFS_I(inode)->
+					u.s1.fragment_start_block,
+					SQUASHFS_I(inode)->u.s1.fragment_size))
+					== NULL) {
+			ERROR("Unable to read page, block %llx, size %x\n",
+					SQUASHFS_I(inode)->
+					u.s1.fragment_start_block,
+					(int) SQUASHFS_I(inode)->
+					u.s1.fragment_size);
+			goto skip_read;
+		}
+		bytes = SQUASHFS_I(inode)->u.s1.fragment_offset +
+					(i_size_read(inode) & (sblk->block_size
+					- 1));
+		byte_offset = SQUASHFS_I(inode)->u.s1.fragment_offset;
+		data_ptr = fragment->data;
+	}
+
+	for (i = start_index; i <= end_index && byte_offset < bytes;
+					i++, byte_offset += PAGE_CACHE_SIZE) {
+		struct page *push_page;
+		int avail = (bytes - byte_offset) > PAGE_CACHE_SIZE ?
+					PAGE_CACHE_SIZE : bytes - byte_offset;
+
+		TRACE("bytes %d, i %d, byte_offset %d, available_bytes %d\n",
+					bytes, i, byte_offset, avail);
+
+		push_page = (i == page->index) ? page :
+			grab_cache_page_nowait(page->mapping, i);
+
+		if (!push_page)
+			continue;
+
+		if (PageUptodate(push_page))
+			goto skip_page;
+
+ 		pageaddr = kmap_atomic(push_page, KM_USER0);
+		memcpy(pageaddr, data_ptr + byte_offset, avail);
+		memset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);
+		kunmap_atomic(pageaddr, KM_USER0);
+		flush_dcache_page(push_page);
+		SetPageUptodate(push_page);
+skip_page:
+		unlock_page(push_page);
+		if(i != page->index)
+			page_cache_release(push_page);
+	}
+
+	if (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK
+					|| index < (i_size_read(inode) >>
+					sblk->block_log))
+		mutex_unlock(&msblk->read_page_mutex);
+	else
+		release_cached_fragment(msblk, fragment);
+
+	kfree(block_list);
+	return 0;
+
+skip_read:
+	pageaddr = kmap_atomic(page, KM_USER0);
+	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
+	kunmap_atomic(pageaddr, KM_USER0);
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	kfree(block_list);
+	return 0;
+}
+
+
+static int squashfs_readpage4K(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned char *block_list;
+	long long block;
+	unsigned int bsize, bytes = 0;
+ 	void *pageaddr;
+	
+	TRACE("Entered squashfs_readpage4K, page index %lx, start block %llx\n",
+					page->index,
+					SQUASHFS_I(inode)->start_block);
+
+	if (page->index >= ((i_size_read(inode) + PAGE_CACHE_SIZE - 1) >>
+					PAGE_CACHE_SHIFT)) {
+		block_list = NULL;
+		goto skip_read;
+	}
+
+	if (!(block_list = kmalloc(SIZE, GFP_KERNEL))) {
+		ERROR("Failed to allocate block_list\n");
+		goto skip_read;
+	}
+
+	if (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK
+					|| page->index < (i_size_read(inode) >>
+					sblk->block_log)) {
+		block = (msblk->read_blocklist)(inode, page->index, 1,
+					block_list, NULL, &bsize);
+		if(block == 0)
+			goto skip_read;
+
+		mutex_lock(&msblk->read_page_mutex);
+		bytes = squashfs_read_data(inode->i_sb, msblk->read_page, block,
+					bsize, NULL, sblk->block_size);
+		if (bytes) {
+			pageaddr = kmap_atomic(page, KM_USER0);
+			memcpy(pageaddr, msblk->read_page, bytes);
+			kunmap_atomic(pageaddr, KM_USER0);
+		} else
+			ERROR("Unable to read page, block %llx, size %x\n",
+					block, bsize);
+		mutex_unlock(&msblk->read_page_mutex);
+	} else {
+		struct squashfs_fragment_cache *fragment =
+			get_cached_fragment(inode->i_sb,
+					SQUASHFS_I(inode)->
+					u.s1.fragment_start_block,
+					SQUASHFS_I(inode)-> u.s1.fragment_size);
+		if (fragment) {
+			bytes = i_size_read(inode) & (sblk->block_size - 1);
+			pageaddr = kmap_atomic(page, KM_USER0);
+			memcpy(pageaddr, fragment->data + SQUASHFS_I(inode)->
+					u.s1.fragment_offset, bytes);
+			kunmap_atomic(pageaddr, KM_USER0);
+			release_cached_fragment(msblk, fragment);
+		} else
+			ERROR("Unable to read page, block %llx, size %x\n",
+					SQUASHFS_I(inode)->
+					u.s1.fragment_start_block, (int)
+					SQUASHFS_I(inode)-> u.s1.fragment_size);
+	}
+
+skip_read:
+	pageaddr = kmap_atomic(page, KM_USER0);
+	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
+	kunmap_atomic(pageaddr, KM_USER0);
+	flush_dcache_page(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+
+	kfree(block_list);
+	return 0;
+}
+
+
+static int get_dir_index_using_offset(struct super_block *s, long long 
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				long long f_pos)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index index;
+
+	TRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\n",
+					i_count, (unsigned int) f_pos);
+
+	f_pos =- 3;
+	if (f_pos == 0)
+		goto finish;
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX(&index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) &index,
+					index_start, index_offset,
+					sizeof(index), &index_start,
+					&index_offset);
+
+		if (index.index > f_pos)
+			break;
+
+		squashfs_get_cached_block(s, NULL, index_start, index_offset,
+					index.size + 1, &index_start,
+					&index_offset);
+
+		length = index.index;
+		*next_block = index.start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+
+finish:
+	return length + 3;
+}
+
+
+static int get_dir_index_using_name(struct super_block *s, long long
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				const char *name, int size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index *index;
+	char *str;
+
+	TRACE("Entered get_dir_index_using_name, i_count %d\n", i_count);
+
+	if (!(str = kmalloc(sizeof(struct squashfs_dir_index) +
+		(SQUASHFS_NAME_LEN + 1) * 2, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_index\n");
+		goto failure;
+	}
+
+	index = (struct squashfs_dir_index *) (str + SQUASHFS_NAME_LEN + 1);
+	strncpy(str, name, size);
+	str[size] = '\0';
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX(index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) index,
+					index_start, index_offset,
+					sizeof(struct squashfs_dir_index),
+					&index_start, &index_offset);
+
+		squashfs_get_cached_block(s, index->name, index_start,
+					index_offset, index->size + 1,
+					&index_start, &index_offset);
+
+		index->name[index->size + 1] = '\0';
+
+		if (strcmp(index->name, str) > 0)
+			break;
+
+		length = index->index;
+		*next_block = index->start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+	kfree(str);
+failure:
+	return length + 3;
+}
+
+		
+static int squashfs_readdir(struct file *file, void *dirent, filldir_t filldir)
+{
+	struct inode *i = file->f_dentry->d_inode;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+		sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+		dir_count;
+	struct squashfs_dir_header dirh;
+	struct squashfs_dir_entry *dire;
+
+	TRACE("Entered squashfs_readdir [%llx:%x]\n", next_block, next_offset);
+
+	if (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto finish;
+	}
+
+	while(file->f_pos < 3) {
+		char *name;
+		int size, i_ino;
+
+		if(file->f_pos == 0) {
+			name = ".";
+			size = 1;
+			i_ino = i->i_ino;
+		} else {
+			name = "..";
+			size = 2;
+			i_ino = SQUASHFS_I(i)->u.s2.parent_inode;
+		}
+		TRACE("Calling filldir(%x, %s, %d, %d, %d, %d)\n",
+				(unsigned int) dirent, name, size, (int)
+				file->f_pos, i_ino,
+				squashfs_filetype_table[1]);
+
+		if (filldir(dirent, name, size,
+				file->f_pos, i_ino,
+				squashfs_filetype_table[1]) < 0) {
+				TRACE("Filldir returned less than 0\n");
+				goto finish;
+		}
+		file->f_pos += size;
+	}
+
+	length = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count,
+				file->f_pos);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header sdirh;
+			
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block, next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block, next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+						next_block, next_offset,
+						dire->size + 1, &next_block,
+						&next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (file->f_pos >= length)
+				continue;
+
+			dire->name[dire->size + 1] = '\0';
+
+			TRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d, %d)\n",
+					(unsigned int) dirent, dire->name,
+					dire->size + 1, (int) file->f_pos,
+					dirh.start_block, dire->offset,
+					dirh.inode_number + dire->inode_number,
+					squashfs_filetype_table[dire->type]);
+
+			if (filldir(dirent, dire->name, dire->size + 1,
+					file->f_pos,
+					dirh.inode_number + dire->inode_number,
+					squashfs_filetype_table[dire->type])
+					< 0) {
+				TRACE("Filldir returned less than 0\n");
+				goto finish;
+			}
+			file->f_pos = length;
+		}
+	}
+
+finish:
+	kfree(dire);
+	return 0;
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	kfree(dire);
+	return 0;
+}
+
+
+static struct dentry *squashfs_lookup(struct inode *i, struct dentry *dentry,
+				struct nameidata *nd)
+{
+	const unsigned char *name = dentry->d_name.name;
+	int len = dentry->d_name.len;
+	struct inode *inode = NULL;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+				sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+				dir_count;
+	struct squashfs_dir_header dirh;
+	struct squashfs_dir_entry *dire;
+
+	TRACE("Entered squashfs_lookup [%llx:%x]\n", next_block, next_offset);
+
+	if (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto exit_lookup;
+	}
+
+	if (len > SQUASHFS_NAME_LEN)
+		goto exit_lookup;
+
+	length = get_dir_index_using_name(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count, name,
+				len);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header sdirh;
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block,next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block,next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+					next_block, next_offset, dire->size + 1,
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (name[0] < dire->name[0])
+				goto exit_lookup;
+
+			if ((len == dire->size + 1) && !strncmp(name, dire->name, len)) {
+				squashfs_inode_t ino = SQUASHFS_MKINODE(dirh.start_block,
+								dire->offset);
+
+				TRACE("calling squashfs_iget for directory "
+					"entry %s, inode %x:%x, %d\n", name,
+					dirh.start_block, dire->offset,
+					dirh.inode_number + dire->inode_number);
+
+				inode = squashfs_iget(i->i_sb, ino, dirh.inode_number + dire->inode_number);
+
+				goto exit_lookup;
+			}
+		}
+	}
+
+exit_lookup:
+	kfree(dire);
+	if (inode)
+		return d_splice_alias(inode, dentry);
+	d_add(dentry, inode);
+	return ERR_PTR(0);
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	goto exit_lookup;
+}
+
+
+static int squashfs_remount(struct super_block *s, int *flags, char *data)
+{
+	*flags |= MS_RDONLY;
+	return 0;
+}
+
+
+static void squashfs_put_super(struct super_block *s)
+{
+	int i;
+
+	if (s->s_fs_info) {
+		struct squashfs_sb_info *sbi = s->s_fs_info;
+		if (sbi->block_cache)
+			for (i = 0; i < SQUASHFS_CACHED_BLKS; i++)
+				if (sbi->block_cache[i].block !=
+							SQUASHFS_INVALID_BLK)
+					kfree(sbi->block_cache[i].data);
+		if (sbi->fragment)
+			for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++) 
+				SQUASHFS_FREE(sbi->fragment[i].data);
+		kfree(sbi->fragment);
+		kfree(sbi->block_cache);
+		kfree(sbi->read_page);
+		kfree(sbi->uid);
+		kfree(sbi->fragment_index);
+		kfree(sbi->fragment_index_2);
+		kfree(sbi->meta_index);
+		kfree(s->s_fs_info);
+		s->s_fs_info = NULL;
+	}
+}
+
+
+static int squashfs_get_sb(struct file_system_type *fs_type, int flags,
+				const char *dev_name, void *data,
+				struct vfsmount *mnt)
+{
+	return get_sb_bdev(fs_type, flags, dev_name, data, squashfs_fill_super,
+				mnt);
+}
+
+
+static void free_sqlzma(void)
+{
+	int cpu;
+	struct sqlzma *p;
+
+	for_each_online_cpu(cpu) {
+		p = per_cpu(sqlzma, cpu);
+		if (p) {
+#ifdef KeepPreemptive
+			mutex_destroy(&p->mtx);
+#endif
+			sqlzma_fin(&p->un);
+			kfree(p);
+		}
+	}
+}
+
+static int __init init_squashfs_fs(void)
+{
+	struct sqlzma *p;
+	int cpu;
+	int err = init_inodecache();
+	if (err)
+		goto out;
+
+	for_each_online_cpu(cpu) {
+		dpri("%d: %p\n", cpu, per_cpu(sqlzma, cpu));
+		err = -ENOMEM;
+		p = kmalloc(sizeof(struct sqlzma), GFP_KERNEL);
+		if (p) {
+#ifdef KeepPreemptive
+			mutex_init(&p->mtx);
+#endif
+			err = sqlzma_init(&p->un, 1, 0);
+			if (unlikely(err)) {
+				ERROR("Failed to intialize uncompress workspace\n");
+				break;
+			}
+			per_cpu(sqlzma, cpu) = p;
+			err = 0;
+		} else
+			break;
+	}
+	if (unlikely(err)) {
+		free_sqlzma();
+		goto out;
+	}
+
+	printk(KERN_INFO "squashfs: version 3.2-r2 (2007/01/15) "
+		"Phillip Lougher\n"
+		"squashfs: LZMA suppport for slax.org by jro\n");
+
+	if ((err = register_filesystem(&squashfs_fs_type))) {
+		free_sqlzma();
+		destroy_inodecache();
+	}
+
+out:
+	return err;
+}
+
+
+static void __exit exit_squashfs_fs(void)
+{
+	unregister_filesystem(&squashfs_fs_type);
+	free_sqlzma();
+	destroy_inodecache();
+}
+
+
+static struct kmem_cache * squashfs_inode_cachep;
+
+
+static struct inode *squashfs_alloc_inode(struct super_block *sb)
+{
+	struct squashfs_inode_info *ei;
+	ei = kmem_cache_alloc(squashfs_inode_cachep, GFP_KERNEL);
+	if (!ei)
+		return NULL;
+	return &ei->vfs_inode;
+}
+
+
+static void squashfs_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(squashfs_inode_cachep, SQUASHFS_I(inode));
+}
+
+
+static void init_once(void * foo, struct kmem_cache * cachep, unsigned long flags)
+{
+	struct squashfs_inode_info *ei = foo;
+
+	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) ==
+							SLAB_CTOR_CONSTRUCTOR)
+		inode_init_once(&ei->vfs_inode);
+}
+ 
+
+static int __init init_inodecache(void)
+{
+	squashfs_inode_cachep = kmem_cache_create("squashfs_inode_cache",
+	     sizeof(struct squashfs_inode_info),
+	     0, SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT,
+	     init_once, NULL);
+	if (squashfs_inode_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+
+static void destroy_inodecache(void)
+{
+	kmem_cache_destroy(squashfs_inode_cachep);
+}
+
+
+module_init(init_squashfs_fs);
+module_exit(exit_squashfs_fs);
+MODULE_DESCRIPTION("squashfs 3.2-r2, a compressed read-only filesystem, and LZMA suppport for slax.org");
+MODULE_AUTHOR("Phillip Lougher <phillip@lougher.org.uk>, and LZMA suppport for slax.org by jro");
+MODULE_LICENSE("GPL");
Index: linux-2.6.21/fs/squashfs/LzmaDecode.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/fs/squashfs/LzmaDecode.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,584 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder (optimized for Speed version)
+  
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#include <linux/LzmaDecode.h>
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
+
+#ifdef _LZMA_IN_CB
+
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) return result; \
+  BufferLim = Buffer + size; if (size == 0) return LZMA_RESULT_DATA_ERROR; }}
+
+#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+
+#else
+
+#define RC_TEST { if (Buffer == BufferLim) return LZMA_RESULT_DATA_ERROR; }
+
+#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
+ 
+#endif
+
+#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi <<= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 << numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size < LZMA_PROPERTIES_SIZE)
+    return LZMA_RESULT_DATA_ERROR;
+  prop0 = propsData[0];
+  if (prop0 >= (9 * 5 * 5))
+    return LZMA_RESULT_DATA_ERROR;
+  {
+    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
+    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
+    propsRes->lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes->lc = prop0 % 9;
+    propsRes->pb = remainder / 5;
+    propsRes->lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes->DictionarySize = 0;
+    for (i = 0; i < 4; i++)
+      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
+    if (propsRes->DictionarySize == 0)
+      propsRes->DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs->Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+
+  #ifdef _LZMA_OUT_READ
+  
+  UInt32 Range = vs->Range;
+  UInt32 Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  const Byte *Buffer = vs->Buffer;
+  const Byte *BufferLim = vs->BufferLim;
+  #else
+  const Byte *Buffer = inStream;
+  const Byte *BufferLim = inStream + inSize;
+  #endif
+  int state = vs->State;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      #ifdef _LZMA_IN_CB
+      RC_INIT;
+      #else
+      RC_INIT(inStream, inSize);
+      #endif
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+    for (i = 0; i < numProbs; i++)
+      p[i] = kBitModelTotal >> 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  RC_INIT;
+  #else
+  RC_INIT(inStream, inSize);
+  #endif
+
+  #endif /* _LZMA_OUT_READ */
+
+  while(nowPos < outSize)
+  {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+
+    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        int matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol < 0x100);
+      }
+      while (symbol < 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (Byte)symbol;
+
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            UpdateBit0(prob);
+            
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+              return LZMA_RESULT_DATA_ERROR;
+            
+            state = state < kNumLitStates ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            #endif
+
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 <<= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range >>= 1;
+              rep0 <<= 1;
+              if (Code >= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 <<= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i <<= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 > distanceLimit) 
+      #else
+      if (rep0 > nowPos)
+      #endif
+        return LZMA_RESULT_DATA_ERROR;
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+  }
+  RC_NORMALIZE;
+
+  #ifdef _LZMA_OUT_READ
+  vs->Range = Range;
+  vs->Code = Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + (UInt32)nowPos;
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs->Buffer = Buffer;
+  vs->BufferLim = BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
Index: linux-2.6.21/fs/squashfs/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/fs/squashfs/Makefile	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,9 @@
+#
+# Makefile for the linux squashfs routines.
+#
+
+obj-$(CONFIG_SQUASHFS) += squashfs.o
+squashfs-y += inode.o
+#squashfs-y += squashfs2_0.o
+squashfs-y += uncomp.o
+squashfs-y += LzmaDecode.o
Index: linux-2.6.21/fs/squashfs/squashfs2_0.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/fs/squashfs/squashfs2_0.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,742 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs2_0.c
+ */
+
+#include <linux/squashfs_fs.h>
+#include <linux/module.h>
+#include <linux/zlib.h>
+#include <linux/fs.h>
+#include <linux/squashfs_fs_sb.h>
+#include <linux/squashfs_fs_i.h>
+
+#include "squashfs.h"
+static int squashfs_readdir_2(struct file *file, void *dirent, filldir_t filldir);
+static struct dentry *squashfs_lookup_2(struct inode *, struct dentry *,
+				struct nameidata *);
+
+static struct file_operations squashfs_dir_ops_2 = {
+	.read = generic_read_dir,
+	.readdir = squashfs_readdir_2
+};
+
+static struct inode_operations squashfs_dir_inode_ops_2 = {
+	.lookup = squashfs_lookup_2
+};
+
+static unsigned char squashfs_filetype_table[] = {
+	DT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK
+};
+
+static int read_fragment_index_table_2(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	if (!(msblk->fragment_index_2 = kmalloc(SQUASHFS_FRAGMENT_INDEX_BYTES_2
+					(sblk->fragments), GFP_KERNEL))) {
+		ERROR("Failed to allocate uid/gid table\n");
+		return 0;
+	}
+   
+	if (SQUASHFS_FRAGMENT_INDEX_BYTES_2(sblk->fragments) &&
+					!squashfs_read_data(s, (char *)
+					msblk->fragment_index_2,
+					sblk->fragment_table_start,
+					SQUASHFS_FRAGMENT_INDEX_BYTES_2
+					(sblk->fragments) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, SQUASHFS_FRAGMENT_INDEX_BYTES_2(sblk->fragments))) {
+		ERROR("unable to read fragment index table\n");
+		return 0;
+	}
+
+	if (msblk->swap) {
+		int i;
+		unsigned int fragment;
+
+		for (i = 0; i < SQUASHFS_FRAGMENT_INDEXES_2(sblk->fragments);
+									i++) {
+			SQUASHFS_SWAP_FRAGMENT_INDEXES_2((&fragment),
+						&msblk->fragment_index_2[i], 1);
+			msblk->fragment_index_2[i] = fragment;
+		}
+	}
+
+	return 1;
+}
+
+
+static int get_fragment_location_2(struct super_block *s, unsigned int fragment,
+				long long *fragment_start_block,
+				unsigned int *fragment_size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start_block =
+		msblk->fragment_index_2[SQUASHFS_FRAGMENT_INDEX_2(fragment)];
+	int offset = SQUASHFS_FRAGMENT_INDEX_OFFSET_2(fragment);
+	struct squashfs_fragment_entry_2 fragment_entry;
+
+	if (msblk->swap) {
+		struct squashfs_fragment_entry_2 sfragment_entry;
+
+		if (!squashfs_get_cached_block(s, (char *) &sfragment_entry,
+					start_block, offset,
+					sizeof(sfragment_entry), &start_block,
+					&offset))
+			goto out;
+		SQUASHFS_SWAP_FRAGMENT_ENTRY_2(&fragment_entry, &sfragment_entry);
+	} else
+		if (!squashfs_get_cached_block(s, (char *) &fragment_entry,
+					start_block, offset,
+					sizeof(fragment_entry), &start_block,
+					&offset))
+			goto out;
+
+	*fragment_start_block = fragment_entry.start_block;
+	*fragment_size = fragment_entry.size;
+
+	return 1;
+
+out:
+	return 0;
+}
+
+
+static void squashfs_new_inode(struct squashfs_sb_info *msblk, struct inode *i,
+		struct squashfs_base_inode_header_2 *inodeb, unsigned int ino)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	i->i_ino = ino;
+	i->i_mtime.tv_sec = sblk->mkfs_time;
+	i->i_atime.tv_sec = sblk->mkfs_time;
+	i->i_ctime.tv_sec = sblk->mkfs_time;
+	i->i_uid = msblk->uid[inodeb->uid];
+	i->i_mode = inodeb->mode;
+	i->i_nlink = 1;
+	i->i_size = 0;
+	if (inodeb->guid == SQUASHFS_GUIDS)
+		i->i_gid = i->i_uid;
+	else
+		i->i_gid = msblk->guid[inodeb->guid];
+}
+
+
+static int squashfs_read_inode_2(struct inode *i, squashfs_inode_t inode)
+{
+	struct super_block *s = i->i_sb;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned int block = SQUASHFS_INODE_BLK(inode) +
+		sblk->inode_table_start;
+	unsigned int offset = SQUASHFS_INODE_OFFSET(inode);
+	unsigned int ino = i->i_ino;
+	long long next_block;
+	unsigned int next_offset;
+	union squashfs_inode_header_2 id, sid;
+	struct squashfs_base_inode_header_2 *inodeb = &id.base,
+					  *sinodeb = &sid.base;
+
+	TRACE("Entered squashfs_iget\n");
+
+	if (msblk->swap) {
+		if (!squashfs_get_cached_block(s, (char *) sinodeb, block,
+					offset, sizeof(*sinodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+		SQUASHFS_SWAP_BASE_INODE_HEADER_2(inodeb, sinodeb,
+					sizeof(*sinodeb));
+	} else
+		if (!squashfs_get_cached_block(s, (char *) inodeb, block,
+					offset, sizeof(*inodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+
+	squashfs_new_inode(msblk, i, inodeb, ino);
+
+	switch(inodeb->inode_type) {
+		case SQUASHFS_FILE_TYPE: {
+			struct squashfs_reg_inode_header_2 *inodep = &id.reg;
+			struct squashfs_reg_inode_header_2 *sinodep = &sid.reg;
+			long long frag_blk;
+			unsigned int frag_size = 0;
+				
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_REG_INODE_HEADER_2(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG &&
+					!get_fragment_location_2(s,
+					inodep->fragment, &frag_blk, &frag_size))
+				goto failed_read;
+				
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			if (sblk->block_size > 4096)
+				i->i_data.a_ops = &squashfs_aops;
+			else
+				i->i_data.a_ops = &squashfs_aops_4K;
+
+			TRACE("File inode %x:%x, start_block %x, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_DIR_TYPE: {
+			struct squashfs_dir_inode_header_2 *inodep = &id.dir;
+			struct squashfs_dir_inode_header_2 *sinodep = &sid.dir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DIR_INODE_HEADER_2(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops_2;
+			i->i_fop = &squashfs_dir_ops_2;
+			i->i_mode |= S_IFDIR;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = 0;
+			SQUASHFS_I(i)->u.s2.parent_inode = 0;
+
+			TRACE("Directory inode %x:%x, start_block %x, offset "
+					"%x\n", SQUASHFS_INODE_BLK(inode),
+					offset, inodep->start_block,
+					inodep->offset);
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			struct squashfs_ldir_inode_header_2 *inodep = &id.ldir;
+			struct squashfs_ldir_inode_header_2 *sinodep = &sid.ldir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LDIR_INODE_HEADER_2(inodep,
+						sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops_2;
+			i->i_fop = &squashfs_dir_ops_2;
+			i->i_mode |= S_IFDIR;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_start = next_block;
+			SQUASHFS_I(i)->u.s2.directory_index_offset =
+								next_offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count =
+								inodep->i_count;
+			SQUASHFS_I(i)->u.s2.parent_inode = 0;
+
+			TRACE("Long directory inode %x:%x, start_block %x, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, inodep->offset);
+			break;
+		}
+		case SQUASHFS_SYMLINK_TYPE: {
+			struct squashfs_symlink_inode_header_2 *inodep =
+								&id.symlink;
+			struct squashfs_symlink_inode_header_2 *sinodep =
+								&sid.symlink;
+	
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER_2(inodep,
+								sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_size = inodep->symlink_size;
+			i->i_op = &page_symlink_inode_operations;
+			i->i_data.a_ops = &squashfs_symlink_aops;
+			i->i_mode |= S_IFLNK;
+			SQUASHFS_I(i)->start_block = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+
+			TRACE("Symbolic link inode %x:%x, start_block %llx, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					next_block, next_offset);
+			break;
+		 }
+		 case SQUASHFS_BLKDEV_TYPE:
+		 case SQUASHFS_CHRDEV_TYPE: {
+			struct squashfs_dev_inode_header_2 *inodep = &id.dev;
+			struct squashfs_dev_inode_header_2 *sinodep = &sid.dev;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DEV_INODE_HEADER_2(inodep, sinodep);
+			} else	
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_mode |= (inodeb->inode_type ==
+					SQUASHFS_CHRDEV_TYPE) ?  S_IFCHR :
+					S_IFBLK;
+			init_special_inode(i, i->i_mode,
+					old_decode_dev(inodep->rdev));
+
+			TRACE("Device inode %x:%x, rdev %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->rdev);
+			break;
+		 }
+		 case SQUASHFS_FIFO_TYPE:
+		 case SQUASHFS_SOCKET_TYPE: {
+
+			i->i_mode |= (inodeb->inode_type == SQUASHFS_FIFO_TYPE)
+							? S_IFIFO : S_IFSOCK;
+			init_special_inode(i, i->i_mode, 0);
+			break;
+		 }
+		 default:
+			ERROR("Unknown inode type %d in squashfs_iget!\n",
+					inodeb->inode_type);
+			goto failed_read1;
+	}
+	
+	return 1;
+
+failed_read:
+	ERROR("Unable to read inode [%x:%x]\n", block, offset);
+
+failed_read1:
+	return 0;
+}
+
+
+static int get_dir_index_using_offset(struct super_block *s, long long 
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				long long f_pos)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index_2 index;
+
+	TRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\n",
+					i_count, (unsigned int) f_pos);
+
+	if (f_pos == 0)
+		goto finish;
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index_2 sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX_2(&index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) &index,
+					index_start, index_offset,
+					sizeof(index), &index_start,
+					&index_offset);
+
+		if (index.index > f_pos)
+			break;
+
+		squashfs_get_cached_block(s, NULL, index_start, index_offset,
+					index.size + 1, &index_start,
+					&index_offset);
+
+		length = index.index;
+		*next_block = index.start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+
+finish:
+	return length;
+}
+
+
+static int get_dir_index_using_name(struct super_block *s, long long
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				const char *name, int size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index_2 *index;
+	char *str;
+
+	TRACE("Entered get_dir_index_using_name, i_count %d\n", i_count);
+
+	if (!(str = kmalloc(sizeof(struct squashfs_dir_index) +
+		(SQUASHFS_NAME_LEN + 1) * 2, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_index\n");
+		goto failure;
+	}
+
+	index = (struct squashfs_dir_index_2 *) (str + SQUASHFS_NAME_LEN + 1);
+	strncpy(str, name, size);
+	str[size] = '\0';
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index_2 sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX_2(index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) index,
+					index_start, index_offset,
+					sizeof(struct squashfs_dir_index_2),
+					&index_start, &index_offset);
+
+		squashfs_get_cached_block(s, index->name, index_start,
+					index_offset, index->size + 1,
+					&index_start, &index_offset);
+
+		index->name[index->size + 1] = '\0';
+
+		if (strcmp(index->name, str) > 0)
+			break;
+
+		length = index->index;
+		*next_block = index->start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+	kfree(str);
+failure:
+	return length;
+}
+
+		
+static int squashfs_readdir_2(struct file *file, void *dirent, filldir_t filldir)
+{
+	struct inode *i = file->f_dentry->d_inode;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+		sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+		dir_count;
+	struct squashfs_dir_header_2 dirh;
+	struct squashfs_dir_entry_2 *dire;
+
+	TRACE("Entered squashfs_readdir_2 [%llx:%x]\n", next_block, next_offset);
+
+	if (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto finish;
+	}
+
+	length = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count,
+				file->f_pos);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header_2 sdirh;
+			
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry_2 sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block, next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block, next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+						next_block, next_offset,
+						dire->size + 1, &next_block,
+						&next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (file->f_pos >= length)
+				continue;
+
+			dire->name[dire->size + 1] = '\0';
+
+			TRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d)\n",
+					(unsigned int) dirent, dire->name,
+					dire->size + 1, (int) file->f_pos,
+					dirh.start_block, dire->offset,
+					squashfs_filetype_table[dire->type]);
+
+			if (filldir(dirent, dire->name, dire->size + 1,
+					file->f_pos, SQUASHFS_MK_VFS_INODE(
+					dirh.start_block, dire->offset),
+					squashfs_filetype_table[dire->type])
+					< 0) {
+				TRACE("Filldir returned less than 0\n");
+				goto finish;
+			}
+			file->f_pos = length;
+		}
+	}
+
+finish:
+	kfree(dire);
+	return 0;
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	kfree(dire);
+	return 0;
+}
+
+
+static struct dentry *squashfs_lookup_2(struct inode *i, struct dentry *dentry,
+				struct nameidata *nd)
+{
+	const unsigned char *name = dentry->d_name.name;
+	int len = dentry->d_name.len;
+	struct inode *inode = NULL;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+				sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+				dir_count;
+	struct squashfs_dir_header_2 dirh;
+	struct squashfs_dir_entry_2 *dire;
+	int sorted = sblk->s_major == 2 && sblk->s_minor >= 1;
+
+	TRACE("Entered squashfs_lookup_2 [%llx:%x]\n", next_block, next_offset);
+
+	if (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto exit_loop;
+	}
+
+	if (len > SQUASHFS_NAME_LEN)
+		goto exit_loop;
+
+	length = get_dir_index_using_name(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count, name,
+				len);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header_2 sdirh;
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry_2 sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block,next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block,next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+					next_block, next_offset, dire->size + 1,
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (sorted && name[0] < dire->name[0])
+				goto exit_loop;
+
+			if ((len == dire->size + 1) && !strncmp(name,
+						dire->name, len)) {
+				squashfs_inode_t ino =
+					SQUASHFS_MKINODE(dirh.start_block,
+					dire->offset);
+				unsigned int inode_number = SQUASHFS_MK_VFS_INODE(dirh.start_block,
+					dire->offset);
+
+				TRACE("calling squashfs_iget for directory "
+					"entry %s, inode %x:%x, %lld\n", name,
+					dirh.start_block, dire->offset, ino);
+
+				inode = squashfs_iget(i->i_sb, ino, inode_number);
+
+				goto exit_loop;
+			}
+		}
+	}
+
+exit_loop:
+	kfree(dire);
+	d_add(dentry, inode);
+	return ERR_PTR(0);
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	goto exit_loop;
+}
+
+
+int squashfs_2_0_supported(struct squashfs_sb_info *msblk)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	msblk->read_inode = squashfs_read_inode_2;
+	msblk->read_fragment_index_table = read_fragment_index_table_2;
+
+	sblk->bytes_used = sblk->bytes_used_2;
+	sblk->uid_start = sblk->uid_start_2;
+	sblk->guid_start = sblk->guid_start_2;
+	sblk->inode_table_start = sblk->inode_table_start_2;
+	sblk->directory_table_start = sblk->directory_table_start_2;
+	sblk->fragment_table_start = sblk->fragment_table_start_2;
+
+	return 1;
+}
Index: linux-2.6.21/fs/squashfs/squashfs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/fs/squashfs/squashfs.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,91 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs.h
+ */
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+#undef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+#endif
+
+#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+#undef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+#endif
+
+#ifdef SQUASHFS_TRACE
+#define TRACE(s, args...)	printk(KERN_NOTICE "SQUASHFS: "s, ## args)
+#else
+#define TRACE(s, args...)	{}
+#endif
+
+#define ERROR(s, args...)	printk(KERN_ERR "SQUASHFS error: "s, ## args)
+
+#define SERROR(s, args...)	do { \
+				if (!silent) \
+				printk(KERN_ERR "SQUASHFS error: "s, ## args);\
+				} while(0)
+
+#define WARNING(s, args...)	printk(KERN_WARNING "SQUASHFS: "s, ## args)
+
+static inline struct squashfs_inode_info *SQUASHFS_I(struct inode *inode)
+{
+	return list_entry(inode, struct squashfs_inode_info, vfs_inode);
+}
+
+#if defined(CONFIG_SQUASHFS_1_0_COMPATIBILITY ) || defined(CONFIG_SQUASHFS_2_0_COMPATIBILITY)
+#define SQSH_EXTERN
+extern unsigned int squashfs_read_data(struct super_block *s, char *buffer,
+				long long index, unsigned int length,
+				long long *next_index, int srclength);
+extern int squashfs_get_cached_block(struct super_block *s, char *buffer,
+				long long block, unsigned int offset,
+				int length, long long *next_block,
+				unsigned int *next_offset);
+extern void release_cached_fragment(struct squashfs_sb_info *msblk, struct
+					squashfs_fragment_cache *fragment);
+extern struct squashfs_fragment_cache *get_cached_fragment(struct super_block
+					*s, long long start_block,
+					int length);
+extern struct inode *squashfs_iget(struct super_block *s, squashfs_inode_t inode, unsigned int inode_number);
+extern const struct address_space_operations squashfs_symlink_aops;
+extern const struct address_space_operations squashfs_aops;
+extern const struct address_space_operations squashfs_aops_4K;
+extern struct inode_operations squashfs_dir_inode_ops;
+#else
+#define SQSH_EXTERN static
+#endif
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+extern int squashfs_1_0_supported(struct squashfs_sb_info *msblk);
+#else
+static inline int squashfs_1_0_supported(struct squashfs_sb_info *msblk)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+extern int squashfs_2_0_supported(struct squashfs_sb_info *msblk);
+#else
+static inline int squashfs_2_0_supported(struct squashfs_sb_info *msblk)
+{
+	return 0;
+}
+#endif
Index: linux-2.6.21/fs/squashfs/uncomp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/fs/squashfs/uncomp.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2006, 2007 Junjiro Okajima
+ * Copyright (C) 2006, 2007 Tomas Matejicek, slax.org
+ *
+ * LICENSE follows the described one in lzma.txt.
+ */
+
+/* $Id: uncomp.c,v 1.1 2007-06-05 09:34:05 steven Exp $ */
+
+/* extract some parts from lzma443/C/7zip/Compress/LZMA_C/LzmaTest.c */
+
+#ifndef __KERNEL__
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <assert.h>
+#include <pthread.h>
+#define unlikely(x)		__builtin_expect(!!(x), 0)
+#define BUG_ON(x)		assert(!(x))
+/* sqlzma buffers are always larger than a page. true? */
+#define kmalloc(sz,gfp)		malloc(sz)
+#define kfree(p)		free(p)
+#define zlib_inflate(s, f)	inflate(s, f)
+#define zlib_inflateInit(s)	inflateInit(s)
+#define zlib_inflateReset(s)	inflateReset(s)
+#define zlib_inflateEnd(s)	inflateEnd(s)
+#else
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#ifndef WARN_ON_ONCE
+#define WARN_ON_ONCE(b)	WARN_ON(b)
+#endif
+#endif /* __KERNEL__ */
+
+#include <linux/sqlzma.h>
+#include <linux/LzmaDecode.h>
+
+static int LzmaUncompress(struct sqlzma_un *un)
+{
+	int err, i, ret;
+	SizeT outSize, inProcessed, outProcessed, srclen;
+	/* it's about 24-80 bytes structure, if int is 32-bit */
+	CLzmaDecoderState state;
+	unsigned char *dst, *src, a[8];
+	struct sized_buf *sbuf;
+
+	/* Decode LZMA properties and allocate memory */
+	err = -EINVAL;
+	src = un->un_cmbuf;
+	ret = LzmaDecodeProperties(&state.Properties, src, LZMA_PROPERTIES_SIZE);
+	src += LZMA_PROPERTIES_SIZE;
+	if (unlikely(ret != LZMA_RESULT_OK))
+		goto out;
+	i = LzmaGetNumProbs(&state.Properties);
+	if (unlikely(i <= 0))
+		i = 1;
+	i *= sizeof(CProb);
+	sbuf = un->un_a + SQUN_PROB;
+	if (unlikely(sbuf->sz < i)) {
+		if (sbuf->buf && sbuf->buf != un->un_prob)
+			kfree(sbuf->buf);
+#ifdef __KERNEL__
+		printk("%s:%d: %d --> %d\n", __func__, __LINE__, sbuf->sz, i);
+#else
+		printf("%d --> %d\n", sbuf->sz, i);
+#endif
+		err = -ENOMEM;
+		sbuf->sz = 0;
+		sbuf->buf = kmalloc(i, GFP_ATOMIC);
+		if (unlikely(!sbuf->buf))
+			goto out;
+		sbuf->sz = i;
+	}
+	state.Probs = (void*)sbuf->buf;
+
+	/* Read uncompressed size */
+	memcpy(a, src, sizeof(a));
+	src += sizeof(a);
+	outSize = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24);
+
+	err = -EINVAL;
+	dst = un->un_resbuf;
+	if (unlikely(!dst || outSize > un->un_reslen))
+		goto out;
+	un->un_reslen = outSize;
+	srclen = un->un_cmlen - (src - un->un_cmbuf);
+
+	/* Decompress */
+	err = LzmaDecode(&state, src, srclen, &inProcessed, dst, outSize,
+			 &outProcessed);
+	if (err)
+		err = -EINVAL;
+
+ out:
+#ifndef __KERNEL__
+	if (err)
+		fprintf(stderr, "err %d\n", err);
+#endif
+	return err;
+}
+
+int sqlzma_un(struct sqlzma_un *un, struct sized_buf *src,
+	      struct sized_buf *dst)
+{
+	int err, by_lzma = 0;
+	if (un->un_lzma && is_lzma(*src->buf)) {
+		by_lzma = 1;
+		un->un_cmbuf = src->buf;
+		un->un_cmlen = src->sz;
+		un->un_resbuf = dst->buf;
+		un->un_reslen = dst->sz;
+
+		/* this library is thread-safe */
+		err = LzmaUncompress(un);
+		goto out;
+	}
+
+	err = zlib_inflateReset(&un->un_stream);
+	if (unlikely(err != Z_OK))
+		goto out;
+	un->un_stream.next_in = src->buf;
+	un->un_stream.avail_in = src->sz;
+	un->un_stream.next_out = dst->buf;
+	un->un_stream.avail_out = dst->sz;
+	err = zlib_inflate(&un->un_stream, Z_FINISH);
+	if (err == Z_STREAM_END)
+		err = 0;
+
+ out:
+	if (err) {
+#ifdef __KERNEL__
+		WARN_ON_ONCE(1);
+#else
+		char a[64] = "ZLIB ";
+		if (by_lzma) {
+			strcpy(a, "LZMA ");
+#ifdef _REENTRANT
+			strerror_r(err, a + 5, sizeof(a) - 5);
+#else
+			strncat(a, strerror(err), sizeof(a) - 5);
+#endif
+		} else
+			strncat(a, zError(err), sizeof(a) - 5);
+		fprintf(stderr, "%s: %.*s\n", __func__, sizeof(a), a);
+#endif
+	}
+	return err;
+}
+
+int sqlzma_init(struct sqlzma_un *un, int do_lzma, unsigned int res_sz)
+{
+	int err;
+
+	err = -ENOMEM;
+	un->un_lzma = do_lzma;
+	memset(un->un_a, 0, sizeof(un->un_a));
+	un->un_a[SQUN_PROB].buf = un->un_prob;
+	un->un_a[SQUN_PROB].sz = sizeof(un->un_prob);
+	if (res_sz) {
+		un->un_a[SQUN_RESULT].buf = kmalloc(res_sz, GFP_KERNEL);
+		if (unlikely(!un->un_a[SQUN_RESULT].buf))
+			return err;
+		un->un_a[SQUN_RESULT].sz = res_sz;
+	}
+
+	un->un_stream.next_in = NULL;
+	un->un_stream.avail_in = 0;
+#ifdef __KERNEL__
+	un->un_stream.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);
+	if (unlikely(!un->un_stream.workspace))
+		return err;
+#else
+	un->un_stream.opaque = NULL;
+	un->un_stream.zalloc = Z_NULL;
+	un->un_stream.zfree = Z_NULL;
+#endif
+	err = zlib_inflateInit(&un->un_stream);
+	if (unlikely(err == Z_MEM_ERROR))
+		return -ENOMEM;
+	BUG_ON(err);
+	return err;
+}
+
+void sqlzma_fin(struct sqlzma_un *un)
+{
+	int i;
+	for (i = 0; i < SQUN_LAST; i++)
+		if (un->un_a[i].buf && un->un_a[i].buf != un->un_prob)
+			kfree(un->un_a[i].buf);
+	BUG_ON(zlib_inflateEnd(&un->un_stream) != Z_OK);
+}
+
+#ifdef __KERNEL__
+EXPORT_SYMBOL(sqlzma_un);
+EXPORT_SYMBOL(sqlzma_init);
+EXPORT_SYMBOL(sqlzma_fin);
+
+#if 0
+static int __init sqlzma_init(void)
+{
+	return 0;
+}
+
+static void __exit sqlzma_exit(void)
+{
+}
+
+module_init(sqlzma_init);
+module_exit(sqlzma_exit);
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Junjiro Okajima <hooanon05 at yahoo dot co dot jp>");
+MODULE_VERSION("$Id: uncomp.c,v 1.1 2007-06-05 09:34:05 steven Exp $");
+MODULE_DESCRIPTION("LZMA uncompress for squashfs. "
+		   "Some functions for squashfs to support LZMA and "
+		   "a tiny wrapper for LzmaDecode.c in LZMA SDK from www.7-zip.org.");
+#endif
Index: linux-2.6.21/fs/super.c
===================================================================
--- linux-2.6.21.orig/fs/super.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/fs/super.c	2009-11-30 12:44:56.000000000 +0100
@@ -618,6 +618,7 @@
 	return 0;
 }
 
+#ifdef CONFIG_PDFLUSH
 static void do_emergency_remount(unsigned long foo)
 {
 	struct super_block *sb;
@@ -643,10 +644,13 @@
 	spin_unlock(&sb_lock);
 	printk("Emergency Remount complete\n");
 }
+#endif
 
 void emergency_remount(void)
 {
+#ifdef CONFIG_PDFLUSH
 	pdflush_operation(do_emergency_remount, 0);
+#endif
 }
 
 /*
Index: linux-2.6.21/fs/sync.c
===================================================================
--- linux-2.6.21.orig/fs/sync.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/fs/sync.c	2009-11-30 12:44:56.000000000 +0100
@@ -44,7 +44,9 @@
 
 void emergency_sync(void)
 {
+#ifdef CONFIG_PDFLUSH
 	pdflush_operation(do_sync, 0);
+#endif
 }
 
 /*
Index: linux-2.6.21/include/asm-mips/addrspace.h
===================================================================
--- linux-2.6.21.orig/include/asm-mips/addrspace.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/asm-mips/addrspace.h	2009-11-30 12:44:56.000000000 +0100
@@ -133,6 +133,7 @@
     || defined (CONFIG_CPU_R4X00)					\
     || defined (CONFIG_CPU_R5000)					\
     || defined (CONFIG_CPU_RM7000)					\
+    || defined (CONFIG_CPU_RM9000)					\
     || defined (CONFIG_CPU_NEVADA)					\
     || defined (CONFIG_CPU_TX49XX)					\
     || defined (CONFIG_CPU_MIPS64)
Index: linux-2.6.21/include/asm-mips/bootinfo.h
===================================================================
--- linux-2.6.21.orig/include/asm-mips/bootinfo.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/asm-mips/bootinfo.h	2009-11-30 12:44:56.000000000 +0100
@@ -208,6 +208,13 @@
 #define  MACH_TITAN_EXCITE	2	/* Basler eXcite		*/
 
 /*
+ * Valid machtype for group Ralink
+ */
+#define MACH_GROUP_RT2880    23 	/* Ralink AP SoC */
+#define MACH_RALINK_ROUTER   0 		/* Ralink Wireless ROUTER*/
+
+
+/*
  * Valid machtype for group NEC EMMA2RH
  */
 #define MACH_GROUP_NEC_EMMA2RH 25	/* NEC EMMA2RH (was 23)		*/
Index: linux-2.6.21/include/asm-mips/mach-generic/ide.h
===================================================================
--- linux-2.6.21.orig/include/asm-mips/mach-generic/ide.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/asm-mips/mach-generic/ide.h	2009-11-30 12:44:56.000000000 +0100
@@ -29,17 +29,12 @@
 
 #define IDE_ARCH_OBSOLETE_DEFAULTS
 
+extern int mips_system_has_legacy_ide;
+
 static __inline__ int ide_probe_legacy(void)
 {
 #ifdef CONFIG_PCI
-	struct pci_dev *dev;
-	if ((dev = pci_get_class(PCI_CLASS_BRIDGE_EISA << 8, NULL)) != NULL ||
-	    (dev = pci_get_class(PCI_CLASS_BRIDGE_ISA << 8, NULL)) != NULL) {
-		pci_dev_put(dev);
-
-		return 1;
-	}
-	return 0;
+	return mips_system_has_legacy_ide;
 #elif defined(CONFIG_EISA) || defined(CONFIG_ISA)
 	return 1;
 #else
Index: linux-2.6.21/include/asm-mips/mach-generic/kernel-entry-init.h
===================================================================
--- linux-2.6.21.orig/include/asm-mips/mach-generic/kernel-entry-init.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/asm-mips/mach-generic/kernel-entry-init.h	2009-11-30 12:44:56.000000000 +0100
@@ -13,6 +13,97 @@
  * arch/mips/mach-xxx/kernel-entry-init.h when necessary.
  */
 .macro	kernel_entry_setup
+#if 1
+/* FIXME */
+
+	# Initialize the register file
+	# should not be required with good software practices
+	or	$1,$0, $0
+	or	$2,$0, $0
+	or	$3,$0, $0
+	or	$4,$0, $0
+	or	$5,$0, $0
+	or	$6,$0, $0
+	or	$7,$0, $0
+	or	$8,$0, $0
+	or	$9,$0, $0
+	or	$10,$0, $0
+	or	$11,$0, $0
+	or	$12,$0, $0
+	or	$13,$0, $0
+	or	$14,$0, $0
+	or	$15,$0, $0
+	or	$16,$0, $0
+	or	$17,$0, $0
+	or	$18,$0, $0
+	or	$19,$0, $0
+	or	$20,$0, $0
+	or	$21,$0, $0
+	or	$22,$0, $0
+	or	$23,$0, $0
+	or	$24,$0, $0
+	or	$25,$0, $0
+	or	$26,$0, $0
+	or	$27,$0, $0
+	or	$28,$0, $0
+	or	$29,$0, $0
+	or	$30,$0, $0
+	or	$31,$0, $0
+
+# Initialize Misc. Cop0 state	
+
+	# Read status register
+	mfc0	$10, $12
+	# Set up Status register:
+	# Disable Coprocessor Usable bits
+	# Turn off Reduce Power bit
+	# Turn off reverse endian
+	# Turn off BEV (use normal exception vectors)
+	# Clear TS, SR, NMI bits
+	# Clear Interrupt masks
+	# Clear User Mode
+	# Clear ERL
+	# Set EXL
+	# Clear Interrupt Enable
+	li	$11, 0x0000ff02
+	mtc0	$11, $12
+
+
+	# Disable watch exceptions
+	mtc0	$0, $18
+
+	# Clear Watch Status bits
+	li	$11, 0x3
+	mtc0	$11, $19
+
+	# Clear WP bit to avoid watch exception upon user code entry
+	# Clear IV bit - Interrupts go to general exception vector
+	# Clear software interrupts
+	mtc0	$0, $13
+
+	# Set KSeg0 to cacheable
+	# Config.K0
+	mfc0	$10, $16
+	li	$11, 0x7
+	not	$11
+	and	$10, $11
+	or	$10, 0x3
+	mtc0	$10, $16
+
+	# Clear Count register
+	mtc0	$0, $9
+
+	# Set compare to -1 to delay 1st count=compare
+	# Also, clears timer interrupt
+	li	$10, -1
+	mtc0	$10, $11
+
+
+	# Cache initialization routine
+	# Long and needed on HW 
+	# Can be skipped if using magic simulation cache flush
+	
+#endif
 .endm
 
 /*
Index: linux-2.6.21/include/asm-mips/rt2880/eureka_ep430.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/asm-mips/rt2880/eureka_ep430.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,75 @@
+#ifndef _EUREKA_EP430_H
+#define _EUREKA_EP430_H
+
+
+#include <asm/addrspace.h>		/* for KSEG1ADDR() */
+#include <asm/byteorder.h>		/* for cpu_to_le32() */
+#include <asm/rt2880/rt_mmap.h>
+
+#define EUREKA_EP430_BASE       			RALINK_PCI_BASE
+#define EUREKA_EP430_PCI_CONFIG_ADDR 		    	0x20
+#define EUREKA_EP430_PCI_CONFIG_DATA_VIRTUAL_REG   	0x24
+
+/*
+ * Because of an error/peculiarity in the Galileo chip, we need to swap the
+ * bytes when running bigendian.
+ */
+
+#define MV_WRITE(ofs, data)  \
+        *(volatile u32 *)(EUREKA_EP430_BASE+(ofs)) = cpu_to_le32(data)
+#define MV_READ(ofs, data)   \
+        *(data) = le32_to_cpu(*(volatile u32 *)(EUREKA_EP430_BASE+(ofs)))
+#define MV_READ_DATA(ofs)    \
+        le32_to_cpu(*(volatile u32 *)(EUREKA_EP430_BASE+(ofs)))
+
+#define MV_WRITE_16(ofs, data)  \
+        *(volatile u16 *)(EUREKA_EP430_BASE+(ofs)) = cpu_to_le16(data)
+#define MV_READ_16(ofs, data)   \
+        *(data) = le16_to_cpu(*(volatile u16 *)(EUREKA_EP430_BASE+(ofs)))
+
+#define MV_WRITE_8(ofs, data)  \
+        *(volatile u8 *)(EUREKA_EP430_BASE+(ofs)) = data
+#define MV_READ_8(ofs, data)   \
+        *(data) = *(volatile u8 *)(EUREKA_EP430_BASE+(ofs))
+
+#define MV_SET_REG_BITS(ofs,bits) \
+	(*((volatile u32 *)(EUREKA_EP430_BASE+(ofs)))) |= ((u32)cpu_to_le32(bits))
+#define MV_RESET_REG_BITS(ofs,bits) \
+	(*((volatile u32 *)(EUREKA_EP430_BASE+(ofs)))) &= ~((u32)cpu_to_le32(bits))
+
+#define RALINK_PCI_BAR0SETUP_ADDR *(volatile u32 *)(EUREKA_EP430_BASE + 0x0010)
+#define RALINK_PCI_BAR1SETUP_ADDR *(volatile u32 *)(EUREKA_EP430_BASE + 0x0014)
+
+#define RALINK_PCI_IMBASEBAR0_ADDR *(volatile u32 *)(EUREKA_EP430_BASE + 0x0018)
+#define RALINK_PCI_IMBASEBAR1_ADDR *(volatile u32 *)(EUREKA_EP430_BASE + 0x001C)
+#define RT2880_PCI_MEMBASE (*(volatile unsigned long *)(EUREKA_EP430_BASE + 0x0028))
+#define RT2880_PCI_IOBASE (*(volatile unsigned long *)(EUREKA_EP430_BASE + 0x002C))
+#define RT2880_PCI_ID (*(volatile unsigned long *)(EUREKA_EP430_BASE + 0x0030))
+#define RT2880_PCI_CLASS (*(volatile unsigned long *)(EUREKA_EP430_BASE + 0x0034))
+#define RT2880_PCI_SUBID (*(volatile unsigned long *)(EUREKA_EP430_BASE + 0x0038))
+#define RT2880_PCI_ARBCTL (*(volatile unsigned long *)(EUREKA_EP430_BASE + 0x0080))
+
+/* EUREKA EP430 PCI INIT reference define  */
+
+#define RALINK_PCI_PCICFG_ADDR *(volatile u32 *)(EUREKA_EP430_BASE + 0x0000)
+#define RALINK_PCI_PCIRAW_ADDR *(volatile u32 *)(EUREKA_EP430_BASE + 0x0004)
+#define RALINK_PCI_PCIINT_ADDR *(volatile u32 *)(EUREKA_EP430_BASE + 0x0008)
+#define RALINK_PCI_PCIMSK_ADDR *(volatile u32 *)(EUREKA_EP430_BASE + 0x000C)
+
+#define RT2880_PCI_MEMWIN(offset) (*(volatile unsigned long *)(EUREKA_EP430_BASE + 0x10000 + offset))
+#define RT2880_PCI_IOWIN(offset) (*(volatile unsigned long *)(EUREKA_EP430_BASE + 0x20000 + offset))
+
+#define RT2880_BIT(x)              ((1 << x))
+
+#define RALINK_PCI_PCIRAW_PDVDPERR RT2880_BIT(17)
+#define RALINK_PCI_PCIRAW_PDVDSERR RT2880_BIT(16)
+#define RALINK_PCI_PCIRAW_DETPERR  RT2880_BIT(13)
+#define RALINK_PCI_PCIRAW_SIGSERR  RT2880_BIT(12)
+#define RALINK_PCI_PCIRAW_RCVMABRT RT2880_BIT(11)
+#define RALINK_PCI_PCIRAW_RCVTABRT RT2880_BIT(10)
+#define RALINK_PCI_PCIRAW_SIGTABRT RT2880_BIT(9)
+#define RALINK_PCI_PCIRAW_MASDPERR RT2880_BIT(8)
+
+#define RALINK_PCI_PCIRAW_FAIL_STATUS 0x00033F00
+
+#endif
Index: linux-2.6.21/include/asm-mips/rt2880/generic.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/asm-mips/rt2880/generic.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2001 Palmchip Corporation.  All rights reserved.
+ *
+ * This program is free software; you can distribute it and/or modify it
+ * under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Defines of the Palmchip boards specific address-MAP, registers, etc.
+ */
+#ifndef __ASM_SURFBOARD_GENERIC_H
+#define __ASM_SURFBOARD_GENERIC_H
+
+#include <asm/addrspace.h>
+#include <asm/byteorder.h>
+#include <asm/rt2880/rt_mmap.h>
+
+/*
+ * Reset register.
+ */
+#define SOFTRES_REG       (KSEG1ADDR(RALINK_SYSCTL_BASE+0x34))
+#define GORESET           (0x1)
+
+/*
+ * Power-off register
+ */
+#define POWER_DIR_REG     (KSEG1ADDR(RALINK_PIO_BASE+0x24))
+#define POWER_DIR_OUTPUT  (0x80)	/* GPIO 7 */
+#define POWER_POL_REG     (KSEG1ADDR(RALINK_PIO_BASE+0x28))
+#define POWEROFF_REG      (KSEG1ADDR(RALINK_PIO_BASE+0x20))
+#define POWEROFF          (0x0)		/* drive low */
+
+
+#endif  /* __ASM_SURFBOARD_GENERIC_H */
Index: linux-2.6.21/include/asm-mips/rt2880/lm.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/asm-mips/rt2880/lm.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,32 @@
+#include <linux/version.h>
+
+struct lm_device {
+	struct device		dev;
+	struct resource		resource;
+	unsigned int		irq;
+	unsigned int		id;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+	void			*lm_drvdata;
+#endif
+};
+
+struct lm_driver {
+	struct device_driver	drv;
+	int			(*probe)(struct lm_device *);
+	void			(*remove)(struct lm_device *);
+	int			(*suspend)(struct lm_device *, u32);
+	int			(*resume)(struct lm_device *);
+};
+
+int lm_driver_register(struct lm_driver *drv);
+void lm_driver_unregister(struct lm_driver *drv);
+
+int lm_device_register(struct lm_device *dev);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+# define lm_get_drvdata(lm)	((lm)->lm_drvdata)
+# define lm_set_drvdata(lm,d)	do { (lm)->lm_drvdata = (d); } while (0)
+#else
+# define lm_get_drvdata(lm)	dev_get_drvdata(&(lm)->dev)
+# define lm_set_drvdata(lm,d)	dev_set_drvdata(&(lm)->dev, d)
+#endif
Index: linux-2.6.21/include/asm-mips/rt2880/prom.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/asm-mips/rt2880/prom.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,50 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * MIPS boards bootprom interface for the Linux kernel.
+ *
+ */
+
+#ifndef _MIPS_PROM_H
+#define _MIPS_PROM_H
+
+extern char *prom_getcmdline(void);
+extern char *prom_getenv(char *name);
+extern void setup_prom_printf(int tty_no);
+extern void prom_setup_printf(int tty_no);
+extern void prom_printf(char *fmt, ...);
+extern void prom_init_cmdline(void);
+extern void prom_meminit(void);
+extern void prom_fixup_mem_map(unsigned long start_mem, unsigned long end_mem);
+extern void prom_free_prom_memory (void);
+extern void mips_display_message(const char *str);
+extern void mips_display_word(unsigned int num);
+extern int get_ethernet_addr(char *ethernet_addr);
+
+/* Memory descriptor management. */
+#define PROM_MAX_PMEMBLOCKS    32
+struct prom_pmemblock {
+        unsigned long base; /* Within KSEG0. */
+        unsigned int size;  /* In bytes. */
+        unsigned int type;  /* free or prom memory */
+};
+
+#endif /* !(_MIPS_PROM_H) */
Index: linux-2.6.21/include/asm-mips/rt2880/rt_mmap.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/asm-mips/rt2880/rt_mmap.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,231 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     serial port definition for Ralink RT2880 solution
+ *
+ *  Copyright 2007 Ralink Inc. (steven_liu@ralinktech.com.tw)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ */
+
+#ifndef __RALINK_MMAP__
+#define __RALINK_MMAP__
+
+#if defined (CONFIG_RALINK_RT2880_SHUTTLE)
+
+#define RALINK_SYSCTL_BASE 		0xA0300000
+#define RALINK_TIMER_BASE		0xA0300100
+#define RALINK_INTCL_BASE		0xA0300200
+#define RALINK_MEMCTRL_BASE		0xA0300300
+#define RALINK_UART_BASE		0xA0300500
+#define RALINK_PIO_BASE			0xA0300600
+#define RALINK_I2C_BASE			0xA0300900
+#define RALINK_SPI_BASE			0xA0300B00
+#define RALINK_UART_LITE_BASE		0xA0300C00
+#define RALINK_FRAME_ENGINE_BASE	0xA0310000
+#define RALINK_EMBEDD_ROM_BASE		0xA0400000
+#define RALINK_PCI_BASE			0xA0500000
+#define RALINK_11N_MAC_BASE		0xA0600000
+
+//Interrupt Controller
+#define RALINK_INTCTL_TIMER0		(1<<0)
+#define RALINK_INTCTL_WDTIMER		(1<<1)
+#define RALINK_INTCTL_UART		(1<<2)
+#define RALINK_INTCTL_PIO		(1<<3)
+#define RALINK_INTCTL_PCM		(1<<4)
+#define RALINK_INTCTL_UARTLITE		(1<<8)
+#define RALINK_INTCTL_ILL_ACCESS	(1<<23)
+
+//Reset Control Register
+#define RALINK_TIMER_RST		(1<<1)
+#define RALINK_INTC_RST			(1<<2)
+#define RALINK_MC_RST			(1<<3)
+#define RALINK_CPU_RST			(1<<4)
+#define RALINK_UART_RST			(1<<5)
+#define RALINK_PIO_RST			(1<<6)
+#define RALINK_I2C_RST			(1<<9)
+#define RALINK_SPI_RST			(1<<11)
+#define RALINK_UART2_RST		(1<<12)
+#define RALINK_PCI_RST			(1<<16)
+#define RALINK_2860_RST			(1<<17)
+#define RALINK_FE_RST			(1<<18)
+#define RALINK_PCM_RST			(1<<19)
+
+
+#elif defined (CONFIG_RALINK_RT2880_MP)
+
+#define RALINK_SYSCTL_BASE 		0xA0300000
+#define RALINK_TIMER_BASE		0xA0300100
+#define RALINK_INTCL_BASE		0xA0300200
+#define RALINK_MEMCTRL_BASE		0xA0300300
+#define RALINK_UART_BASE		0xA0300500
+#define RALINK_PIO_BASE			0xA0300600
+#define RALINK_I2C_BASE			0xA0300900
+#define RALINK_SPI_BASE			0xA0300B00
+#define RALINK_UART_LITE_BASE		0x00300C00
+#define RALINK_FRAME_ENGINE_BASE	0xA0400000
+#define RALINK_EMBEDD_ROM_BASE		0xA0410000
+#define RALINK_PCI_BASE			0xA0440000
+#define RALINK_11N_MAC_BASE		0xA0480000
+
+//Interrupt Controller
+#define RALINK_INTCTL_TIMER0		(1<<0)
+#define RALINK_INTCTL_WDTIMER		(1<<1)
+#define RALINK_INTCTL_UART		(1<<2)
+#define RALINK_INTCTL_PIO		(1<<3)
+#define RALINK_INTCTL_PCM		(1<<4)
+#define RALINK_INTCTL_UARTLITE		(1<<8)
+#define RALINK_INTCTL_ILL_ACCESS	(1<<23)
+
+//Reset Control Register
+#define RALINK_TIMER_RST		(1<<1)
+#define RALINK_INTC_RST			(1<<2)
+#define RALINK_MC_RST			(1<<3)
+#define RALINK_CPU_RST			(1<<4)
+#define RALINK_UART_RST			(1<<5)
+#define RALINK_PIO_RST			(1<<6)
+#define RALINK_I2C_RST			(1<<9)
+#define RALINK_SPI_RST			(1<<11)
+#define RALINK_UART2_RST		(1<<12)
+#define RALINK_PCI_RST			(1<<16)
+#define RALINK_2860_RST			(1<<17)
+#define RALINK_FE_RST			(1<<18)
+#define RALINK_PCM_RST			(1<<19)
+
+#elif defined (CONFIG_RALINK_RT3052) 
+
+#define RALINK_SYSCTL_BASE		0xB0000000
+#define RALINK_TIMER_BASE		0xB0000100
+#define RALINK_INTCL_BASE		0xB0000200
+#define RALINK_MEMCTRL_BASE		0xB0000300
+#define RALINK_PCM_BASE			0xB0000400
+#define RALINK_UART_BASE		0x10000500
+#define RALINK_PIO_BASE			0xB0000600
+#define RALINK_GDMA_BASE		0xB0000700
+#define RALINK_NAND_CTRL_BASE		0xB0000800
+#define RALINK_I2C_BASE			0xB0000900
+#define RALINK_I2S_BASE			0xB0000A00
+#define RALINK_SPI_BASE			0xB0000B00
+#define RALINK_UART_LITE_BASE		0x10000C00
+#define RALINK_FRAME_ENGINE_BASE	0xB0100000
+#define RALINK_ETH_SW_BASE		0xB0110000
+#define RALINK_11N_MAC_BASE		0xB0180000
+#define RALINK_USB_OTG_BASE		0x101C0000
+
+//Interrupt Controller
+#define RALINK_INTCTL_SYSCTL		(1<<0)
+#define RALINK_INTCTL_TIMER0		(1<<1)
+#define RALINK_INTCTL_WDTIMER		(1<<2)
+#define RALINK_INTCTL_ILL_ACCESS	(1<<3)
+#define RALINK_INTCTL_PCM		(1<<4)
+#define RALINK_INTCTL_UART		(1<<5)
+#define RALINK_INTCTL_PIO		(1<<6)
+#define RALINK_INTCTL_DMA		(1<<7)
+#define RALINK_INTCTL_NAND		(1<<8)
+#define RALINK_INTCTL_PC		(1<<9)
+#define RALINK_INTCTL_I2S		(1<<10)
+#define RALINK_INTCTL_UARTLITE		(1<<12)
+#define RALINK_INTCTL_ESW		(1<<17)
+#define RALINK_INTCTL_OTG		(1<<18)
+#define RALINK_INTCTL_OTG_IRQN		18
+#define RALINK_INTCTL_GLOBAL		(1<<31)
+
+//Reset Control Register
+#define RALINK_SYS_RST			(1<<0)
+#define RALINK_CPU_RST			(1<<1)
+#define RALINK_TIMER_RST		(1<<8)
+#define RALINK_INTC_RST			(1<<9)
+#define RALINK_MC_RST			(1<<10)
+#define RALINK_PCM_RST			(1<<11)
+#define RALINK_UART_RST			(1<<12)
+#define RALINK_PIO_RST			(1<<13)
+#define RALINK_DMA_RST			(1<<14)
+#define RALINK_I2C_RST			(1<<16)
+#define RALINK_I2S_RST			(1<<17)
+#define RALINK_SPI_RST			(1<<18)
+#define RALINK_UARTL_RST		(1<<19)
+#define RALINK_RT2872_RST		(1<<20)
+#define RALINK_FE_RST			(1<<21)
+#define RALINK_OTG_RST			(1<<22)
+#define RALINK_SW_RST			(1<<23)
+#define RALINK_EPHY_RST			(1<<24)
+
+#elif defined (CONFIG_RALINK_RT2883)
+
+#define RALINK_SYSCTL_BASE		0xB0000000
+#define RALINK_TIMER_BASE		0xB0000100
+#define RALINK_INTCL_BASE		0xB0000200
+#define RALINK_MEMCTRL_BASE		0xB0000300
+#define RALINK_PCM_BASE			0xB0000400
+#define RALINK_UART_BASE		0x10000500
+#define RALINK_PIO_BASE			0xB0000600
+#define RALINK_GDMA_BASE		0xB0000700
+#define RALINK_NAND_CTRL_BASE		0xB0000800
+#define RALINK_I2C_BASE			0xB0000900
+#define RALINK_I2S_BASE			0xB0000A00
+#define RALINK_SPI_BASE			0xB0000B00
+#define RALINK_UART_LITE_BASE		0x10000C00
+#define RALINK_FRAME_ENGINE_BASE	0xB0100000
+#define RALINK_PCI_EXTRESS_BASE		0xB0140000
+#define RALINK_11N_MAC_BASE		0xB0180000
+#define RALINK_USB_OTG_BASE		0x101C0000
+
+//Interrupt Controller
+#define RALINK_INTCTL_SYSCTL		(1<<0)
+#define RALINK_INTCTL_TIMER0		(1<<1)
+#define RALINK_INTCTL_WDTIMER		(1<<2)
+#define RALINK_INTCTL_ILL_ACCESS	(1<<3)
+#define RALINK_INTCTL_PCM		(1<<4)
+#define RALINK_INTCTL_UART		(1<<5)
+#define RALINK_INTCTL_PIO		(1<<6)
+#define RALINK_INTCTL_DMA		(1<<7)
+#define RALINK_INTCTL_NAND		(1<<8)
+#define RALINK_INTCTL_PC		(1<<9)
+#define RALINK_INTCTL_I2S		(1<<10)
+#define RALINK_INTCTL_UARTLITE		(1<<12)
+#define RALINK_INTCTL_OTG		(1<<18)
+#define RALINK_INTCTL_OTG_IRQN		18
+#define RALINK_INTCTL_GLOBAL		(1<<31)
+
+//Reset Control Register
+#define RALINK_SYS_RST			(1<<0)
+#define RALINK_CPU_RST			(1<<1)
+#define RALINK_TIMER_RST		(1<<8)
+#define RALINK_INTC_RST			(1<<9)
+#define RALINK_MC_RST			(1<<10)
+#define RALINK_PCM_RST			(1<<11)
+#define RALINK_UART_RST			(1<<12)
+#define RALINK_PIO_RST			(1<<13)
+#define RALINK_DMA_RST			(1<<14)
+#define RALINK_I2C_RST			(1<<16)
+#define RALINK_I2S_RST			(1<<17)
+#define RALINK_SPI_RST			(1<<18)
+#define RALINK_UARTL_RST		(1<<19)
+#define RALINK_RT2863_RST		(1<<20)
+#define RALINK_FE_RST			(1<<21)
+#define RALINK_OTG_RST			(1<<22)
+#define RALINK_PCIE_RST			(1<<23)
+
+#endif
+#endif
Index: linux-2.6.21/include/asm-mips/rt2880/sizes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/asm-mips/rt2880/sizes.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size definitions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
Index: linux-2.6.21/include/asm-mips/rt2880/surfboard.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/asm-mips/rt2880/surfboard.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2001 Palmchip Corporation.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ */
+#ifndef _SURFBOARD_H
+#define _SURFBOARD_H
+
+#include <asm/addrspace.h>
+
+
+
+/*
+ * Surfboard system clock.
+ * This is the default value and maybe overidden by System Clock passed on the
+ * command line (sysclk=).
+ */
+#define SURFBOARD_SYSTEM_CLOCK		(125000000)
+
+/*
+ * Surfboard UART base baud rate = System Clock / 16.
+ * Ex. (14.7456 MHZ / 16) = 921600
+ *     (32.0000 MHZ / 16) = 2000000
+ */
+#define SURFBOARD_BAUD_DIV	(16)
+#define SURFBOARD_BASE_BAUD	(SURFBOARD_SYSTEM_CLOCK / SURFBOARD_BAUD_DIV)
+
+/*
+ * Maximum number of IDE Controllers
+ * Surfboard only has one ide (ide0), so only 2 drives are
+ * possible.  (no need to check for more hwifs.)
+ */
+//#define MAX_IDE_HWIFS		(1)	/* Surfboard/Wakeboard */
+#define MAX_IDE_HWIFS		(2)	/* Graphite board */
+
+
+#endif /* !(_SURFBOARD_H) */
Index: linux-2.6.21/include/asm-mips/rt2880/surfboardint.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/asm-mips/rt2880/surfboardint.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2001 Palmchip Corporation.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Defines for the Surfboard interrupt controller.
+ *
+ */
+#ifndef _SURFBOARDINT_H
+#define _SURFBOARDINT_H
+
+/* Number of IRQ supported on hw interrupt 0. */
+#if defined (CONFIG_RT2880_FPGA) || defined (CONFIG_RT2880_ASIC)
+#define RALINK_CPU_TIMER_IRQ 	 6	/* mips timer */
+#define SURFBOARDINT_GPIO	 7	/* GPIO */
+#define SURFBOARDINT_UART1	 8	/* UART Lite */
+#define SURFBOARDINT_UART	 9	/* UART */
+#define SURFBOARDINT_TIMER0	 10	/* timer0 */
+#else
+#define RALINK_CPU_TIMER_IRQ 	 5	/* mips timer */
+#define SURFBOARDINT_GPIO	 6	/* GPIO */
+#define SURFBOARDINT_DMA	 7	/* DMA */
+#define SURFBOARDINT_NAND	 8	/* NAND */
+#define SURFBOARDINT_PC	 	 9	/* Performance counter */
+#define SURFBOARDINT_I2S 	 10	/* I2S */
+#define SURFBOARDINT_ESW	 17	/* ESW */
+#define SURFBOARDINT_UART1	 12 	/* UART Lite */
+#define SURFBOARDINT_SYSCTL 	 32	/* SYSCTL */
+#define SURFBOARDINT_TIMER0	 33	/* timer0 */
+#define SURFBOARDINT_WDG	 34	/* watch dog */
+#define SURFBOARDINT_ILL_ACC	 35	/* illegal access */
+#define SURFBOARDINT_PCM	 36	/* PCM */
+#define SURFBOARDINT_UART	 37	/* UART */
+#endif
+
+#define SURFBOARDINT_END 	 64
+#define RT2880_INTERINT_START 	 40
+
+/* Global interrupt bit definitions */
+#define C_SURFBOARD_GLOBAL_INT	31
+#define M_SURFBOARD_GLOBAL_INT	(1 << C_SURFBOARD_GLOBAL_INT)
+
+/* added ??? */
+#define RALINK_SDRAM_ILL_ACC_ADDR  *(volatile u32 *)(RALINK_SYSCTL_BASE + 0x310)
+#define RALINK_SDRAM_ILL_ACC_TYPE  *(volatile u32 *)(RALINK_SYSCTL_BASE + 0x314)
+/* end of added, bobtseng */
+
+/*
+ * Surfboard registers are memory mapped on 32-bit aligned boundaries and
+ * only word access are allowed.
+ */
+struct surfboard_ictrl_regs {
+        volatile unsigned long irq0Status;
+        volatile unsigned long irq1Status;
+	long reserved[6];
+	volatile unsigned long intType;
+	long reserved1[3];
+	volatile unsigned long rawStatus;
+	volatile unsigned long intEnable;
+	volatile unsigned long intDisable;
+};
+
+/* bobtseng added ++, 2006.3.6. */
+#define read_32bit_cp0_register(source)                         \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+        ".set\tpush\n\t"                                        \
+        ".set\treorder\n\t"                                     \
+        "mfc0\t%0,"STR(source)"\n\t"                            \
+        ".set\tpop"                                             \
+        : "=r" (__res));                                        \
+        __res;})
+        
+#define write_32bit_cp0_register(register,value)                \
+        __asm__ __volatile__(                                   \
+        "mtc0\t%0,"STR(register)"\n\t"                          \
+        "nop"                                                   \
+        : : "r" (value));
+        
+/* bobtseng added --, 2006.3.6. */
+
+void surfboardint_init(void);
+u32 get_surfboard_sysclk(void);
+
+
+#endif /* !(_SURFBOARDINT_H) */
Index: linux-2.6.21/include/linux/ethtool.h
===================================================================
--- linux-2.6.21.orig/include/linux/ethtool.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/ethtool.h	2009-11-30 12:44:56.000000000 +0100
@@ -260,6 +260,7 @@
 
 struct net_device;
 
+#ifdef CONFIG_ETHTOOL
 /* Some generic methods drivers may use in their ethtool_ops */
 u32 ethtool_op_get_link(struct net_device *dev);
 u32 ethtool_op_get_tx_csum(struct net_device *dev);
@@ -273,6 +274,23 @@
 			     struct ethtool_perm_addr *addr, u8 *data);
 u32 ethtool_op_get_ufo(struct net_device *dev);
 int ethtool_op_set_ufo(struct net_device *dev, u32 data);
+#else
+static inline u32 ethtool_noop1(struct net_device *dev) { return 0; }
+static inline int ethtool_noop2(struct net_device *dev, u32 data) { return 0; }
+static inline int ethtool_noop3(struct net_device *dev,
+		struct ethtool_perm_addr *addr, u32 data) { return 0; }
+#define ethtool_op_get_link ethtool_noop1
+#define ethtool_op_get_tx_csum ethtool_noop1
+#define ethtool_op_set_tx_csum ethtool_noop2
+#define ethtool_op_set_tx_hw_csum ethtool_noop2
+#define ethtool_op_get_sg ethtool_noop1
+#define ethtool_op_set_sg ethtool_noop2
+#define ethtool_op_get_tso ethtool_noop1
+#define ethtool_op_set_tso ethtool_noop2
+#define ethtool_op_get_perm_addr ethtool_noop3
+#define ethtool_op_get_ufo ethtool_noop1
+#define ethtool_op_set_ufo ethtool_noop2
+#endif
 
 /**
  * &ethtool_ops - Alter and report network device settings
Index: linux-2.6.21/include/linux/filter.h
===================================================================
--- linux-2.6.21.orig/include/linux/filter.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/filter.h	2009-11-30 12:44:56.000000000 +0100
@@ -141,12 +141,18 @@
 #define SKF_LL_OFF    (-0x200000)
 
 #ifdef __KERNEL__
+#ifdef CONFIG_NET_SK_FILTER
 struct sk_buff;
 struct sock;
 
 extern unsigned int sk_run_filter(struct sk_buff *skb, struct sock_filter *filter, int flen);
 extern int sk_attach_filter(struct sock_fprog *fprog, struct sock *sk);
 extern int sk_chk_filter(struct sock_filter *filter, int flen);
+#else
+#define sk_run_filter(a, b, c) (0)
+#define sk_attach_filter(a, b) (-EINVAL)
+#define sk_chk_filter(a, b) (-EINVAL)
+#endif /* NET_SK_FILTER */
 #endif /* __KERNEL__ */
 
 #endif /* __LINUX_FILTER_H__ */
Index: linux-2.6.21/include/linux/fs.h
===================================================================
--- linux-2.6.21.orig/include/linux/fs.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/fs.h	2009-11-30 12:44:56.000000000 +0100
@@ -828,6 +828,13 @@
 
 #include <linux/fcntl.h>
 
+extern void send_sigio(struct fown_struct *fown, int fd, int band);
+
+/* fs/sync.c */
+extern int do_sync_file_range(struct file *file, loff_t offset, loff_t endbyte,
+			unsigned int flags);
+
+#ifdef CONFIG_FILE_LOCKING
 extern int fcntl_getlk(struct file *, struct flock __user *);
 extern int fcntl_setlk(unsigned int, struct file *, unsigned int,
 			struct flock __user *);
@@ -838,14 +845,9 @@
 			struct flock64 __user *);
 #endif
 
-extern void send_sigio(struct fown_struct *fown, int fd, int band);
 extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
 extern int fcntl_getlease(struct file *filp);
 
-/* fs/sync.c */
-extern int do_sync_file_range(struct file *file, loff_t offset, loff_t endbyte,
-			unsigned int flags);
-
 /* fs/locks.c */
 extern void locks_init_lock(struct file_lock *);
 extern void locks_copy_lock(struct file_lock *, struct file_lock *);
@@ -864,6 +866,38 @@
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
 extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
 
+#else /* !CONFIG_FILE_LOCKING */
+
+#define fcntl_getlk(a, b) (-EINVAL)
+#define fcntl_setlk(a, b, c, d) (-EACCES)
+#if BITS_PER_LONG == 32
+#define fcntl_getlk64(a, b) (-EINVAL)
+#define fcntl_setlk64(a, b, c, d) (-EACCES)
+#endif
+#define fcntl_setlease(a, b, c) (0)
+#define fcntl_getlease(a) (0)
+#define locks_init_lock(a)
+#define locks_copy_lock(a, b)
+#define locks_remove_posix(a, b)
+#define locks_remove_flock(a)
+#define posix_test_lock(a, b) (0)
+#define posix_lock_file(a, b) (-ENOLCK)
+#define posix_lock_file_wait(a, b) (-ENOLCK)
+#define posix_block_lock(a, b)
+#define posix_unblock_lock(a, b) (-ENOENT)
+#define posix_locks_deadlock(a, b) (0)
+#define vfs_test_lock(a, b) (0)
+#define vfs_lock_file(a, b, c, d) (-ENOLCK)
+#define vfs_cancel_lock(a, b) (0)
+#define flock_lock_file_wait(a, b) (-ENOLCK)
+#define __break_lease(a, b) (0)
+#define lease_get_mtime(a, b)
+#define lock_may_read(a, b, c) (1)
+#define lock_may_write(a, b, c) (1)
+#define steal_locks(a)
+
+#endif /* !CONFIG_FILE_LOCKING */
+
 struct fasync_struct {
 	int	magic;
 	int	fa_fd;
@@ -1416,6 +1450,7 @@
 #define FLOCK_VERIFY_READ  1
 #define FLOCK_VERIFY_WRITE 2
 
+#ifdef CONFIG_FILE_LOCKING
 extern int locks_mandatory_locked(struct inode *);
 extern int locks_mandatory_area(int, struct inode *, struct file *, loff_t, size_t);
 
@@ -1456,6 +1491,18 @@
 	return 0;
 }
 
+#else /* !CONFIG_FILE_LOCKING */
+
+#define locks_mandatory_locked(a) (0)
+#define locks_mandatory_area(a, b, c, d, e) (0)
+#define MANDATORY_LOCK(inode) (0)
+#define locks_verify_locked(a) (0)
+#define locks_verify_area(a, b, c, d, e) (0 && (b))
+#define locks_verify_truncate(a, b, c) (0)
+#define break_lease(a, b) (0)
+
+#endif /* !CONFIG_FILE_LOCKING */
+
 /* fs/open.c */
 
 extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
Index: linux-2.6.21/include/linux/if_ppp.h
===================================================================
--- linux-2.6.21.orig/include/linux/if_ppp.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/if_ppp.h	2009-11-30 12:44:56.000000000 +0100
@@ -1,4 +1,4 @@
-/*	$Id: if_ppp.h,v 1.21 2000/03/27 06:03:36 paulus Exp $	*/
+/*	$Id: if_ppp.h,v 1.2 2008-12-26 08:01:14 steven Exp $	*/
 
 /*
  * if_ppp.h - Point-to-Point Protocol definitions.
@@ -110,6 +110,21 @@
 	struct ppp_comp_stats stats;
 };
 
+/* For PPPIOCGL2TPSTATS */
+struct pppol2tp_ioc_stats {
+	__u16	tunnel_id;	/* redundant */
+	__u16	session_id;	/* if zero, get tunnel stats */
+	__u64	tx_packets;
+	__u64	tx_bytes;
+	__u64	tx_errors;
+	__u64	rx_packets;
+	__u64	rx_bytes;
+	__u64	rx_seq_discards;
+	__u64	rx_oos_packets;
+	__u64	rx_errors;
+	int	using_ipsec;	/* valid only for session_id == 0 */
+};
+
 #define ifr__name       b.ifr_ifrn.ifrn_name
 #define stats_ptr       b.ifr_ifru.ifru_data
 
@@ -146,6 +161,7 @@
 #define PPPIOCDISCONN	_IO('t', 57)		/* disconnect channel */
 #define PPPIOCATTCHAN	_IOW('t', 56, int)	/* attach to ppp channel */
 #define PPPIOCGCHAN	_IOR('t', 55, int)	/* get ppp channel number */
+#define PPPIOCGL2TPSTATS _IOR('t', 54, struct pppol2tp_ioc_stats)
 
 #define SIOCGPPPSTATS   (SIOCDEVPRIVATE + 0)
 #define SIOCGPPPVER     (SIOCDEVPRIVATE + 1)	/* NEVER change this!! */
Index: linux-2.6.21/include/linux/if_pppol2tp.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/linux/if_pppol2tp.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,67 @@
+/***************************************************************************
+ * Linux PPP over L2TP (PPPoL2TP) Socket Implementation (RFC 2661)
+ *
+ * This file supplies definitions required by the PPP over L2TP driver
+ * (pppol2tp.c).  All version information wrt this file is located in pppol2tp.c
+ *
+ * License:
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __LINUX_IF_PPPOL2TP_H
+#define __LINUX_IF_PPPOL2TP_H
+
+#include <asm/types.h>
+
+#ifdef __KERNEL__
+#include <linux/in.h>
+#endif
+
+/* Structure used to bind() the socket to a particular socket & tunnel */
+struct pppol2tp_addr
+{
+	pid_t	pid;			/* pid that owns the fd.
+					 * 0 => current */
+	int	fd;			/* FD of UDP socket to use */
+
+	struct sockaddr_in addr;	/* IP address and port to send to */
+
+	__u16 s_tunnel, s_session;	/* For matching incoming packets */
+	__u16 d_tunnel, d_session;	/* For sending outgoing packets */
+};
+
+/* Socket options:
+ * DEBUG	- bitmask of debug message categories
+ * SENDSEQ	- 0 => don't send packets with sequence numbers
+ *		  1 => send packets with sequence numbers
+ * RECVSEQ	- 0 => receive packet sequence numbers are optional
+ *		  1 => drop receive packets without sequence numbers
+ * LNSMODE	- 0 => act as LAC.
+ *		  1 => act as LNS.
+ * REORDERTO	- reorder timeout (in millisecs). If 0, don't try to reorder.
+ */
+enum {
+	PPPOL2TP_SO_DEBUG	= 1,
+	PPPOL2TP_SO_RECVSEQ	= 2,
+	PPPOL2TP_SO_SENDSEQ	= 3,
+	PPPOL2TP_SO_LNSMODE	= 4,
+	PPPOL2TP_SO_REORDERTO	= 5,
+};
+
+/* Debug message categories for the DEBUG socket option */
+enum {
+	PPPOL2TP_MSG_DEBUG	= (1 << 0),	/* verbose debug (if
+						 * compiled in) */
+	PPPOL2TP_MSG_CONTROL	= (1 << 1),	/* userspace - kernel
+						 * interface */
+	PPPOL2TP_MSG_SEQ	= (1 << 2),	/* sequence numbers */
+	PPPOL2TP_MSG_DATA	= (1 << 3),	/* data packets */
+};
+
+
+
+#endif
Index: linux-2.6.21/include/linux/if_pppox.h
===================================================================
--- linux-2.6.21.orig/include/linux/if_pppox.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/if_pppox.h	2009-11-30 12:44:56.000000000 +0100
@@ -1,6 +1,6 @@
 /***************************************************************************
  * Linux PPP over X - Generic PPP transport layer sockets
- * Linux PPP over Ethernet (PPPoE) Socket Implementation (RFC 2516) 
+ * Linux PPP over Ethernet (PPPoE) Socket Implementation (RFC 2516)
  *
  * This file supplies definitions required by the PPP over Ethernet driver
  * (pppox.c).  All version information wrt this file is located in pppox.c
@@ -18,15 +18,28 @@
 
 
 #include <asm/types.h>
+#ifdef __KERNEL__
 #include <asm/byteorder.h>
+#else
+#include <endian.h>
+#include <byteswap.h>
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#elif __BYTE_ORDER == __BIG_ENDIAN
+#define __BIG_ENDIAN_BITFIELD
+#else
+#error "Adjust your <endian.h> defines."
+#endif
+#endif
 
-#ifdef  __KERNEL__
+#ifdef	__KERNEL__
 #include <linux/if_ether.h>
 #include <linux/if.h>
 #include <linux/netdevice.h>
 #include <asm/semaphore.h>
 #include <linux/ppp_channel.h>
 #endif /* __KERNEL__ */
+#include <linux/if_pppol2tp.h>
 
 /* For user-space programs to pick up these definitions
  * which they wouldn't get otherwise without defining __KERNEL__
@@ -36,30 +49,48 @@
 #define PF_PPPOX	AF_PPPOX
 #endif /* !(AF_PPPOX) */
 
-/************************************************************************ 
- * PPPoE addressing definition 
- */ 
-typedef __u16 sid_t; 
-struct pppoe_addr{ 
-       sid_t           sid;                    /* Session identifier */ 
-       unsigned char   remote[ETH_ALEN];       /* Remote address */ 
-       char            dev[IFNAMSIZ];          /* Local device to use */ 
-}; 
- 
-/************************************************************************ 
- * Protocols supported by AF_PPPOX 
- */ 
-#define PX_PROTO_OE    0 /* Currently just PPPoE */
-#define PX_MAX_PROTO   1	
- 
-struct sockaddr_pppox { 
-       sa_family_t     sa_family;            /* address family, AF_PPPOX */ 
-       unsigned int    sa_protocol;          /* protocol identifier */ 
-       union{ 
-               struct pppoe_addr       pppoe; 
-       }sa_addr; 
-}__attribute__ ((packed)); 
+/************************************************************************
+ * PPPoE addressing definition
+ */
+typedef __u16 sid_t;
+struct pppoe_addr{
+       sid_t           sid;                    /* Session identifier */
+       unsigned char   remote[ETH_ALEN];       /* Remote address */
+       char            dev[IFNAMSIZ];          /* Local device to use */
+};
 
+struct pptp_addr{
+       __u16           call_id;
+       struct in_addr  sin_addr;
+};
+
+/************************************************************************
+ * Protocols supported by AF_PPPOX
+ */
+#define PX_PROTO_OE    0 /* Currently just PPPoE */
+#define PX_PROTO_OL2TP 1 /* Now L2TP also */
+#define PX_PROTO_PPTP  2 /* Now PPTP also */
+#define PX_MAX_PROTO   3
+
+struct sockaddr_pppox {
+       sa_family_t     sa_family;            /* address family, AF_PPPOX */
+       unsigned int    sa_protocol;          /* protocol identifier */
+       union{
+               struct pppoe_addr       pppoe;
+	       struct pptp_addr        pptp;
+       }sa_addr;
+}__attribute__ ((packed));
+
+/* The use of the above union isn't viable because the size of this
+ * struct must stay fixed over time -- applications use sizeof(struct
+ * sockaddr_pppox) to fill it. We use a protocol specific sockaddr
+ * type instead.
+ */
+struct sockaddr_pppol2tp {
+	sa_family_t     sa_family;      /* address family, AF_PPPOX */
+	unsigned int    sa_protocol;    /* protocol identifier */
+	struct pppol2tp_addr pppol2tp;
+}__attribute__ ((packed));
 
 /*********************************************************************
  *
@@ -70,6 +101,7 @@
 #define PPPOEIOCSFWD	_IOW(0xB1 ,0, size_t)
 #define PPPOEIOCDFWD	_IO(0xB1 ,1)
 /*#define PPPOEIOCGFWD	_IOWR(0xB1,2, size_t)*/
+#define PPPTPIOWFP  	_IOWR(0xB1 ,2,size_t)
 
 /* Codes to identify message types */
 #define PADI_CODE	0x09
@@ -89,11 +121,11 @@
 #define PTT_AC_NAME	__constant_htons(0x0102)
 #define PTT_HOST_UNIQ	__constant_htons(0x0103)
 #define PTT_AC_COOKIE	__constant_htons(0x0104)
-#define PTT_VENDOR 	__constant_htons(0x0105)
+#define PTT_VENDOR	__constant_htons(0x0105)
 #define PTT_RELAY_SID	__constant_htons(0x0110)
-#define PTT_SRV_ERR     __constant_htons(0x0201)
-#define PTT_SYS_ERR  	__constant_htons(0x0202)
-#define PTT_GEN_ERR  	__constant_htons(0x0203)
+#define PTT_SRV_ERR	__constant_htons(0x0201)
+#define PTT_SYS_ERR	__constant_htons(0x0202)
+#define PTT_GEN_ERR	__constant_htons(0x0203)
 
 struct pppoe_hdr {
 #if defined(__LITTLE_ENDIAN_BITFIELD)
@@ -111,9 +143,13 @@
 	struct pppoe_tag tag[0];
 } __attribute__ ((packed));
 
+/* Socket options */
+#define PPTP_SO_TIMEOUT 1
+#define PPTP_SO_WINDOW  2
+
 #ifdef __KERNEL__
 struct pppoe_opt {
-	struct net_device      *dev;	  /* device associated with socket*/
+	struct net_device	*dev;	  /* device associated with socket*/
 	int			ifindex;  /* ifindex of device associated with socket */
 	struct pppoe_addr	pa;	  /* what this socket is bound to*/
 	struct sockaddr_pppox	relay;	  /* what socket data will be
@@ -122,6 +158,26 @@
 
 #include <net/sock.h>
 
+struct pptp_opt {
+       struct pptp_addr        src_addr;
+       struct pptp_addr        dst_addr;
+       int timeout;
+       int window;
+       __u32 ack_sent, ack_recv;
+       __u32 seq_sent, seq_recv;
+       int ppp_flags;
+       int flags;
+       int pause:1;
+       int proc:1;
+       spinlock_t skb_buf_lock;
+       struct sk_buff_head skb_buf;
+       struct delayed_work buf_work; //check bufferd packets work
+       struct gre_statistics *stat;
+	wait_queue_head_t	wait;
+	spinlock_t xmit_lock;
+	spinlock_t rcv_lock;
+};
+
 struct pppox_sock {
 	/* struct sock must be the first member of pppox_sock */
 	struct sock		sk;
@@ -129,6 +185,7 @@
 	struct pppox_sock	*next;	  /* for hash table */
 	union {
 		struct pppoe_opt pppoe;
+		struct pptp_opt pptp;
 	} proto;
 	unsigned short		num;
 };
Index: linux-2.6.21/include/linux/if_tun.h
===================================================================
--- linux-2.6.21.orig/include/linux/if_tun.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/if_tun.h	2009-11-30 12:44:56.000000000 +0100
@@ -12,7 +12,7 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  *  GNU General Public License for more details.
  *
- *  $Id: if_tun.h,v 1.2 2001/06/01 18:39:47 davem Exp $
+ *  $Id: if_tun.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
  */
 
 #ifndef __IF_TUN_H
Index: linux-2.6.21/include/linux/igmp.h
===================================================================
--- linux-2.6.21.orig/include/linux/igmp.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/igmp.h	2009-11-30 12:44:56.000000000 +0100
@@ -198,6 +198,7 @@
 #define IGMPV3_QQIC(value) IGMPV3_EXP(0x80, 4, 3, value)
 #define IGMPV3_MRC(value) IGMPV3_EXP(0x80, 4, 3, value)
 
+#ifdef CONFIG_IGMP
 extern int ip_check_mc(struct in_device *dev, __be32 mc_addr, __be32 src_addr, u16 proto);
 extern int igmp_rcv(struct sk_buff *);
 extern int ip_mc_join_group(struct sock *sk, struct ip_mreqn *imr);
@@ -219,6 +220,25 @@
 extern void ip_mc_dec_group(struct in_device *in_dev, __be32 addr);
 extern void ip_mc_inc_group(struct in_device *in_dev, __be32 addr);
 extern void ip_mc_rejoin_group(struct ip_mc_list *im);
+#else /* !CONFIG_IGMP */
+#define ip_check_mc(a, b, c, d) (0)
+#define igmp_rcv(a) (0)
+#define ip_mc_join_group(a, b) (0)
+#define ip_mc_leave_group(a, b) (0)
+#define ip_mc_drop_socket(a)
+#define ip_mc_source(a, b, c, d, e) (0)
+#define ip_mc_msfilter(a, b, c) (0)
+#define ip_mc_msfget(a, b, c, d) (0)
+#define ip_mc_gsfget(a, b, c, d) (0)
+#define ip_mc_sf_allow(a, b, c, d) (0)
+#define ip_mc_init_dev(a)
+#define ip_mc_destroy_dev(a)
+#define ip_mc_up(a)
+#define ip_mc_down(a)
+#define ip_mc_dec_group(a, b)
+#define ip_mc_inc_group(a, b)
+#define ip_mc_rejoin_group(a)
+#endif /* !CONFIG_IGMP */
 
 #endif
 #endif
Index: linux-2.6.21/include/linux/inet.h
===================================================================
--- linux-2.6.21.orig/include/linux/inet.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/inet.h	2009-11-30 12:44:56.000000000 +0100
@@ -8,31 +8,31 @@
  *		This work was derived from Ross Biro's inspirational work
  *		for the LINUX operating system.  His version numbers were:
  *
- *		$Id: Space.c,v     0.8.4.5  1992/12/12 19:25:04 bir7 Exp $
- *		$Id: arp.c,v       0.8.4.6  1993/01/28 22:30:00 bir7 Exp $
- *		$Id: arp.h,v       0.8.4.6  1993/01/28 22:30:00 bir7 Exp $
- *		$Id: dev.c,v       0.8.4.13 1993/01/23 18:00:11 bir7 Exp $
- *		$Id: dev.h,v       0.8.4.7  1993/01/23 18:00:11 bir7 Exp $
- *		$Id: eth.c,v       0.8.4.4  1993/01/22 23:21:38 bir7 Exp $
- *		$Id: eth.h,v       0.8.4.1  1992/11/10 00:17:18 bir7 Exp $
- *		$Id: icmp.c,v      0.8.4.9  1993/01/23 18:00:11 bir7 Exp $
- *		$Id: icmp.h,v      0.8.4.2  1992/11/15 14:55:30 bir7 Exp $
- * 		$Id: ip.c,v        0.8.4.8  1992/12/12 19:25:04 bir7 Exp $
- * 		$Id: ip.h,v        0.8.4.2  1993/01/23 18:00:11 bir7 Exp $
- * 		$Id: loopback.c,v  0.8.4.8  1993/01/23 18:00:11 bir7 Exp $
- * 		$Id: packet.c,v    0.8.4.7  1993/01/26 22:04:00 bir7 Exp $
- *		$Id: protocols.c,v 0.8.4.3  1992/11/15 14:55:30 bir7 Exp $
- *		$Id: raw.c,v       0.8.4.12 1993/01/26 22:04:00 bir7 Exp $
- *		$Id: sock.c,v      0.8.4.6  1993/01/28 22:30:00 bir7 Exp $
- *		$Id: sock.h,v      0.8.4.7  1993/01/26 22:04:00 bir7 Exp $
- *		$Id: tcp.c,v       0.8.4.16 1993/01/26 22:04:00 bir7 Exp $
- *		$Id: tcp.h,v       0.8.4.7  1993/01/22 22:58:08 bir7 Exp $
- *		$Id: timer.c,v     0.8.4.8  1993/01/23 18:00:11 bir7 Exp $
- *		$Id: timer.h,v     0.8.4.2  1993/01/23 18:00:11 bir7 Exp $
- *		$Id: udp.c,v       0.8.4.12 1993/01/26 22:04:00 bir7 Exp $
- *		$Id: udp.h,v       0.8.4.1  1992/11/10 00:17:18 bir7 Exp $
- *		$Id: we.c,v        0.8.4.10 1993/01/23 18:00:11 bir7 Exp $
- *		$Id: wereg.h,v     0.8.4.1  1992/11/10 00:17:18 bir7 Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ * 		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ * 		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ * 		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ * 		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
+ *		$Id: inet.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
  *
  *		This program is free software; you can redistribute it and/or
  *		modify it under the terms of the GNU General Public License
Index: linux-2.6.21/include/linux/ip6_tunnel.h
===================================================================
--- linux-2.6.21.orig/include/linux/ip6_tunnel.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/ip6_tunnel.h	2009-11-30 12:44:56.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id: ip6_tunnel.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
  */
 
 #ifndef _IP6_TUNNEL_H
Index: linux-2.6.21/include/linux/irq.h
===================================================================
--- linux-2.6.21.orig/include/linux/irq.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/irq.h	2009-11-30 12:44:56.000000000 +0100
@@ -304,10 +304,12 @@
 #ifdef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
 	desc->handle_irq(irq, desc);
 #else
-	if (likely(desc->handle_irq))
+	if (likely(desc->handle_irq)){
 		desc->handle_irq(irq, desc);
-	else
+	}
+	else{
 		__do_IRQ(irq);
+	}
 #endif
 }
 
Index: linux-2.6.21/include/linux/Kbuild
===================================================================
--- linux-2.6.21.orig/include/linux/Kbuild	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/Kbuild	2009-11-30 12:44:56.000000000 +0100
@@ -220,6 +220,7 @@
 unifdef-y += if_frad.h
 unifdef-y += if_ltalk.h
 unifdef-y += if_link.h
+unifdef-y += if_pppol2tp.h
 unifdef-y += if_pppox.h
 unifdef-y += if_shaper.h
 unifdef-y += if_tr.h
Index: linux-2.6.21/include/linux/kernel.h
===================================================================
--- linux-2.6.21.orig/include/linux/kernel.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/kernel.h	2009-11-30 12:44:56.000000000 +0100
@@ -94,8 +94,23 @@
 
 extern struct atomic_notifier_head panic_notifier_list;
 extern long (*panic_blink)(long time);
+
+#ifndef CONFIG_PANIC
+NORET_TYPE static inline void panic(const char * fmt, ...)
+	__attribute__ ((NORET_AND format (printf, 1, 2)));
+NORET_TYPE static inline void panic(const char * fmt, ...) {}
+#else
+
+#ifdef CONFIG_FULL_PANIC
 NORET_TYPE void panic(const char * fmt, ...)
 	__attribute__ ((NORET_AND format (printf, 1, 2)));
+#else
+#define panic(fmt, ...) tiny_panic(0, ## __VA_ARGS__)
+NORET_TYPE void tiny_panic(int a, ...) ATTRIB_NORET;
+#endif
+
+#endif
+
 extern void oops_enter(void);
 extern void oops_exit(void);
 extern int oops_may_print(void);
@@ -139,7 +154,7 @@
 
 extern void dump_thread(struct pt_regs *regs, struct user *dump);
 
-#ifdef CONFIG_PRINTK
+#if defined(CONFIG_PRINTK) || (defined(CONFIG_PRINTK_FUNC) && defined(DO_PRINTK))
 asmlinkage int vprintk(const char *fmt, va_list args)
 	__attribute__ ((format (printf, 1, 0)));
 asmlinkage int printk(const char * fmt, ...)
Index: linux-2.6.21/include/linux/LzmaDecode.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/linux/LzmaDecode.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,113 @@
+/* 
+  LzmaDecode.h
+  LZMA Decoder interface
+
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMADECODE_H
+#define __LZMADECODE_H
+
+#include "LzmaTypes.h"
+
+/* #define _LZMA_IN_CB */
+/* Use callback for input data */
+
+/* #define _LZMA_OUT_READ */
+/* Use read function for output data */
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_LOC_OPT */
+/* Enable local speed optimizations inside code */
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#ifdef _LZMA_IN_CB
+typedef struct _ILzmaInCallback
+{
+  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
+} ILzmaInCallback;
+#endif
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  #ifdef _LZMA_OUT_READ
+  UInt32 DictionarySize;
+  #endif
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((Properties)->lc + (Properties)->lp)))
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+
+  #ifdef _LZMA_IN_CB
+  const unsigned char *Buffer;
+  const unsigned char *BufferLim;
+  #endif
+
+  #ifdef _LZMA_OUT_READ
+  unsigned char *Dictionary;
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;
+  unsigned char TempDictionary[4];
+  #endif
+} CLzmaDecoderState;
+
+#ifdef _LZMA_OUT_READ
+#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; }
+#endif
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);
+
+#endif
Index: linux-2.6.21/include/linux/LzmaTypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/linux/LzmaTypes.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,45 @@
+/* 
+LzmaTypes.h 
+
+Types for LZMA Decoder
+
+This file written and distributed to public domain by Igor Pavlov.
+This file is part of LZMA SDK 4.40 (2006-05-01)
+*/
+
+#ifndef __LZMATYPES_H
+#define __LZMATYPES_H
+
+#ifndef _7ZIP_BYTE_DEFINED
+#define _7ZIP_BYTE_DEFINED
+typedef unsigned char Byte;
+#endif 
+
+#ifndef _7ZIP_UINT16_DEFINED
+#define _7ZIP_UINT16_DEFINED
+typedef unsigned short UInt16;
+#endif 
+
+#ifndef _7ZIP_UINT32_DEFINED
+#define _7ZIP_UINT32_DEFINED
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef unsigned long UInt32;
+#else
+typedef unsigned int UInt32;
+#endif
+#endif 
+
+/* #define _LZMA_SYSTEM_SIZE_T */
+/* Use system's size_t. You can use it to enable 64-bit sizes supporting */
+
+#ifndef _7ZIP_SIZET_DEFINED
+#define _7ZIP_SIZET_DEFINED
+#ifdef _LZMA_SYSTEM_SIZE_T
+#include <stddef.h>
+typedef size_t SizeT;
+#else
+typedef UInt32 SizeT;
+#endif
+#endif
+
+#endif
Index: linux-2.6.21/include/linux/mempool.h
===================================================================
--- linux-2.6.21.orig/include/linux/mempool.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/mempool.h	2009-11-30 12:44:56.000000000 +0100
@@ -11,6 +11,7 @@
 typedef void * (mempool_alloc_t)(gfp_t gfp_mask, void *pool_data);
 typedef void (mempool_free_t)(void *element, void *pool_data);
 
+#ifdef CONFIG_MEMPOOL
 typedef struct mempool_s {
 	spinlock_t lock;
 	int min_nr;		/* nr of elements at *elements */
@@ -33,6 +34,24 @@
 extern void * mempool_alloc(mempool_t *pool, gfp_t gfp_mask);
 extern void mempool_free(void *element, mempool_t *pool);
 
+#else
+
+typedef struct mempool_s {
+	void *pool_data;
+	void *cache;
+	mempool_alloc_t *alloc;
+	mempool_free_t *free;
+} mempool_t;
+
+extern mempool_t * mempool_create(int min_nr, mempool_alloc_t *alloc_fn,
+		mempool_free_t *free_fn, void *pool_data);
+extern void * mempool_alloc(mempool_t *pool, int gfp_mask);
+extern void mempool_free(void *element, mempool_t *pool);
+extern void mempool_destroy(mempool_t *pool);
+#define mempool_resize(a, b, c) (0)
+#define mempool_create_node(m, a, f, p, n) mempool_create(m, a, f, p)
+
+#endif
 /*
  * A mempool_alloc_t and mempool_free_t that get the memory from
  * a slab that is passed in through pool_data.
Index: linux-2.6.21/include/linux/mroute.h
===================================================================
--- linux-2.6.21.orig/include/linux/mroute.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/mroute.h	2009-11-30 12:44:56.000000000 +0100
@@ -131,7 +131,11 @@
 extern int ip_mroute_setsockopt(struct sock *, int, char __user *, int);
 extern int ip_mroute_getsockopt(struct sock *, int, char __user *, int __user *);
 extern int ipmr_ioctl(struct sock *sk, int cmd, void __user *arg);
+#ifdef CONFIG_IGMP
 extern void ip_mr_init(void);
+#else
+static inline void ip_mr_init(void) {}
+#endif
 
 
 struct vif_device
Index: linux-2.6.21/include/linux/mtd/blktrans.h
===================================================================
--- linux-2.6.21.orig/include/linux/mtd/blktrans.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/mtd/blktrans.h	2009-11-30 12:44:56.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * $Id: blktrans.h,v 1.6 2005/11/07 11:14:54 gleixner Exp $
+ * $Id: blktrans.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
  *
  * (C) 2003 David Woodhouse <dwmw2@infradead.org>
  *
Index: linux-2.6.21/include/linux/mtd/cfi_endian.h
===================================================================
--- linux-2.6.21.orig/include/linux/mtd/cfi_endian.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/mtd/cfi_endian.h	2009-11-30 12:44:56.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * $Id: cfi_endian.h,v 1.11 2002/01/30 23:20:48 awozniak Exp $
+ * $Id: cfi_endian.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $
  *
  */
 
Index: linux-2.6.21/include/linux/mtd/cfi.h
===================================================================
--- linux-2.6.21.orig/include/linux/mtd/cfi.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/mtd/cfi.h	2009-11-30 12:44:56.000000000 +0100
@@ -1,7 +1,7 @@
 
 /* Common Flash Interface structures
  * See http://support.intel.com/design/flash/technote/index.htm
- * $Id: cfi.h,v 1.57 2005/11/15 23:28:17 tpoynor Exp $
+ * $Id: cfi.h,v 1.3 2009-01-16 07:28:30 steven Exp $
  */
 
 #ifndef __MTD_CFI_H__
@@ -201,6 +201,27 @@
 
 /* Vendor-Specific PRI for Atmel chips (command set 0x0002) */
 
+/* Vendor-Specific PRI for SST Extended Command Set (0x0701) */
+
+struct cfi_pri_sststd {
+	uint8_t  pri[3];
+	uint8_t  MajorVersion;
+	uint8_t  MinorVersion;
+	uint8_t  SiliconRevision; /* bits 1-0: Address Sensitive Unlock */
+	uint8_t  EraseSuspend;
+	uint8_t  BlkProt;
+	uint8_t  TmpBlkUnprotect;
+	uint8_t  BlkProtUnprot;
+	uint8_t  SimultaneousOps;
+	uint8_t  BurstMode;
+	uint8_t  PageMode;
+	uint8_t  VppMin;
+	uint8_t  VppMax;
+	uint8_t  TopBottom;
+} __attribute__((packed));
+
+/* Vendor-Specific PRI for SST chips (command set 0x0701) */
+
 struct cfi_pri_atmel {
 	uint8_t pri[3];
 	uint8_t MajorVersion;
@@ -477,7 +498,9 @@
 
 #define CFI_MFR_AMD 0x0001
 #define CFI_MFR_ATMEL 0x001F
+#define CFI_MFR_SAMSUNG 0x00EC
 #define CFI_MFR_ST  0x0020 	/* STMicroelectronics */
+#define CFI_MFR_SST 0x00BF
 
 void cfi_fixup(struct mtd_info *mtd, struct cfi_fixup* fixups);
 
Index: linux-2.6.21/include/linux/netdevice.h
===================================================================
--- linux-2.6.21.orig/include/linux/netdevice.h	2009-11-30 12:44:56.000000000 +0100
+++ linux-2.6.21/include/linux/netdevice.h	2009-11-30 12:44:56.000000000 +0100
@@ -973,17 +973,27 @@
 extern int		register_netdev(struct net_device *dev);
 extern void		unregister_netdev(struct net_device *dev);
 /* Functions used for multicast support */
+#ifdef CONFIG_NET_DEV_MULTICAST
 extern void		dev_mc_upload(struct net_device *dev);
 extern int 		dev_mc_delete(struct net_device *dev, void *addr, int alen, int all);
 extern int		dev_mc_add(struct net_device *dev, void *addr, int alen, int newonly);
 extern void		dev_mc_discard(struct net_device *dev);
+extern void		dev_mcast_init(void);
+#else
+#define		dev_mc_upload(a)
+static inline int dev_mc_delete(struct net_device *dev,
+		void *addr, int alen, int all) { return 0; }
+static inline int dev_mc_add(struct net_device *dev,
+		void *addr, int alen, int newonly) { return 0; }
+#define		dev_mc_discard(a)
+#define		dev_mcast_init()
+#endif
 extern void		dev_set_promiscuity(struct net_device *dev, int inc);
 extern void		dev_set_allmulti(struct net_device *dev, int inc);
 extern void		netdev_state_change(struct net_device *dev);
 extern void		netdev_features_change(struct net_device *dev);
 /* Load a device via the kmod */
 extern void		dev_load(const char *name);
-extern void		dev_mcast_init(void);
 extern int		netdev_max_backlog;
 extern int		weight_p;
 extern int		netdev_set_master(struct net_device *dev, struct net_device *master);
Index: linux-2.6.21/include/linux/netfilter/xt_layer7.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/linux/netfilter/xt_layer7.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,13 @@
+#ifndef _XT_LAYER7_H
+#define _XT_LAYER7_H
+
+#define MAX_PATTERN_LEN 8192
+#define MAX_PROTOCOL_LEN 256
+
+struct xt_layer7_info {
+    char protocol[MAX_PROTOCOL_LEN];
+    char invert:1;
+    char pattern[MAX_PATTERN_LEN];
+};
+
+#endif /* _XT_LAYER7_H */
Index: linux-2.6.21/include/linux/netfilter_helpers.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/linux/netfilter_helpers.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,133 @@
+/*
+ * Helpers for netfiler modules.  This file provides implementations for basic
+ * functions such as strncasecmp(), etc.
+ *
+ * gcc will warn for defined but unused functions, so we only include the
+ * functions requested.  The following macros are used:
+ *   NF_NEED_STRNCASECMP        nf_strncasecmp()
+ *   NF_NEED_STRTOU16           nf_strtou16()
+ *   NF_NEED_STRTOU32           nf_strtou32()
+ */
+#ifndef _NETFILTER_HELPERS_H
+#define _NETFILTER_HELPERS_H
+
+/* Only include these functions for kernel code. */
+#ifdef __KERNEL__
+
+#include <linux/ctype.h>
+#define iseol(c) ( (c) == '\r' || (c) == '\n' )
+
+/*
+ * The standard strncasecmp()
+ */
+#ifdef NF_NEED_STRNCASECMP
+static int
+nf_strncasecmp(const char* s1, const char* s2, u_int32_t len)
+{
+    if (s1 == NULL || s2 == NULL)
+    {
+        if (s1 == NULL && s2 == NULL)
+        {
+            return 0;
+        }
+        return (s1 == NULL) ? -1 : 1;
+    }
+    while (len > 0 && tolower(*s1) == tolower(*s2))
+    {
+        len--;
+        s1++;
+        s2++;
+    }
+    return ( (len == 0) ? 0 : (tolower(*s1) - tolower(*s2)) );
+}
+#endif /* NF_NEED_STRNCASECMP */
+
+/*
+ * Parse a string containing a 16-bit unsigned integer.
+ * Returns the number of chars used, or zero if no number is found.
+ */
+#ifdef NF_NEED_STRTOU16
+static int
+nf_strtou16(const char* pbuf, u_int16_t* pval)
+{
+    int n = 0;
+
+    *pval = 0;
+    while (isdigit(pbuf[n]))
+    {
+        *pval = (*pval * 10) + (pbuf[n] - '0');
+        n++;
+    }
+
+    return n;
+}
+#endif /* NF_NEED_STRTOU16 */
+
+/*
+ * Parse a string containing a 32-bit unsigned integer.
+ * Returns the number of chars used, or zero if no number is found.
+ */
+#ifdef NF_NEED_STRTOU32
+static int
+nf_strtou32(const char* pbuf, u_int32_t* pval)
+{
+    int n = 0;
+
+    *pval = 0;
+    while (pbuf[n] >= '0' && pbuf[n] <= '9')
+    {
+        *pval = (*pval * 10) + (pbuf[n] - '0');
+        n++;
+    }
+
+    return n;
+}
+#endif /* NF_NEED_STRTOU32 */
+
+/*
+ * Given a buffer and length, advance to the next line and mark the current
+ * line.
+ */
+#ifdef NF_NEED_NEXTLINE
+static int
+nf_nextline(char* p, uint len, uint* poff, uint* plineoff, uint* plinelen)
+{
+    uint    off = *poff;
+    uint    physlen = 0;
+
+    if (off >= len)
+    {
+        return 0;
+    }
+
+    while (p[off] != '\n')
+    {
+        if (len-off <= 1)
+        {
+            return 0;
+        }
+
+        physlen++;
+        off++;
+    }
+
+    /* if we saw a crlf, physlen needs adjusted */
+    if (physlen > 0 && p[off] == '\n' && p[off-1] == '\r')
+    {
+        physlen--;
+    }
+
+    /* advance past the newline */
+    off++;
+
+    *plineoff = *poff;
+    *plinelen = physlen;
+    *poff = off;
+
+    return 1;
+}
+#endif /* NF_NEED_NEXTLINE */
+
+#endif /* __KERNEL__ */
+
+#endif /* _NETFILTER_HELPERS_H */
Index: linux-2.6.21/include/linux/netfilter_ipv4/ip_conntrack_quake3.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/linux/netfilter_ipv4/ip_conntrack_quake3.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,22 @@
+#ifndef _IP_CT_QUAKE3
+#define _IP_CT_QUAKE3
+
+/* Don't confuse with 27960, often used as the Server Port */
+#define QUAKE3_MASTER_PORT 27950
+
+struct quake3_search {
+	const char marker[4]; /* always 0xff 0xff 0xff 0xff ? */
+	const char *pattern;
+	size_t plen;
+}; 
+
+/* This structure is per expected connection */
+struct ip_ct_quake3_expect {
+};
+
+/* This structure exists only once per master */
+struct ip_ct_quake3_master {
+};
+
+extern unsigned int (*ip_nat_quake3_hook)(struct ip_conntrack_expect *exp);
+#endif /* _IP_CT_QUAKE3 */
Index: linux-2.6.21/include/linux/netfilter_ipv4/ip_conntrack_rtsp.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/linux/netfilter_ipv4/ip_conntrack_rtsp.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,56 @@
+/*
+ * RTSP extension for IP connection tracking.
+ * (C) 2003 by Tom Marshall <tmarshall@real.com>
+ * based on ip_conntrack_irc.h
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+#ifndef _IP_CONNTRACK_RTSP_H
+#define _IP_CONNTRACK_RTSP_H
+
+/* #define IP_NF_RTSP_DEBUG */
+#define IP_NF_RTSP_VERSION "0.6.21"
+
+/* port block types */
+typedef enum {
+    pb_single,  /* client_port=x */
+    pb_range,   /* client_port=x-y */
+    pb_discon   /* client_port=x/y (rtspbis) */
+} portblock_t;
+
+/* We record seq number and length of rtsp headers here, all in host order. */
+
+/*
+ * This structure is per expected connection.  It is a member of struct
+ * ip_conntrack_expect.  The TCP SEQ for the conntrack expect is stored
+ * there and we are expected to only store the length of the data which
+ * needs replaced.  If a packet contains multiple RTSP messages, we create
+ * one expected connection per message.
+ *
+ * We use these variables to mark the entire header block.  This may seem
+ * like overkill, but the nature of RTSP requires it.  A header may appear
+ * multiple times in a message.  We must treat two Transport headers the
+ * same as one Transport header with two entries.
+ */
+struct ip_ct_rtsp_expect
+{
+    u_int32_t   len;        /* length of header block */
+    portblock_t pbtype;     /* Type of port block that was requested */
+    u_int16_t   loport;     /* Port that was requested, low or first */
+    u_int16_t   hiport;     /* Port that was requested, high or second */
+#if 0
+    uint        method;     /* RTSP method */
+    uint        cseq;       /* CSeq from request */
+#endif
+};
+
+#ifdef __KERNEL__
+
+#define RTSP_PORT   554
+
+#endif /* __KERNEL__ */
+
+#endif /* _IP_CONNTRACK_RTSP_H */
Index: linux-2.6.21/include/linux/netfilter_mime.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/linux/netfilter_mime.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,89 @@
+/*
+ * MIME functions for netfilter modules.  This file provides implementations
+ * for basic MIME parsing.  MIME headers are used in many protocols, such as
+ * HTTP, RTSP, SIP, etc.
+ *
+ * gcc will warn for defined but unused functions, so we only include the
+ * functions requested.  The following macros are used:
+ *   NF_NEED_MIME_NEXTLINE      nf_mime_nextline()
+ */
+#ifndef _NETFILTER_MIME_H
+#define _NETFILTER_MIME_H
+
+/* Only include these functions for kernel code. */
+#ifdef __KERNEL__
+
+#include <linux/ctype.h>
+
+/*
+ * Given a buffer and length, advance to the next line and mark the current
+ * line.  If the current line is empty, *plinelen will be set to zero.  If
+ * not, it will be set to the actual line length (including CRLF).
+ *
+ * 'line' in this context means logical line (includes LWS continuations).
+ * Returns 1 on success, 0 on failure.
+ */
+#ifdef NF_NEED_MIME_NEXTLINE
+static int
+nf_mime_nextline(char* p, uint len, uint* poff, uint* plineoff, uint* plinelen)
+{
+    uint    off = *poff;
+    uint    physlen = 0;
+    int     is_first_line = 1;
+
+    if (off >= len)
+    {
+        return 0;
+    }
+
+    do
+    {
+        while (p[off] != '\n')
+        {
+            if (len-off <= 1)
+            {
+                return 0;
+            }
+
+            physlen++;
+            off++;
+        }
+
+        /* if we saw a crlf, physlen needs adjusted */
+        if (physlen > 0 && p[off] == '\n' && p[off-1] == '\r')
+        {
+            physlen--;
+        }
+
+        /* advance past the newline */
+        off++;
+
+        /* check for an empty line */
+        if (physlen == 0)
+        {
+            break;
+        }
+
+        /* check for colon on the first physical line */
+        if (is_first_line)
+        {
+            is_first_line = 0;
+            if (memchr(p+(*poff), ':', physlen) == NULL)
+            {
+                return 0;
+            }
+        }
+    }
+    while (p[off] == ' ' || p[off] == '\t');
+
+    *plineoff = *poff;
+    *plinelen = (physlen == 0) ? 0 : (off - *poff);
+    *poff = off;
+
+    return 1;
+}
+#endif /* NF_NEED_MIME_NEXTLINE */
+
+#endif /* __KERNEL__ */
+
+#endif /* _NETFILTER_MIME_H */
Index: linux-2.6.21/include/linux/netlink.h
===================================================================
--- linux-2.6.21.orig/include/linux/netlink.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/netlink.h	2009-11-30 12:44:56.000000000 +0100
@@ -25,7 +25,9 @@
 #define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
 #define NETLINK_ECRYPTFS	19
 
-#define MAX_LINKS 32		
+#define NETLINK_CSR             38
+
+#define MAX_LINKS 64 /* update for csr_test, by bobtseng 2006.5.15. */
 
 struct sockaddr_nl
 {
Index: linux-2.6.21/include/linux/sched.h
===================================================================
--- linux-2.6.21.orig/include/linux/sched.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/sched.h	2009-11-30 12:44:56.000000000 +0100
@@ -520,7 +520,7 @@
  * MAX_RT_PRIO must not be smaller than MAX_USER_RT_PRIO.
  */
 
-#define MAX_USER_RT_PRIO	100
+#define MAX_USER_RT_PRIO	CONFIG_MAX_USER_RT_PRIO
 #define MAX_RT_PRIO		MAX_USER_RT_PRIO
 
 #define MAX_PRIO		(MAX_RT_PRIO + 40)
Index: linux-2.6.21/include/linux/serial.h
===================================================================
--- linux-2.6.21.orig/include/linux/serial.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/serial.h	2009-11-30 12:44:56.000000000 +0100
@@ -76,7 +76,8 @@
 #define PORT_16654	11
 #define PORT_16850	12
 #define PORT_RSA	13	/* RSA-DV II/S card */
-#define PORT_MAX	13
+#define PORT_SB1250	14
+#define PORT_MAX	14
 
 #define SERIAL_IO_PORT	0
 #define SERIAL_IO_HUB6	1
Index: linux-2.6.21/include/linux/serialP.h
===================================================================
--- linux-2.6.21.orig/include/linux/serialP.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/serialP.h	2009-11-30 12:44:56.000000000 +0100
@@ -24,6 +24,7 @@
 #include <linux/interrupt.h>
 #include <linux/circ_buf.h>
 #include <linux/wait.h>
+#include <linux/serial.h>
 
 struct serial_state {
 	int	magic;
Index: linux-2.6.21/include/linux/serial_reg.h
===================================================================
--- linux-2.6.21.orig/include/linux/serial_reg.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/serial_reg.h	2009-11-30 12:44:56.000000000 +0100
@@ -14,13 +14,67 @@
 #ifndef _LINUX_SERIAL_REG_H
 #define _LINUX_SERIAL_REG_H
 
-/*
- * DLAB=0
+#if defined (CONFIG_RALINK_RT2880) || defined (CONFIG_RALINK_RT3052) || defined (CONFIG_RALINK_RT2883)
+
+#define UART_RX		0	/* In:  Receive buffer (DLAB=0) */
+
+#define UART_TX		1	/* Out: Transmit buffer (DLAB=0) */
+#define UART_TRG	1	/* (LCR=BF) FCTR bit 7 selects Rx or Tx
+				 * In: Fifo count
+				 * Out: Fifo custom trigger levels
+				 * XR16C85x only
+				 */
+
+#define UART_IER	2	/* Out: Interrupt Enable Register */
+#define UART_FCTR	2	/* (LCR=BF) Feature Control Register
+				 * XR16C85x only
+				 */
+
+#define UART_IIR	3	/* In:  Interrupt ID Register */
+#define UART_EFR	3	/* I/O: Extended Features Register */
+				/* (DLAB=1, 16C660 only) */
+
+#define UART_FCR	4 	/* Out: FIFO Control Register */
+#define UART_LCR	5	/* Out: Line Control Register */
+#define UART_MCR	6	/* Out: Modem Control Register */
+#define UART_LSR	7	/* In:  Line Status Register */
+#define UART_MSR	8	/* In:  Modem Status Register */
+#define UART_SCR	9	/* I/O: Scratch Register */
+#define UART_DLL	10	/* Out: Divisor Latch Low (DLAB=1) */
+/* Since surfboard uart cannot be accessed by byte, using UART_DLM will cause
+ * unpredictable values to be written to the Divisor Latch
  */
+#define UART_DLM	11	/* Out: Divisor Latch High (DLAB=1) */
+
+#else
+
 #define UART_RX		0	/* In:  Receive buffer */
 #define UART_TX		0	/* Out: Transmit buffer */
+#define UART_DLL	0	/* Out: Divisor Latch Low */
+#define UART_TRG	0	/* FCTR bit 7 selects Rx or Tx
+				 * In: Fifo count
+				 * Out: Fifo custom trigger levels */
 
+#define UART_DLM	1	/* Out: Divisor Latch High */
 #define UART_IER	1	/* Out: Interrupt Enable Register */
+#define UART_FCTR	1	/* Feature Control Register */
+
+#define UART_IIR	2	/* In:  Interrupt ID Register */
+#define UART_FCR	2	/* Out: FIFO Control Register */
+#define UART_EFR	2	/* I/O: Extended Features Register */
+
+#define UART_LCR	3	/* Out: Line Control Register */
+#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_SCR	7	/* I/O: Scratch Register */
+#define UART_EMSR	7	/* Extended Mode Select Register */
+
+#endif
+/*
+ * DLAB=0
+ */
+//#define UART_IER	1	/* Out: Interrupt Enable Register */
 #define UART_IER_MSI		0x08 /* Enable Modem status interrupt */
 #define UART_IER_RLSI		0x04 /* Enable receiver line status interrupt */
 #define UART_IER_THRI		0x02 /* Enable Transmitter holding register int. */
@@ -30,7 +84,7 @@
  */
 #define UART_IERX_SLEEP		0x10 /* Enable sleep mode */
 
-#define UART_IIR	2	/* In:  Interrupt ID Register */
+//#define UART_IIR	2	/* In:  Interrupt ID Register */
 #define UART_IIR_NO_INT		0x01 /* No interrupts pending */
 #define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
 #define UART_IIR_MSI		0x00 /* Modem status interrupt */
@@ -38,7 +92,7 @@
 #define UART_IIR_RDI		0x04 /* Receiver data interrupt */
 #define UART_IIR_RLSI		0x06 /* Receiver line status interrupt */
 
-#define UART_FCR	2	/* Out: FIFO Control Register */
+//#define UART_FCR	2	/* Out: FIFO Control Register */
 #define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
 #define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
 #define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
@@ -81,7 +135,7 @@
 #define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
 #define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
 
-#define UART_LCR	3	/* Out: Line Control Register */
+//#define UART_LCR	3	/* Out: Line Control Register */
 /*
  * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
  * UART_LCR_STOP will select 1.5 stop bits, not 2 stop bits.
@@ -97,7 +151,7 @@
 #define UART_LCR_WLEN7		0x02 /* Wordlength: 7 bits */
 #define UART_LCR_WLEN8		0x03 /* Wordlength: 8 bits */
 
-#define UART_MCR	4	/* Out: Modem Control Register */
+//#define UART_MCR	4	/* Out: Modem Control Register */
 #define UART_MCR_CLKSEL		0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
 #define UART_MCR_TCRTLR		0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
 #define UART_MCR_XONANY		0x20 /* Enable Xon Any (TI16C752, EFR[4]=1) */
@@ -108,7 +162,7 @@
 #define UART_MCR_RTS		0x02 /* RTS complement */
 #define UART_MCR_DTR		0x01 /* DTR complement */
 
-#define UART_LSR	5	/* In:  Line Status Register */
+//#define UART_LSR	5	/* In:  Line Status Register */
 #define UART_LSR_TEMT		0x40 /* Transmitter empty */
 #define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
 #define UART_LSR_BI		0x10 /* Break interrupt indicator */
@@ -117,7 +171,7 @@
 #define UART_LSR_OE		0x02 /* Overrun error indicator */
 #define UART_LSR_DR		0x01 /* Receiver data ready */
 
-#define UART_MSR	6	/* In:  Modem Status Register */
+//#define UART_MSR	6	/* In:  Modem Status Register */
 #define UART_MSR_DCD		0x80 /* Data Carrier Detect */
 #define UART_MSR_RI		0x40 /* Ring Indicator */
 #define UART_MSR_DSR		0x20 /* Data Set Ready */
@@ -128,18 +182,18 @@
 #define UART_MSR_DCTS		0x01 /* Delta CTS */
 #define UART_MSR_ANY_DELTA	0x0F /* Any of the delta bits! */
 
-#define UART_SCR	7	/* I/O: Scratch Register */
+//#define UART_SCR	7	/* I/O: Scratch Register */
 
 /*
  * DLAB=1
  */
-#define UART_DLL	0	/* Out: Divisor Latch Low */
-#define UART_DLM	1	/* Out: Divisor Latch High */
+//#define UART_DLL	0	/* Out: Divisor Latch Low */
+//#define UART_DLM	1	/* Out: Divisor Latch High */
 
 /*
  * LCR=0xBF (or DLAB=1 for 16C660)
  */
-#define UART_EFR	2	/* I/O: Extended Features Register */
+//#define UART_EFR	2	/* I/O: Extended Features Register */
 #define UART_EFR_CTS		0x80 /* CTS flow control */
 #define UART_EFR_RTS		0x40 /* RTS flow control */
 #define UART_EFR_SCD		0x20 /* Special character detect */
@@ -165,9 +219,9 @@
 /*
  * LCR=0xBF, XR16C85x
  */
-#define UART_TRG	0	/* FCTR bit 7 selects Rx or Tx
-				 * In: Fifo count
-				 * Out: Fifo custom trigger levels */
+//#define UART_TRG	0	/* FCTR bit 7 selects Rx or Tx
+//				 * In: Fifo count
+//				 * Out: Fifo custom trigger levels */
 /*
  * These are the definitions for the Programmable Trigger Register
  */
@@ -181,7 +235,7 @@
 #define UART_TRG_120		0x78
 #define UART_TRG_128		0x80
 
-#define UART_FCTR	1	/* Feature Control Register */
+//#define UART_FCTR	1	/* Feature Control Register */
 #define UART_FCTR_RTS_NODELAY	0x00  /* RTS flow control delay */
 #define UART_FCTR_RTS_4DELAY	0x01
 #define UART_FCTR_RTS_6DELAY	0x02
@@ -199,7 +253,7 @@
 /*
  * LCR=0xBF, FCTR[6]=1
  */
-#define UART_EMSR	7	/* Extended Mode Select Register */
+//#define UART_EMSR	7	/* Extended Mode Select Register */
 #define UART_EMSR_FIFO_COUNT	0x01  /* Rx/Tx select */
 #define UART_EMSR_ALT_COUNT	0x02  /* Alternating count select */
 
Index: linux-2.6.21/include/linux/socket.h
===================================================================
--- linux-2.6.21.orig/include/linux/socket.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/socket.h	2009-11-30 12:44:56.000000000 +0100
@@ -284,6 +284,8 @@
 #define SOL_DCCP	269
 #define SOL_NETLINK	270
 #define SOL_TIPC	271
+#define SOL_RXRPC	272
+#define SOL_PPPOL2TP	273
 
 /* IPX options */
 #define IPX_TYPE	1
Index: linux-2.6.21/include/linux/sqlzma.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/linux/sqlzma.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2006 Junjiro Okajima
+ * Copyright (C) 2006 Tomas Matejicek, slax.org
+ *
+ * LICENSE follows the described one in lzma.
+ */
+
+/* $Id: sqlzma.h,v 1.1 2007-06-05 09:25:21 steven Exp $ */
+
+#ifndef __sqlzma_h__
+#define __sqlzma_h__
+
+#ifndef __KERNEL__
+#include <stdlib.h>
+#include <string.h>
+#include <zlib.h>
+#ifdef _REENTRANT
+#include <pthread.h>
+#endif
+#else
+#include <linux/zlib.h>
+#endif
+#define _7ZIP_BYTE_DEFINED
+
+/*
+ * detect the compression method automatically by the first byte of compressed
+ * data.
+ * according to rfc1950, the first byte of zlib compression must be 0x?8.
+ */
+#define is_lzma(c)	(c == 0x5d)
+
+/* ---------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef __KERNEL__
+/* for mksquashfs only */
+int sqlzma_cm(int lzma, z_stream *stream, Bytef *next_in, uInt avail_in,
+	      Bytef *next_out, uInt avail_out);
+#endif
+
+/* ---------------------------------------------------------------------- */
+/*
+ * Three patterns for sqlzma uncompression. very dirty code.
+ * - kernel space (squashfs kernel module)
+ * - user space with pthread (mksquashfs)
+ * - user space without pthread (unsquashfs)
+ */
+
+struct sized_buf {
+	unsigned int	sz;
+	unsigned char	*buf;
+};
+
+enum {SQUN_PROB, SQUN_RESULT, SQUN_LAST};
+struct sqlzma_un {
+	int			un_lzma;
+	struct sized_buf	un_a[SQUN_LAST];
+	unsigned char		un_prob[31960]; /* unlzma 64KB */
+	z_stream		un_stream;
+#define un_cmbuf	un_stream.next_in
+#define un_cmlen	un_stream.avail_in
+#define un_resbuf	un_stream.next_out
+#define un_resroom	un_stream.avail_out
+#define un_reslen	un_stream.total_out
+};
+
+int sqlzma_init(struct sqlzma_un *un, int do_lzma, unsigned int res_sz);
+int sqlzma_un(struct sqlzma_un *un, struct sized_buf *src, struct sized_buf *dst);
+void sqlzma_fin(struct sqlzma_un *un);
+
+/* ---------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+};
+#endif
+#endif
Index: linux-2.6.21/include/linux/sqmagic.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/linux/sqmagic.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,17 @@
+/*
+ * Copyright (C) 2006 Junjiro Okajima
+ * Copyright (C) 2006 Tomas Matejicek, slax.org
+ *
+ * LICENSE must follow the one in squashfs.
+ */
+
+/* $Id: sqmagic.h,v 1.1 2007-06-05 09:25:21 steven Exp $ */
+
+#ifndef __sqmagic_h__
+#define __sqmagic_h__
+
+/* see SQUASHFS_MAGIC in squashfs_fs.h */
+#define SQUASHFS_MAGIC_LZMA		0x71736873
+#define SQUASHFS_MAGIC_LZMA_SWAP	0x73687371
+
+#endif
Index: linux-2.6.21/include/linux/squashfs_fs.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/linux/squashfs_fs.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,934 @@
+#ifndef SQUASHFS_FS
+#define SQUASHFS_FS
+
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs.h
+ */
+
+#ifndef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+#define CONFIG_SQUASHFS_2_0_COMPATIBILITY
+#endif
+
+#ifdef	CONFIG_SQUASHFS_VMALLOC
+#define SQUASHFS_ALLOC(a)		vmalloc(a)
+#define SQUASHFS_FREE(a)		vfree(a)
+#else
+#define SQUASHFS_ALLOC(a)		kmalloc(a, GFP_KERNEL)
+#define SQUASHFS_FREE(a)		kfree(a)
+#endif
+#define SQUASHFS_CACHED_FRAGMENTS	CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE	
+#define SQUASHFS_MAJOR			3
+#define SQUASHFS_MINOR			0
+#define SQUASHFS_MAGIC			0x73717368
+#define SQUASHFS_MAGIC_SWAP		0x68737173
+#define SQUASHFS_START			0
+
+/* size of metadata (inode and directory) blocks */
+#define SQUASHFS_METADATA_SIZE		8192
+#define SQUASHFS_METADATA_LOG		13
+
+/* default size of data blocks */
+#define SQUASHFS_FILE_SIZE		65536
+#define SQUASHFS_FILE_LOG		16
+
+#define SQUASHFS_FILE_MAX_SIZE		65536
+
+/* Max number of uids and gids */
+#define SQUASHFS_UIDS			256
+#define SQUASHFS_GUIDS			255
+
+/* Max length of filename (not 255) */
+#define SQUASHFS_NAME_LEN		256
+
+#define SQUASHFS_INVALID		((long long) 0xffffffffffff)
+#define SQUASHFS_INVALID_FRAG		((unsigned int) 0xffffffff)
+#define SQUASHFS_INVALID_BLK		((long long) -1)
+#define SQUASHFS_USED_BLK		((long long) -2)
+
+/* Filesystem flags */
+#define SQUASHFS_NOI			0
+#define SQUASHFS_NOD			1
+#define SQUASHFS_CHECK			2
+#define SQUASHFS_NOF			3
+#define SQUASHFS_NO_FRAG		4
+#define SQUASHFS_ALWAYS_FRAG		5
+#define SQUASHFS_DUPLICATE		6
+#define SQUASHFS_EXPORT			7
+
+#define SQUASHFS_BIT(flag, bit)		((flag >> bit) & 1)
+
+#define SQUASHFS_UNCOMPRESSED_INODES(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOI)
+
+#define SQUASHFS_UNCOMPRESSED_DATA(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOD)
+
+#define SQUASHFS_UNCOMPRESSED_FRAGMENTS(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOF)
+
+#define SQUASHFS_NO_FRAGMENTS(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_NO_FRAG)
+
+#define SQUASHFS_ALWAYS_FRAGMENTS(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_ALWAYS_FRAG)
+
+#define SQUASHFS_DUPLICATES(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_DUPLICATE)
+
+#define SQUASHFS_EXPORTABLE(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_EXPORT)
+
+#define SQUASHFS_CHECK_DATA(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_CHECK)
+
+#define SQUASHFS_MKFLAGS(noi, nod, check_data, nof, no_frag, always_frag, \
+		duplicate_checking, exortable)	(noi | (nod << 1) | (check_data << 2) \
+		| (nof << 3) | (no_frag << 4) | (always_frag << 5) | \
+		(duplicate_checking << 6) | (exportable << 7))
+
+/* Max number of types and file types */
+#define SQUASHFS_DIR_TYPE		1
+#define SQUASHFS_FILE_TYPE		2
+#define SQUASHFS_SYMLINK_TYPE		3
+#define SQUASHFS_BLKDEV_TYPE		4
+#define SQUASHFS_CHRDEV_TYPE		5
+#define SQUASHFS_FIFO_TYPE		6
+#define SQUASHFS_SOCKET_TYPE		7
+#define SQUASHFS_LDIR_TYPE		8
+#define SQUASHFS_LREG_TYPE		9
+
+/* 1.0 filesystem type definitions */
+#define SQUASHFS_TYPES			5
+#define SQUASHFS_IPC_TYPE		0
+
+/* Flag whether block is compressed or uncompressed, bit is set if block is
+ * uncompressed */
+#define SQUASHFS_COMPRESSED_BIT		(1 << 15)
+
+#define SQUASHFS_COMPRESSED_SIZE(B)	(((B) & ~SQUASHFS_COMPRESSED_BIT) ? \
+		(B) & ~SQUASHFS_COMPRESSED_BIT :  SQUASHFS_COMPRESSED_BIT)
+
+#define SQUASHFS_COMPRESSED(B)		(!((B) & SQUASHFS_COMPRESSED_BIT))
+
+#define SQUASHFS_COMPRESSED_BIT_BLOCK		(1 << 24)
+
+#define SQUASHFS_COMPRESSED_SIZE_BLOCK(B)	(((B) & \
+	~SQUASHFS_COMPRESSED_BIT_BLOCK) ? (B) & \
+	~SQUASHFS_COMPRESSED_BIT_BLOCK : SQUASHFS_COMPRESSED_BIT_BLOCK)
+
+#define SQUASHFS_COMPRESSED_BLOCK(B)	(!((B) & SQUASHFS_COMPRESSED_BIT_BLOCK))
+
+/*
+ * Inode number ops.  Inodes consist of a compressed block number, and an
+ * uncompressed  offset within that block
+ */
+#define SQUASHFS_INODE_BLK(a)		((unsigned int) ((a) >> 16))
+
+#define SQUASHFS_INODE_OFFSET(a)	((unsigned int) ((a) & 0xffff))
+
+#define SQUASHFS_MKINODE(A, B)		((squashfs_inode_t)(((squashfs_inode_t) (A)\
+					<< 16) + (B)))
+
+/* Compute 32 bit VFS inode number from squashfs inode number */
+#define SQUASHFS_MK_VFS_INODE(a, b)	((unsigned int) (((a) << 8) + \
+					((b) >> 2) + 1))
+/* XXX */
+
+/* Translate between VFS mode and squashfs mode */
+#define SQUASHFS_MODE(a)		((a) & 0xfff)
+
+/* fragment and fragment table defines */
+#define SQUASHFS_FRAGMENT_BYTES(A)	((A) * sizeof(struct squashfs_fragment_entry))
+
+#define SQUASHFS_FRAGMENT_INDEX(A)	(SQUASHFS_FRAGMENT_BYTES(A) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET(A)	(SQUASHFS_FRAGMENT_BYTES(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEXES(A)	((SQUASHFS_FRAGMENT_BYTES(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_BYTES(A)	(SQUASHFS_FRAGMENT_INDEXES(A) *\
+						sizeof(long long))
+
+/* inode lookup table defines */
+#define SQUASHFS_LOOKUP_BYTES(A)	((A) * sizeof(squashfs_inode_t))
+
+#define SQUASHFS_LOOKUP_BLOCK(A)		(SQUASHFS_LOOKUP_BYTES(A) / \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_LOOKUP_BLOCK_OFFSET(A)		(SQUASHFS_LOOKUP_BYTES(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_LOOKUP_BLOCKS(A)	((SQUASHFS_LOOKUP_BYTES(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_LOOKUP_BLOCK_BYTES(A)	(SQUASHFS_LOOKUP_BLOCKS(A) *\
+					sizeof(long long))
+
+/* cached data constants for filesystem */
+#define SQUASHFS_CACHED_BLKS		8
+
+#define SQUASHFS_MAX_FILE_SIZE_LOG	64
+
+#define SQUASHFS_MAX_FILE_SIZE		((long long) 1 << \
+					(SQUASHFS_MAX_FILE_SIZE_LOG - 2))
+
+#define SQUASHFS_MARKER_BYTE		0xff
+
+/* meta index cache */
+#define SQUASHFS_META_INDEXES	(SQUASHFS_METADATA_SIZE / sizeof(unsigned int))
+#define SQUASHFS_META_ENTRIES	31
+#define SQUASHFS_META_NUMBER	8
+#define SQUASHFS_SLOTS		4
+
+struct meta_entry {
+	long long		data_block;
+	unsigned int		index_block;
+	unsigned short		offset;
+	unsigned short		pad;
+};
+
+struct meta_index {
+	unsigned int		inode_number;
+	unsigned int		offset;
+	unsigned short		entries;
+	unsigned short		skip;
+	unsigned short		locked;
+	unsigned short		pad;
+	struct meta_entry	meta_entry[SQUASHFS_META_ENTRIES];
+};
+
+
+/*
+ * definitions for structures on disk
+ */
+
+typedef long long		squashfs_block_t;
+typedef long long		squashfs_inode_t;
+
+struct squashfs_super_block {
+	unsigned int		s_magic;
+	unsigned int		inodes;
+	unsigned int		bytes_used_2;
+	unsigned int		uid_start_2;
+	unsigned int		guid_start_2;
+	unsigned int		inode_table_start_2;
+	unsigned int		directory_table_start_2;
+	unsigned int		s_major:16;
+	unsigned int		s_minor:16;
+	unsigned int		block_size_1:16;
+	unsigned int		block_log:16;
+	unsigned int		flags:8;
+	unsigned int		no_uids:8;
+	unsigned int		no_guids:8;
+	unsigned int		mkfs_time /* time of filesystem creation */;
+	squashfs_inode_t	root_inode;
+	unsigned int		block_size;
+	unsigned int		fragments;
+	unsigned int		fragment_table_start_2;
+	long long		bytes_used;
+	long long		uid_start;
+	long long		guid_start;
+	long long		inode_table_start;
+	long long		directory_table_start;
+	long long		fragment_table_start;
+	long long		lookup_table_start;
+} __attribute__ ((packed));
+
+struct squashfs_dir_index {
+	unsigned int		index;
+	unsigned int		start_block;
+	unsigned char		size;
+	unsigned char		name[0];
+} __attribute__ ((packed));
+
+#define SQUASHFS_BASE_INODE_HEADER		\
+	unsigned int		inode_type:4;	\
+	unsigned int		mode:12;	\
+	unsigned int		uid:8;		\
+	unsigned int		guid:8;		\
+	unsigned int		mtime;		\
+	unsigned int 		inode_number;
+
+struct squashfs_base_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	squashfs_block_t	start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	unsigned int		file_size;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_lreg_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	squashfs_block_t	start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	long long		file_size;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		start_block;
+	unsigned int		parent_inode;
+} __attribute__  ((packed));
+
+struct squashfs_ldir_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	unsigned int		file_size:27;
+	unsigned int		offset:13;
+	unsigned int		start_block;
+	unsigned int		i_count:16;
+	unsigned int		parent_inode;
+	struct squashfs_dir_index	index[0];
+} __attribute__  ((packed));
+
+union squashfs_inode_header {
+	struct squashfs_base_inode_header	base;
+	struct squashfs_dev_inode_header	dev;
+	struct squashfs_symlink_inode_header	symlink;
+	struct squashfs_reg_inode_header	reg;
+	struct squashfs_lreg_inode_header	lreg;
+	struct squashfs_dir_inode_header	dir;
+	struct squashfs_ldir_inode_header	ldir;
+	struct squashfs_ipc_inode_header	ipc;
+};
+	
+struct squashfs_dir_entry {
+	unsigned int		offset:13;
+	unsigned int		type:3;
+	unsigned int		size:8;
+	int			inode_number:16;
+	char			name[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_header {
+	unsigned int		count:8;
+	unsigned int		start_block;
+	unsigned int		inode_number;
+} __attribute__ ((packed));
+
+struct squashfs_fragment_entry {
+	long long		start_block;
+	unsigned int		size;
+	unsigned int		pending;
+} __attribute__ ((packed));
+
+extern int squashfs_uncompress_block(void *d, int dstlen, void *s, int srclen);
+extern int squashfs_uncompress_init(void);
+extern int squashfs_uncompress_exit(void);
+
+/*
+ * macros to convert each packed bitfield structure from little endian to big
+ * endian and vice versa.  These are needed when creating or using a filesystem
+ * on a machine with different byte ordering to the target architecture.
+ *
+ */
+
+#define SQUASHFS_SWAP_START \
+	int bits;\
+	int b_pos;\
+	unsigned long long val;\
+	unsigned char *s;\
+	unsigned char *d;
+
+#define SQUASHFS_SWAP_SUPER_BLOCK(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_super_block));\
+	SQUASHFS_SWAP((s)->s_magic, d, 0, 32);\
+	SQUASHFS_SWAP((s)->inodes, d, 32, 32);\
+	SQUASHFS_SWAP((s)->bytes_used_2, d, 64, 32);\
+	SQUASHFS_SWAP((s)->uid_start_2, d, 96, 32);\
+	SQUASHFS_SWAP((s)->guid_start_2, d, 128, 32);\
+	SQUASHFS_SWAP((s)->inode_table_start_2, d, 160, 32);\
+	SQUASHFS_SWAP((s)->directory_table_start_2, d, 192, 32);\
+	SQUASHFS_SWAP((s)->s_major, d, 224, 16);\
+	SQUASHFS_SWAP((s)->s_minor, d, 240, 16);\
+	SQUASHFS_SWAP((s)->block_size_1, d, 256, 16);\
+	SQUASHFS_SWAP((s)->block_log, d, 272, 16);\
+	SQUASHFS_SWAP((s)->flags, d, 288, 8);\
+	SQUASHFS_SWAP((s)->no_uids, d, 296, 8);\
+	SQUASHFS_SWAP((s)->no_guids, d, 304, 8);\
+	SQUASHFS_SWAP((s)->mkfs_time, d, 312, 32);\
+	SQUASHFS_SWAP((s)->root_inode, d, 344, 64);\
+	SQUASHFS_SWAP((s)->block_size, d, 408, 32);\
+	SQUASHFS_SWAP((s)->fragments, d, 440, 32);\
+	SQUASHFS_SWAP((s)->fragment_table_start_2, d, 472, 32);\
+	SQUASHFS_SWAP((s)->bytes_used, d, 504, 64);\
+	SQUASHFS_SWAP((s)->uid_start, d, 568, 64);\
+	SQUASHFS_SWAP((s)->guid_start, d, 632, 64);\
+	SQUASHFS_SWAP((s)->inode_table_start, d, 696, 64);\
+	SQUASHFS_SWAP((s)->directory_table_start, d, 760, 64);\
+	SQUASHFS_SWAP((s)->fragment_table_start, d, 824, 64);\
+	SQUASHFS_SWAP((s)->lookup_table_start, d, 888, 64);\
+}
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE(s, d, n)\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 8);\
+	SQUASHFS_SWAP((s)->guid, d, 24, 8);\
+	SQUASHFS_SWAP((s)->mtime, d, 32, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 64, 32);
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_ipc_inode_header))\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+}
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_dev_inode_header)); \
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->rdev, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_symlink_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->symlink_size, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_reg_inode_header));\
+	SQUASHFS_SWAP((s)->start_block, d, 96, 64);\
+	SQUASHFS_SWAP((s)->fragment, d, 160, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 192, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 224, 32);\
+}
+
+#define SQUASHFS_SWAP_LREG_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_lreg_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 128, 64);\
+	SQUASHFS_SWAP((s)->fragment, d, 192, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 224, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 256, 64);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_dir_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 128, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 147, 13);\
+	SQUASHFS_SWAP((s)->start_block, d, 160, 32);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 192, 32);\
+}
+
+#define SQUASHFS_SWAP_LDIR_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_ldir_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 128, 27);\
+	SQUASHFS_SWAP((s)->offset, d, 155, 13);\
+	SQUASHFS_SWAP((s)->start_block, d, 168, 32);\
+	SQUASHFS_SWAP((s)->i_count, d, 200, 16);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 216, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INDEX(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index));\
+	SQUASHFS_SWAP((s)->index, d, 0, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 32, 32);\
+	SQUASHFS_SWAP((s)->size, d, 64, 8);\
+}
+
+#define SQUASHFS_SWAP_DIR_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header));\
+	SQUASHFS_SWAP((s)->count, d, 0, 8);\
+	SQUASHFS_SWAP((s)->start_block, d, 8, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 40, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_ENTRY(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry));\
+	SQUASHFS_SWAP((s)->offset, d, 0, 13);\
+	SQUASHFS_SWAP((s)->type, d, 13, 3);\
+	SQUASHFS_SWAP((s)->size, d, 16, 8);\
+	SQUASHFS_SWAP((s)->inode_number, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_ENTRY(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 64);\
+	SQUASHFS_SWAP((s)->size, d, 64, 32);\
+}
+
+#define SQUASHFS_SWAP_INODE_T(s, d) SQUASHFS_SWAP_LONG_LONGS(s, d, 1)
+
+#define SQUASHFS_SWAP_SHORTS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 2);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			16)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 16);\
+}
+
+#define SQUASHFS_SWAP_INTS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 4);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			32)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 32);\
+}
+
+#define SQUASHFS_SWAP_LONG_LONGS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 8);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			64)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 64);\
+}
+
+#define SQUASHFS_SWAP_DATA(s, d, n, bits) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * bits / 8);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			bits)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, bits);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES(s, d, n) SQUASHFS_SWAP_LONG_LONGS(s, d, n)
+#define SQUASHFS_SWAP_LOOKUP_BLOCKS(s, d, n) SQUASHFS_SWAP_LONG_LONGS(s, d, n)
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+
+struct squashfs_base_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		type:4;
+	unsigned int		offset:4;
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		mtime;
+	unsigned int		start_block;
+	unsigned int		file_size:32;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header_1 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:4; /* index into uid table */
+	unsigned int		guid:4; /* index into guid table */
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+} __attribute__  ((packed));
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, n) \
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 4);\
+	SQUASHFS_SWAP((s)->guid, d, 20, 4);
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_ipc_inode_header_1));\
+	SQUASHFS_SWAP((s)->type, d, 24, 4);\
+	SQUASHFS_SWAP((s)->offset, d, 28, 4);\
+}
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_dev_inode_header_1));\
+	SQUASHFS_SWAP((s)->rdev, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_symlink_inode_header_1));\
+	SQUASHFS_SWAP((s)->symlink_size, d, 24, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_reg_inode_header_1));\
+	SQUASHFS_SWAP((s)->mtime, d, 24, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 56, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 88, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER_1(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_dir_inode_header_1));\
+	SQUASHFS_SWAP((s)->file_size, d, 24, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 43, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 56, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 88, 24);\
+}
+
+#endif
+
+#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+
+struct squashfs_dir_index_2 {
+	unsigned int		index:27;
+	unsigned int		start_block:29;
+	unsigned char		size;
+	unsigned char		name[0];
+} __attribute__ ((packed));
+
+struct squashfs_base_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		mtime;
+	unsigned int		start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	unsigned int		file_size:32;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+} __attribute__  ((packed));
+
+struct squashfs_ldir_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:27;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+	unsigned int		i_count:16;
+	struct squashfs_dir_index_2	index[0];
+} __attribute__  ((packed));
+
+union squashfs_inode_header_2 {
+	struct squashfs_base_inode_header_2	base;
+	struct squashfs_dev_inode_header_2	dev;
+	struct squashfs_symlink_inode_header_2	symlink;
+	struct squashfs_reg_inode_header_2	reg;
+	struct squashfs_dir_inode_header_2	dir;
+	struct squashfs_ldir_inode_header_2	ldir;
+	struct squashfs_ipc_inode_header_2	ipc;
+};
+	
+struct squashfs_dir_header_2 {
+	unsigned int		count:8;
+	unsigned int		start_block:24;
+} __attribute__ ((packed));
+
+struct squashfs_dir_entry_2 {
+	unsigned int		offset:13;
+	unsigned int		type:3;
+	unsigned int		size:8;
+	char			name[0];
+} __attribute__ ((packed));
+
+struct squashfs_fragment_entry_2 {
+	unsigned int		start_block;
+	unsigned int		size;
+} __attribute__ ((packed));
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, n)\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 8);\
+	SQUASHFS_SWAP((s)->guid, d, 24, 8);\
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_2(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER_2(s, d) \
+	SQUASHFS_SWAP_BASE_INODE_HEADER_2(s, d, sizeof(struct squashfs_ipc_inode_header_2))
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_dev_inode_header_2)); \
+	SQUASHFS_SWAP((s)->rdev, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_symlink_inode_header_2));\
+	SQUASHFS_SWAP((s)->symlink_size, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_reg_inode_header_2));\
+	SQUASHFS_SWAP((s)->mtime, d, 32, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 64, 32);\
+	SQUASHFS_SWAP((s)->fragment, d, 96, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 128, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 160, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_dir_inode_header_2));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 51, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 64, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 96, 24);\
+}
+
+#define SQUASHFS_SWAP_LDIR_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_ldir_inode_header_2));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 27);\
+	SQUASHFS_SWAP((s)->offset, d, 59, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 72, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 104, 24);\
+	SQUASHFS_SWAP((s)->i_count, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_DIR_INDEX_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index_2));\
+	SQUASHFS_SWAP((s)->index, d, 0, 27);\
+	SQUASHFS_SWAP((s)->start_block, d, 27, 29);\
+	SQUASHFS_SWAP((s)->size, d, 56, 8);\
+}
+#define SQUASHFS_SWAP_DIR_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header_2));\
+	SQUASHFS_SWAP((s)->count, d, 0, 8);\
+	SQUASHFS_SWAP((s)->start_block, d, 8, 24);\
+}
+
+#define SQUASHFS_SWAP_DIR_ENTRY_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry_2));\
+	SQUASHFS_SWAP((s)->offset, d, 0, 13);\
+	SQUASHFS_SWAP((s)->type, d, 13, 3);\
+	SQUASHFS_SWAP((s)->size, d, 16, 8);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_ENTRY_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry_2));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 32);\
+	SQUASHFS_SWAP((s)->size, d, 32, 32);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES_2(s, d, n) SQUASHFS_SWAP_INTS(s, d, n)
+
+/* fragment and fragment table defines */
+#define SQUASHFS_FRAGMENT_BYTES_2(A)	(A * sizeof(struct squashfs_fragment_entry_2))
+
+#define SQUASHFS_FRAGMENT_INDEX_2(A)	(SQUASHFS_FRAGMENT_BYTES_2(A) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET_2(A)	(SQUASHFS_FRAGMENT_BYTES_2(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEXES_2(A)	((SQUASHFS_FRAGMENT_BYTES_2(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_BYTES_2(A)	(SQUASHFS_FRAGMENT_INDEXES_2(A) *\
+						sizeof(int))
+
+#endif
+
+#ifdef __KERNEL__
+
+/*
+ * macros used to swap each structure entry, taking into account
+ * bitfields and different bitfield placing conventions on differing
+ * architectures
+ */
+
+#include <asm/byteorder.h>
+
+#ifdef __BIG_ENDIAN
+	/* convert from little endian to big endian */
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, \
+		tbits, b_pos)
+#else
+	/* convert from big endian to little endian */ 
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, \
+		tbits, 64 - tbits - b_pos)
+#endif
+
+#define _SQUASHFS_SWAP(value, p, pos, tbits, SHIFT) {\
+	b_pos = pos % 8;\
+	val = 0;\
+	s = (unsigned char *)p + (pos / 8);\
+	d = ((unsigned char *) &val) + 7;\
+	for(bits = 0; bits < (tbits + b_pos); bits += 8) \
+		*d-- = *s++;\
+	value = (val >> (SHIFT))/* & ((1 << tbits) - 1)*/;\
+}
+
+#define SQUASHFS_MEMSET(s, d, n)	memset(s, 0, n);
+
+#endif
+#endif
Index: linux-2.6.21/include/linux/squashfs_fs_i.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/linux/squashfs_fs_i.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,45 @@
+#ifndef SQUASHFS_FS_I
+#define SQUASHFS_FS_I
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs_i.h
+ */
+
+struct squashfs_inode_info {
+	long long	start_block;
+	unsigned int	offset;
+	union {
+		struct {
+			long long	fragment_start_block;
+			unsigned int	fragment_size;
+			unsigned int	fragment_offset;
+			long long	block_list_start;
+		} s1;
+		struct {
+			long long	directory_index_start;
+			unsigned int	directory_index_offset;
+			unsigned int	directory_index_count;
+			unsigned int	parent_inode;
+		} s2;
+	} u;
+	struct inode	vfs_inode;
+};
+#endif
Index: linux-2.6.21/include/linux/squashfs_fs_sb.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/linux/squashfs_fs_sb.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,74 @@
+#ifndef SQUASHFS_FS_SB
+#define SQUASHFS_FS_SB
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_fs_sb.h
+ */
+
+#include <linux/squashfs_fs.h>
+#include "sqlzma.h"
+
+struct squashfs_cache {
+	long long	block;
+	int		length;
+	long long	next_index;
+	char		*data;
+};
+
+struct squashfs_fragment_cache {
+	long long	block;
+	int		length;
+	unsigned int	locked;
+	char		*data;
+};
+
+struct squashfs_sb_info {
+	struct squashfs_super_block	sblk;
+	int			devblksize;
+	int			devblksize_log2;
+	int			swap;
+	struct squashfs_cache	*block_cache;
+	struct squashfs_fragment_cache	*fragment;
+	int			next_cache;
+	int			next_fragment;
+	int			next_meta_index;
+	unsigned int		*uid;
+	unsigned int		*guid;
+	long long		*fragment_index;
+	unsigned int		*fragment_index_2;
+	char			*read_page;
+	//struct mutex		read_data_mutex;
+	struct mutex		read_page_mutex;
+	struct mutex		block_cache_mutex;
+	struct mutex		fragment_mutex;
+	struct mutex		meta_index_mutex;
+	wait_queue_head_t	waitq;
+	wait_queue_head_t	fragment_wait_queue;
+	struct meta_index	*meta_index;
+	long long		*inode_lookup_table;
+	int			(*read_inode)(struct inode *i,  squashfs_inode_t \
+				inode);
+	long long		(*read_blocklist)(struct inode *inode, int \
+				index, int readahead_blks, char *block_list, \
+				unsigned short **block_p, unsigned int *bsize);
+	int			(*read_fragment_index_table)(struct super_block *s);
+};
+#endif
Index: linux-2.6.21/include/linux/swap.h
===================================================================
--- linux-2.6.21.orig/include/linux/swap.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/swap.h	2009-11-30 12:44:56.000000000 +0100
@@ -31,7 +31,7 @@
  * on 32-bit-pgoff_t architectures.  And that assumes that the architecture packs
  * the type/offset into the pte as 5/27 as well.
  */
-#define MAX_SWAPFILES_SHIFT	5
+#define MAX_SWAPFILES_SHIFT	CONFIG_MAX_SWAPFILES_SHIFT
 #ifndef CONFIG_MIGRATION
 #define MAX_SWAPFILES		(1 << MAX_SWAPFILES_SHIFT)
 #else
Index: linux-2.6.21/include/linux/swapops.h
===================================================================
--- linux-2.6.21.orig/include/linux/swapops.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/swapops.h	2009-11-30 12:44:56.000000000 +0100
@@ -12,6 +12,7 @@
 #define SWP_TYPE_SHIFT(e)	(sizeof(e.val) * 8 - MAX_SWAPFILES_SHIFT)
 #define SWP_OFFSET_MASK(e)	((1UL << SWP_TYPE_SHIFT(e)) - 1)
 
+#if MAX_SWAPFILES_SHIFT > 0
 /*
  * Store a type+offset into a swp_entry_t in an arch-independent format
  */
@@ -41,6 +42,26 @@
 {
 	return entry.val & SWP_OFFSET_MASK(entry);
 }
+#else /* avoid undefined shift operations */
+
+static inline swp_entry_t swp_entry(unsigned type, pgoff_t offset)
+{
+	swp_entry_t ret;
+	ret.val = offset;
+	return ret;
+}
+
+static inline unsigned swp_type(swp_entry_t entry)
+{
+	return 0;
+}
+
+static inline pgoff_t swp_offset(swp_entry_t entry)
+{
+	return entry.val;
+}
+
+#endif
 
 /*
  * Convert the arch-dependent pte representation of a swp_entry_t into an
Index: linux-2.6.21/include/linux/tty.h
===================================================================
--- linux-2.6.21.orig/include/linux/tty.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/tty.h	2009-11-30 12:44:56.000000000 +0100
@@ -24,7 +24,7 @@
 #define NR_PTYS	CONFIG_LEGACY_PTY_COUNT   /* Number of legacy ptys */
 #define NR_UNIX98_PTY_DEFAULT	4096      /* Default maximum for Unix98 ptys */
 #define NR_UNIX98_PTY_MAX	(1 << MINORBITS) /* Absolute limit */
-#define NR_LDISCS		17
+#define NR_LDISCS		CONFIG_NR_LDISCS
 
 /* line disciplines */
 #define N_TTY		0
Index: linux-2.6.21/include/linux/usb_ch9.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/linux/usb_ch9.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,384 @@
+/*
+ * This file holds USB constants and structures that are needed for USB
+ * device APIs.  These are used by the USB device model, which is defined
+ * in chapter 9 of the USB 2.0 specification.  Linux has several APIs in C
+ * that need these:
+ *
+ * - the master/host side Linux-USB kernel driver API;
+ * - the "usbfs" user space API; and
+ * - (eventually) a Linux "gadget" slave/device side driver API.
+ *
+ * USB 2.0 adds an additional "On The Go" (OTG) mode, which lets systems
+ * act either as a USB master/host or as a USB slave/device.  That means
+ * the master and slave side APIs will benefit from working well together.
+ */
+
+#ifndef __LINUX_USB_CH9_H
+#define __LINUX_USB_CH9_H
+
+#include <asm/types.h>		/* __u8 etc */
+
+/*-------------------------------------------------------------------------*/
+
+/* CONTROL REQUEST SUPPORT */
+
+/*
+ * USB directions
+ *
+ * This bit flag is used in endpoint descriptors' bEndpointAddress field.
+ * It's also one of three fields in control requests bRequestType.
+ */
+#define USB_DIR_OUT			0		/* to device */
+#define USB_DIR_IN			0x80		/* to host */
+
+/*
+ * USB types, the second of three bRequestType fields
+ */
+#define USB_TYPE_MASK			(0x03 << 5)
+#define USB_TYPE_STANDARD		(0x00 << 5)
+#define USB_TYPE_CLASS			(0x01 << 5)
+#define USB_TYPE_VENDOR			(0x02 << 5)
+#define USB_TYPE_RESERVED		(0x03 << 5)
+
+/*
+ * USB recipients, the third of three bRequestType fields
+ */
+#define USB_RECIP_MASK			0x1f
+#define USB_RECIP_DEVICE		0x00
+#define USB_RECIP_INTERFACE		0x01
+#define USB_RECIP_ENDPOINT		0x02
+#define USB_RECIP_OTHER			0x03
+
+/*
+ * Standard requests, for the bRequest field of a SETUP packet.
+ *
+ * These are qualified by the bRequestType field, so that for example
+ * TYPE_CLASS or TYPE_VENDOR specific feature flags could be retrieved
+ * by a GET_STATUS request.
+ */
+#define USB_REQ_GET_STATUS		0x00
+#define USB_REQ_CLEAR_FEATURE		0x01
+#define USB_REQ_SET_FEATURE		0x03
+#define USB_REQ_SET_ADDRESS		0x05
+#define USB_REQ_GET_DESCRIPTOR		0x06
+#define USB_REQ_SET_DESCRIPTOR		0x07
+#define USB_REQ_GET_CONFIGURATION	0x08
+#define USB_REQ_SET_CONFIGURATION	0x09
+#define USB_REQ_GET_INTERFACE		0x0A
+#define USB_REQ_SET_INTERFACE		0x0B
+#define USB_REQ_SYNCH_FRAME		0x0C
+
+/*
+ * USB feature flags are written using USB_REQ_{CLEAR,SET}_FEATURE, and
+ * are read as a bit array returned by USB_REQ_GET_STATUS.  (So there
+ * are at most sixteen features of each type.)
+ */
+#define USB_DEVICE_SELF_POWERED		0	/* (read only) */
+#define USB_DEVICE_REMOTE_WAKEUP	1	/* dev may initiate wakeup */
+#define USB_DEVICE_TEST_MODE		2	/* (high speed only) */
+#define USB_DEVICE_B_HNP_ENABLE		3	/* dev may initiate HNP */
+#define USB_DEVICE_A_HNP_SUPPORT	4	/* RH port supports HNP */
+#define USB_DEVICE_A_ALT_HNP_SUPPORT	5	/* other RH port does */
+#define USB_DEVICE_DEBUG_MODE		6	/* (special devices only) */
+
+#define USB_ENDPOINT_HALT		0	/* IN/OUT will STALL */
+
+
+/**
+ * struct usb_ctrlrequest - SETUP data for a USB device control request
+ * @bRequestType: matches the USB bmRequestType field
+ * @bRequest: matches the USB bRequest field
+ * @wValue: matches the USB wValue field (le16 byte order)
+ * @wIndex: matches the USB wIndex field (le16 byte order)
+ * @wLength: matches the USB wLength field (le16 byte order)
+ *
+ * This structure is used to send control requests to a USB device.  It matches
+ * the different fields of the USB 2.0 Spec section 9.3, table 9-2.  See the
+ * USB spec for a fuller description of the different fields, and what they are
+ * used for.
+ *
+ * Note that the driver for any interface can issue control requests.
+ * For most devices, interfaces don't coordinate with each other, so
+ * such requests may be made at any time.
+ */
+struct usb_ctrlrequest {
+	__u8 bRequestType;
+	__u8 bRequest;
+	__le16 wValue;
+	__le16 wIndex;
+	__le16 wLength;
+} __attribute__ ((packed));
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * STANDARD DESCRIPTORS ... as returned by GET_DESCRIPTOR, or
+ * (rarely) accepted by SET_DESCRIPTOR.
+ *
+ * Note that all multi-byte values here are encoded in little endian
+ * byte order "on the wire".  But when exposed through Linux-USB APIs,
+ * they've been converted to cpu byte order.
+ */
+
+/*
+ * Descriptor types ... USB 2.0 spec table 9.5
+ */
+#define USB_DT_DEVICE			0x01
+#define USB_DT_CONFIG			0x02
+#define USB_DT_STRING			0x03
+#define USB_DT_INTERFACE		0x04
+#define USB_DT_ENDPOINT			0x05
+#define USB_DT_DEVICE_QUALIFIER		0x06
+#define USB_DT_OTHER_SPEED_CONFIG	0x07
+#define USB_DT_INTERFACE_POWER		0x08
+/* these are from a minor usb 2.0 revision (ECN) */
+#define USB_DT_OTG			0x09
+#define USB_DT_DEBUG			0x0a
+#define USB_DT_INTERFACE_ASSOCIATION	0x0b
+
+/* conventional codes for class-specific descriptors */
+#define USB_DT_CS_DEVICE		0x21
+#define USB_DT_CS_CONFIG		0x22
+#define USB_DT_CS_STRING		0x23
+#define USB_DT_CS_INTERFACE		0x24
+#define USB_DT_CS_ENDPOINT		0x25
+
+/* All standard descriptors have these 2 fields at the beginning */
+struct usb_descriptor_header {
+	__u8  bLength;
+	__u8  bDescriptorType;
+} __attribute__ ((packed));
+
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_DEVICE: Device descriptor */
+struct usb_device_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__le16 bcdUSB;
+	__u8  bDeviceClass;
+	__u8  bDeviceSubClass;
+	__u8  bDeviceProtocol;
+	__u8  bMaxPacketSize0;
+	__le16 idVendor;
+	__le16 idProduct;
+	__le16 bcdDevice;
+	__u8  iManufacturer;
+	__u8  iProduct;
+	__u8  iSerialNumber;
+	__u8  bNumConfigurations;
+} __attribute__ ((packed));
+
+#define USB_DT_DEVICE_SIZE		18
+
+
+/*
+ * Device and/or Interface Class codes
+ * as found in bDeviceClass or bInterfaceClass
+ * and defined by www.usb.org documents
+ */
+#define USB_CLASS_PER_INTERFACE		0	/* for DeviceClass */
+#define USB_CLASS_AUDIO			1
+#define USB_CLASS_COMM			2
+#define USB_CLASS_HID			3
+#define USB_CLASS_PHYSICAL		5
+#define USB_CLASS_STILL_IMAGE		6
+#define USB_CLASS_PRINTER		7
+#define USB_CLASS_MASS_STORAGE		8
+#define USB_CLASS_HUB			9
+#define USB_CLASS_CDC_DATA		0x0a
+#define USB_CLASS_CSCID			0x0b	/* chip+ smart card */
+#define USB_CLASS_CONTENT_SEC		0x0d	/* content security */
+#define USB_CLASS_VIDEO			0x0e
+#define USB_CLASS_APP_SPEC		0xfe
+#define USB_CLASS_VENDOR_SPEC		0xff
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_CONFIG: Configuration descriptor information.
+ *
+ * USB_DT_OTHER_SPEED_CONFIG is the same descriptor, except that the
+ * descriptor type is different.  Highspeed-capable devices can look
+ * different depending on what speed they're currently running.  Only
+ * devices with a USB_DT_DEVICE_QUALIFIER have any OTHER_SPEED_CONFIG
+ * descriptors.
+ */
+struct usb_config_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__le16 wTotalLength;
+	__u8  bNumInterfaces;
+	__u8  bConfigurationValue;
+	__u8  iConfiguration;
+	__u8  bmAttributes;
+	__u8  bMaxPower;
+} __attribute__ ((packed));
+
+#define USB_DT_CONFIG_SIZE		9
+
+/* from config descriptor bmAttributes */
+#define USB_CONFIG_ATT_ONE		(1 << 7)	/* must be set */
+#define USB_CONFIG_ATT_SELFPOWER	(1 << 6)	/* self powered */
+#define USB_CONFIG_ATT_WAKEUP		(1 << 5)	/* can wakeup */
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_STRING: String descriptor */
+struct usb_string_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__le16 wData[1];		/* UTF-16LE encoded */
+} __attribute__ ((packed));
+
+/* note that "string" zero is special, it holds language codes that
+ * the device supports, not Unicode characters.
+ */
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_INTERFACE: Interface descriptor */
+struct usb_interface_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  bInterfaceNumber;
+	__u8  bAlternateSetting;
+	__u8  bNumEndpoints;
+	__u8  bInterfaceClass;
+	__u8  bInterfaceSubClass;
+	__u8  bInterfaceProtocol;
+	__u8  iInterface;
+} __attribute__ ((packed));
+
+#define USB_DT_INTERFACE_SIZE		9
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_ENDPOINT: Endpoint descriptor */
+struct usb_endpoint_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  bEndpointAddress;
+	__u8  bmAttributes;
+	__le16 wMaxPacketSize;
+	__u8  bInterval;
+
+	// NOTE:  these two are _only_ in audio endpoints.
+	// use USB_DT_ENDPOINT*_SIZE in bLength, not sizeof.
+	__u8  bRefresh;
+	__u8  bSynchAddress;
+} __attribute__ ((packed));
+
+#define USB_DT_ENDPOINT_SIZE		7
+#define USB_DT_ENDPOINT_AUDIO_SIZE	9	/* Audio extension */
+
+
+/*
+ * Endpoints
+ */
+#define USB_ENDPOINT_NUMBER_MASK	0x0f	/* in bEndpointAddress */
+#define USB_ENDPOINT_DIR_MASK		0x80
+
+#define USB_ENDPOINT_XFERTYPE_MASK	0x03	/* in bmAttributes */
+#define USB_ENDPOINT_XFER_CONTROL	0
+#define USB_ENDPOINT_XFER_ISOC		1
+#define USB_ENDPOINT_XFER_BULK		2
+#define USB_ENDPOINT_XFER_INT		3
+
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_DEVICE_QUALIFIER: Device Qualifier descriptor */
+struct usb_qualifier_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__le16 bcdUSB;
+	__u8  bDeviceClass;
+	__u8  bDeviceSubClass;
+	__u8  bDeviceProtocol;
+	__u8  bMaxPacketSize0;
+	__u8  bNumConfigurations;
+	__u8  bRESERVED;
+} __attribute__ ((packed));
+
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_OTG (from OTG 1.0a supplement) */
+struct usb_otg_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  bmAttributes;	/* support for HNP, SRP, etc */
+} __attribute__ ((packed));
+
+/* from usb_otg_descriptor.bmAttributes */
+#define USB_OTG_SRP		(1 << 0)
+#define USB_OTG_HNP		(1 << 1)	/* swap host/device roles */
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_DEBUG:  for special highspeed devices, replacing serial console */
+struct usb_debug_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	/* bulk endpoints with 8 byte maxpacket */
+	__u8  bDebugInEndpoint;
+	__u8  bDebugOutEndpoint;
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* USB_DT_INTERFACE_ASSOCIATION: groups interfaces */
+struct usb_interface_assoc_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+
+	__u8  bFirstInterface;
+	__u8  bInterfaceCount;
+	__u8  bFunctionClass;
+	__u8  bFunctionSubClass;
+	__u8  bFunctionProtocol;
+	__u8  iFunction;
+} __attribute__ ((packed));
+
+
+/*-------------------------------------------------------------------------*/
+
+/* USB 2.0 defines three speeds, here's how Linux identifies them */
+
+enum usb_device_speed {
+	USB_SPEED_UNKNOWN = 0,			/* enumerating */
+	USB_SPEED_LOW, USB_SPEED_FULL,		/* usb 1.1 */
+	USB_SPEED_HIGH				/* usb 2.0 */
+};
+
+enum usb_device_state {
+	/* NOTATTACHED isn't in the USB spec, and this state acts
+	 * the same as ATTACHED ... but it's clearer this way.
+	 */
+	USB_STATE_NOTATTACHED = 0,
+
+	/* the chapter 9 device states */
+	USB_STATE_ATTACHED,
+	USB_STATE_POWERED,
+	USB_STATE_DEFAULT,			/* limited function */
+	USB_STATE_ADDRESS,
+	USB_STATE_CONFIGURED,			/* most functions */
+
+	USB_STATE_SUSPENDED
+
+	/* NOTE:  there are actually four different SUSPENDED
+	 * states, returning to POWERED, DEFAULT, ADDRESS, or
+	 * CONFIGURED respectively when SOF tokens flow again.
+	 */
+};
+
+#endif	/* __LINUX_USB_CH9_H */
Index: linux-2.6.21/include/linux/usb_gadget.h
===================================================================
--- linux-2.6.21.orig/include/linux/usb_gadget.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/usb_gadget.h	2009-11-30 12:44:56.000000000 +0100
@@ -457,6 +457,7 @@
 	int	(*pullup) (struct usb_gadget *, int is_on);
 	int	(*ioctl)(struct usb_gadget *,
 				unsigned code, unsigned long param);
+	int     (*lpm_support) (struct usb_gadget *);
 };
 
 /**
Index: linux-2.6.21/include/linux/xattr.h
===================================================================
--- linux-2.6.21.orig/include/linux/xattr.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/xattr.h	2009-11-30 12:44:56.000000000 +0100
@@ -51,10 +51,17 @@
 int vfs_setxattr(struct dentry *, char *, void *, size_t, int);
 int vfs_removexattr(struct dentry *, char *);
 
+#ifdef CONFIG_XATTR
 ssize_t generic_getxattr(struct dentry *dentry, const char *name, void *buffer, size_t size);
 ssize_t generic_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size);
 int generic_setxattr(struct dentry *dentry, const char *name, const void *value, size_t size, int flags);
 int generic_removexattr(struct dentry *dentry, const char *name);
+#else
+#define generic_getxattr NULL
+#define generic_listxattr NULL
+#define generic_setxattr NULL
+#define generic_removexattr NULL
+#endif
 
 #endif  /*  __KERNEL__  */
 
Index: linux-2.6.21/include/linux/zconf.h
===================================================================
--- linux-2.6.21.orig/include/linux/zconf.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/linux/zconf.h	2009-11-30 12:44:56.000000000 +0100
@@ -3,7 +3,7 @@
  * For conditions of distribution and use, see copyright notice in zlib.h 
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id: zconf.h,v 1.1.1.1 2007-05-25 06:50:12 bruce Exp $ */
 
 #ifndef _ZCONF_H
 #define _ZCONF_H
Index: linux-2.6.21/include/net/af_unix.h
===================================================================
--- linux-2.6.21.orig/include/net/af_unix.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/net/af_unix.h	2009-11-30 12:44:56.000000000 +0100
@@ -10,7 +10,11 @@
 extern void unix_notinflight(struct file *fp);
 extern void unix_gc(void);
 
+#ifdef CONFIG_NET_SMALL
+#define UNIX_HASH_SIZE	16
+#else
 #define UNIX_HASH_SIZE	256
+#endif
 
 extern struct hlist_head unix_socket_table[UNIX_HASH_SIZE + 1];
 extern spinlock_t unix_table_lock;
Index: linux-2.6.21/include/net/inetpeer.h
===================================================================
--- linux-2.6.21.orig/include/net/inetpeer.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/net/inetpeer.h	2009-11-30 12:44:56.000000000 +0100
@@ -1,7 +1,7 @@
 /*
  *		INETPEER - A storage for permanent information about peers
  *
- *  Version:	$Id: inetpeer.h,v 1.2 2002/01/12 07:54:56 davem Exp $
+ *  Version:	$Id: inetpeer.h,v 1.2 2008-08-15 07:51:49 winfred Exp $
  *
  *  Authors:	Andrey V. Savochkin <saw@msu.ru>
  */
@@ -31,6 +31,7 @@
 	unsigned long		tcp_ts_stamp;
 };
 
+#ifdef CONFIG_INETPEER
 void			inet_initpeers(void) __init;
 
 /* can be called with or without local BH being disabled */
@@ -51,5 +52,13 @@
 	spin_unlock_bh(&inet_peer_idlock);
 	return id;
 }
+#else
+
+#define inet_getpeer(a, b) (0)
+#define inet_putpeer(b)
+static void inline inet_initpeers(void) { }
+#define inet_getid(a, b) (0)
+
+#endif
 
 #endif /* _NET_INETPEER_H */
Index: linux-2.6.21/include/net/ip6_tunnel.h
===================================================================
--- linux-2.6.21.orig/include/net/ip6_tunnel.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/net/ip6_tunnel.h	2009-11-30 12:44:56.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * $Id$
+ * $Id: ip6_tunnel.h,v 1.1.1.1 2007-05-25 06:50:11 bruce Exp $
  */
 
 #ifndef _NET_IP6_TUNNEL_H
Index: linux-2.6.21/include/net/netfilter/nf_conntrack.h
===================================================================
--- linux-2.6.21.orig/include/net/netfilter/nf_conntrack.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/net/netfilter/nf_conntrack.h	2009-11-30 12:44:56.000000000 +0100
@@ -128,6 +128,22 @@
 	u_int32_t secmark;
 #endif
 
+#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || \
+    defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	struct {
+		/*
+		 * e.g. "http". NULL before decision. "unknown" after decision
+		 * if no match.
+		 */
+		char *app_proto;
+		/*
+		 * application layer data so far. NULL after match decision.
+		 */
+		char *app_data;
+		unsigned int app_data_len;
+	} layer7;
+#endif
+
 	/* Storage reserved for other modules: */
 	union nf_conntrack_proto proto;
 
Index: linux-2.6.21/include/net/protocol.h
===================================================================
--- linux-2.6.21.orig/include/net/protocol.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/net/protocol.h	2009-11-30 12:44:56.000000000 +0100
@@ -29,7 +29,11 @@
 #include <linux/ipv6.h>
 #endif
 
+#ifdef CONFIG_NET_SMALL
+#define MAX_INET_PROTOS 32
+#else
 #define MAX_INET_PROTOS	256		/* Must be a power of 2		*/
+#endif
 
 
 /* This is used to register protocols. */
Index: linux-2.6.21/include/net/sock.h
===================================================================
--- linux-2.6.21.orig/include/net/sock.h	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/include/net/sock.h	2009-11-30 12:44:56.000000000 +0100
@@ -887,6 +887,7 @@
  *
  */
 
+#ifdef CONFIG_NET_SK_FILTER
 static inline int sk_filter(struct sock *sk, struct sk_buff *skb)
 {
 	int err;
@@ -941,6 +942,13 @@
 	atomic_inc(&fp->refcnt);
 	atomic_add(sk_filter_len(fp), &sk->sk_omem_alloc);
 }
+#else
+
+#define sk_filter(a, b) (0)
+#define sk_filter_release(a, fp)
+#define sk_filter_charge(a, b)
+
+#endif
 
 /*
  * Socket reference counting postulates.
Index: linux-2.6.21/init/do_mounts_rd.c
===================================================================
--- linux-2.6.21.orig/init/do_mounts_rd.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/init/do_mounts_rd.c	2009-11-30 12:44:56.000000000 +0100
@@ -5,6 +5,7 @@
 #include <linux/ext2_fs.h>
 #include <linux/romfs_fs.h>
 #include <linux/cramfs_fs.h>
+#include <linux/squashfs_fs.h>
 #include <linux/initrd.h>
 #include <linux/string.h>
 
@@ -39,6 +40,7 @@
  * numbers could not be found.
  *
  * We currently check for the following magic numbers:
+ * 	squashfs
  * 	minix
  * 	ext2
  *	romfs
@@ -53,6 +55,7 @@
 	struct ext2_super_block *ext2sb;
 	struct romfs_super_block *romfsb;
 	struct cramfs_super *cramfsb;
+	struct squashfs_super_block *squashfsb;
 	int nblocks = -1;
 	unsigned char *buf;
 
@@ -64,6 +67,7 @@
 	ext2sb = (struct ext2_super_block *) buf;
 	romfsb = (struct romfs_super_block *) buf;
 	cramfsb = (struct cramfs_super *) buf;
+	squashfsb = (struct squashfs_super_block *) buf;
 	memset(buf, 0xe5, size);
 
 	/*
@@ -101,6 +105,19 @@
 		goto done;
 	}
 
+	/* squashfs is at block zero too */
+	if (squashfsb->s_magic == SQUASHFS_MAGIC) {
+		printk(KERN_NOTICE
+			"RAMDISK: squashfs filesystem found at block %d\n", 
+			start_block);
+		if (squashfsb->s_major < 3)
+			nblocks = (squashfsb->bytes_used_2+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+		else
+			nblocks = (squashfsb->bytes_used+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+		goto done;
+	}
+
+
 	/*
 	 * Read block 1 to test for minix and ext2 superblock
 	 */
Index: linux-2.6.21/init/initramfs.c
===================================================================
--- linux-2.6.21.orig/init/initramfs.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/init/initramfs.c	2009-11-30 12:44:56.000000000 +0100
@@ -6,6 +6,7 @@
 #include <linux/delay.h>
 #include <linux/string.h>
 #include <linux/syscalls.h>
+#include <linux/vmalloc.h>
 
 static __initdata char *message;
 static void __init error(char *x)
@@ -441,6 +442,104 @@
 	outcnt = 0;
 }
 
+#define _LZMA_IN_CB
+#define _LZMA_OUT_READ
+#include <linux/LzmaDecode.h>
+#include "MyLzmaDecode.c"
+
+static int read_byte(void *object, const unsigned char **buffer, SizeT *bufferSize)
+{
+	static unsigned char val;
+	*bufferSize = 1;
+	val = get_byte();
+	*buffer = &val;
+	return LZMA_RESULT_OK;
+}
+                                        
+static int __init lzma_unzip(void)
+{
+	unsigned int i;
+	CLzmaDecoderState state;
+	unsigned char* outputbuffer;
+	unsigned int uncompressedSize = 0;
+	unsigned char* p;
+	unsigned int kBlockSize =  0x10000;
+	unsigned int nowPos = 0;
+	unsigned int outsizeProcessed = 0;
+	int res;
+	ILzmaInCallback callback;
+
+	callback.Read = read_byte;
+
+	// lzma args
+	i = get_byte();
+	state.Properties.lc = i % 9, i = i / 9;
+	state.Properties.lp = i % 5, state.Properties.pb = i / 5;
+
+	// read dictionary size
+	p = (char*)&state.Properties.DictionarySize;
+	for (i = 0; i < 4; i++) 
+		*p++ = get_byte();
+
+	// get uncompressedSize
+	p= (char*)&uncompressedSize;	
+	for (i = 0; i < 4; i++) 
+		*p++ = get_byte();
+
+	// skip big file
+	for (i = 0; i < 4; i++) 
+		get_byte();
+
+	printk(KERN_NOTICE "initramfs: LZMA lc=%d,lp=%d,pb=%d,dictSize=%d,origSize=%d\n",
+			state.Properties.lc,state.Properties.lp,state.Properties.pb,state.Properties.DictionarySize, uncompressedSize);
+	outputbuffer = kmalloc(kBlockSize, GFP_KERNEL); 	
+	if (outputbuffer == 0) {
+		printk(KERN_ERR "initramfs: Couldn't allocate lzma output buffer\n");
+		return -1;
+	}
+
+	state.Probs =  (CProb*) kmalloc(LzmaGetNumProbs(&state.Properties)*sizeof(CProb), GFP_KERNEL);
+	if (state.Probs == 0) {
+		printk(KERN_ERR "initramfs: Couldn't allocate lzma workspace\n");
+		return -1;
+	}
+
+	state.Dictionary = vmalloc(state.Properties.DictionarySize);
+	if (state.Dictionary == 0) {
+		printk(KERN_ERR "initramfs: Couldn't allocate lzma dictionary\n");
+		return -1;
+	}
+
+	printk(KERN_NOTICE "LZMA initramfs by Ming-Ching Tiew <mctiew@yahoo.com>");
+
+	LzmaDecoderInit(&state);
+
+	for (nowPos =0; nowPos < uncompressedSize ; ) {
+		UInt32 blockSize = uncompressedSize - nowPos;
+		if (blockSize > kBlockSize)
+			blockSize = kBlockSize;
+		res = MyLzmaDecode(&state, &callback, outputbuffer, blockSize, &outsizeProcessed);
+		if (res != 0) {
+			panic( KERN_ERR "initramfs: Lzma decode failure\n");
+			return -1;
+		}
+		if (outsizeProcessed == 0) {
+			uncompressedSize = nowPos;
+			printk(KERN_NOTICE "initramfs: nowPos=%d, uncompressedSize=%d\n",
+					nowPos, uncompressedSize ); 
+			break;
+		}
+		flush_buffer(outputbuffer, outsizeProcessed);
+		nowPos += outsizeProcessed;
+		printk(".");
+	}
+
+	vfree(state.Dictionary);
+	kfree(outputbuffer);
+	kfree(state.Probs);
+	return 0;
+}
+
 static char * __init unpack_to_rootfs(char *buf, unsigned len, int check_only)
 {
 	int written;
@@ -475,11 +574,19 @@
 		inptr = 0;
 		outcnt = 0;		/* bytes in output buffer */
 		bytes_out = 0;
-		crc = (ulg)0xffffffffL; /* shift register contents */
-		makecrc();
-		gunzip();
-		if (state != Reset)
-			error("junk in gzipped archive");
+		if (inbuf[0] < 9 * 5 * 5 && buf[9] == 0 && buf[10] == 0
+				&& buf[11] == 0 && buf[12] == 0) {
+			printk("detected lzma initramfs\n");
+			printk(KERN_NOTICE "detected lzma initramfs\n");
+			lzma_unzip();
+		}
+		else {
+			crc = (ulg)0xffffffffL; /* shift register contents */
+			makecrc();
+			gunzip();
+			if (state != Reset)
+				error("junk in gzipped archive");
+		}
 		this_header = saved_offset + inptr;
 		buf += inptr;
 		len -= inptr;
Index: linux-2.6.21/init/Kconfig
===================================================================
--- linux-2.6.21.orig/init/Kconfig	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/init/Kconfig	2009-11-30 12:44:56.000000000 +0100
@@ -306,7 +306,7 @@
 
 config BLK_DEV_INITRD
 	bool "Initial RAM filesystem and RAM disk (initramfs/initrd) support"
-	depends on BROKEN || !FRV
+	depends on (BROKEN || !FRV) && RT2880_ROOTFS_IN_RAM
 	help
 	  The initial RAM filesystem is a ramfs which is loaded by the
 	  boot loader (loadlin or lilo) and that is mounted as root
@@ -413,15 +413,33 @@
 	  disabling this option for embedded systems that do not use modules, a
 	  dynamic /dev tree, or dynamic device discovery.  Just say Y.
 
+config PRINTK_FUNC
+	default y
+	bool "Enable printk function in the kernel" if EMBEDDED
+	help
+	  This option controls whether the printk function is compiled
+	  into the kernel or not. Removing it eliminates a small amount of
+	  code size from the kernel, which is OK if it is not being used.
+	  See CONFIG_PRINTK to disable the function calls to printk(),
+	  which is where the big win comes in reducing kernel size.
+
 config PRINTK
 	default y
-	bool "Enable support for printk" if EMBEDDED
+	bool "Enable support for printk message" if EMBEDDED
+	depends on PRINTK_FUNC
 	help
 	  This option enables normal printk support. Removing it
 	  eliminates most of the message strings from the kernel image
 	  and makes the kernel more or less silent. As this makes it
-	  very difficult to diagnose system problems, saying N here is
-	  strongly discouraged.
+	  very difficult to diagnose system problems, saying N here on
+	  non-embedded systems is strongly discouraged.
+
+	  With this set to 'N', if the printk function is still enabled,
+	  (see CONFIG_PRINTK_FUNC) you can enable printk messages from
+	  a single file, by putting "#define DO_PRINTK 1" at the top of
+	  the file.  This must appear before any #include lines.
+	  This makes it possible to have fine-grained control over
+	  which printk messages to include in the kernel.
 
 config BUG
 	bool "BUG() support" if EMBEDDED
@@ -492,6 +510,158 @@
 	  on EMBEDDED systems.  /proc/vmstat will only show page counts
 	  if VM event counters are disabled.
 
+menuconfig TINY
+	bool "Configure tiny kernel features"
+	help
+	  This option allows certain base kernel options and settings
+          to be disabled or tweaked. This is for specialized
+          environments which can tolerate a "non-standard" tiny kernel.
+          Only use this if you really know what you are doing.
+
+config NET_SMALL
+	default n
+	bool "Enable various size reductions for networking" if TINY
+	help
+	  This reduces the size of miscellaneous networking data structures.
+	  Currently a placeholder.
+
+config LINUXTINY_DO_UNINLINE
+	bool "un-inline several functions for smaller kernel size" if TINY
+	default n
+	help
+	  Un-inline some function for smaller kernel size.
+
+config PANIC
+	default y
+	bool "Enable panic reporting code" if TINY
+	help
+	  Disabling this completely removes panic handling code.
+	  Warning: this can result in data loss if a panic condition
+	  occurs, as the kernel may ignore the condition entirely.<F11>jj
+
+config FULL_PANIC
+	depends PANIC
+	default y
+	bool "Full panic reporting data" if TINY
+	help
+	  This includes text descriptions of panics in addition to stack dumps.
+	  Disabling compiles out the explanations for panics, saving
+	  string space. Use with caution.
+
+config MEMPOOL
+	default y
+	bool "Use mempool allocator" if TINY
+	help
+	  The mempool allocator attempts keep a reserve pool of
+	  various objects available for use in low-memory situations.
+	  Disabling this feature may make more memory available and
+	  will somewhat decrease code size, but with a higher risk of
+	  deadlock under some loads.
+
+config AIO
+	default y
+	bool "Enable AIO support" if TINY
+	help
+	  This option enables POSIX async IO which may be used by
+	  some high performance threaded applications. Disabling
+	  this option saves about 5k.
+
+config XATTR
+	default y
+	bool "Enable filesystem extended attribute support" if TINY
+	help
+	  This enables the filesystem extended attribute syscalls.
+
+config FILE_LOCKING
+	default y
+	bool "Enable POSIX file locking API" if TINY
+	help
+	  This enables standard file locking support.
+
+config ETHTOOL
+	depends NET
+	default y
+	bool "Enable ethtool support" if TINY
+	help
+	  Disabling this option removes support for configuring
+	  ethernet device features via ethtool. Saves about 6k.
+
+config INETPEER
+	default y
+	bool "Enable INET peer information storage" if TINY
+	help
+	  This allows storing various information about network peers.
+	  Disabling saves about 2k.
+
+config NET_SK_FILTER
+	default y
+	depends NET
+	bool "Enable network socket filter" if TINY
+	help
+	  This enables the basic kernel level socket filtering, not to
+	  be confused with netfilter. Required by PPP.
+
+config NET_DEV_MULTICAST
+	default y
+	depends NET
+	bool "Enable device multicast support" if TINY
+	help
+	  This enables the core device multicast list management code.
+
+config IGMP
+	depends NET
+	default y
+	bool "Enable IGMP support" if TINY && !IP_MULTICAST
+	help
+	  This includes support for the Internet group management
+	  protocol, used for multicast.
+
+config MAX_SWAPFILES_SHIFT
+	int "Number of swap files log2 (0 => 1, 5 => 32)" if TINY
+	range 0 5
+	default 5
+	help
+	  Select the maximum number of swapfiles (5 for default).
+
+config NR_LDISCS
+	int "Number of tty line disciplines (1~16)" if TINY
+	range 1 16
+	default 16
+	help
+	  Select the maximum number of tty line disciplines. Embedded systems
+	  can probably get by with only a few of these.
+
+config MAX_USER_RT_PRIO
+	int "Number of realtime priority levels (5~100)" if TINY
+	range 5 100
+	default 100
+	help
+	  This option allows reducing the size of the O(1) scheduler arrays.
+
+menuconfig TINY_EXPERIMENTAL
+	bool "Configure experimental tiny kernel features"
+	help
+	  This option allows certain base kernel options and settings
+          to be disabled or tweaked. This is for specialized
+          environments which can tolerate a "non-standard" tiny kernel.
+          Only use this if you really know what you are doing.
+
+config PDFLUSH
+	default y
+	bool "Enable pdflush daemon" if TINY_EXPERIMENTAL
+	help
+	  Enable kernel pdflush daemon.
+
+config BINFMT_ELF_AOUT
+	bool "ELF binaries with a.out linkage" if TINY_EXPERIMENTAL
+	depends on BINFMT_ELF
+	default y
+	help
+	  The kernel may support ELF executables which use an a.out format
+	  interpreter (dynamic linker) and/or a.out shared libraries, in
+	  addition to the usual ELF-ELF setups. You shouldn't need this.
+
+
 endmenu		# General setup
 
 config RT_MUTEXES
Index: linux-2.6.21/init/main.c
===================================================================
--- linux-2.6.21.orig/init/main.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/init/main.c	2009-11-30 12:44:56.000000000 +0100
@@ -770,6 +770,7 @@
 	run_init_process("/bin/sh");
 
 	panic("No init found.  Try passing init= option to kernel.");
+	return 0;
 }
 
 static int __init init(void * unused)
Index: linux-2.6.21/init/MyLzmaDecode.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/init/MyLzmaDecode.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,551 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder (optimized for Speed version)
+  
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#include <linux/LzmaDecode.h>
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
+
+#ifdef _LZMA_IN_CB
+
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) return result; \
+  BufferLim = Buffer + size; if (size == 0) return LZMA_RESULT_DATA_ERROR; }}
+
+#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+
+#else
+
+#define RC_TEST { if (Buffer == BufferLim) return LZMA_RESULT_DATA_ERROR; }
+
+#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
+ 
+#endif
+
+#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi <<= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 << numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int MyLzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs->Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+
+  #ifdef _LZMA_OUT_READ
+  
+  UInt32 Range = vs->Range;
+  UInt32 Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  const Byte *Buffer = vs->Buffer;
+  const Byte *BufferLim = vs->BufferLim;
+  #else
+  const Byte *Buffer = inStream;
+  const Byte *BufferLim = inStream + inSize;
+  #endif
+  int state = vs->State;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      #ifdef _LZMA_IN_CB
+      RC_INIT;
+      #else
+      RC_INIT(inStream, inSize);
+      #endif
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+    for (i = 0; i < numProbs; i++)
+      p[i] = kBitModelTotal >> 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  RC_INIT;
+  #else
+  RC_INIT(inStream, inSize);
+  #endif
+
+  #endif /* _LZMA_OUT_READ */
+
+  while(nowPos < outSize)
+  {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+
+    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        int matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol < 0x100);
+      }
+      while (symbol < 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (Byte)symbol;
+
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            UpdateBit0(prob);
+            
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+              return LZMA_RESULT_DATA_ERROR;
+            
+            state = state < kNumLitStates ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            #endif
+
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 <<= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range >>= 1;
+              rep0 <<= 1;
+              if (Code >= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 <<= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i <<= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 > distanceLimit) 
+      #else
+      if (rep0 > nowPos)
+      #endif
+        return LZMA_RESULT_DATA_ERROR;
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+  }
+  RC_NORMALIZE;
+
+  #ifdef _LZMA_OUT_READ
+  vs->Range = Range;
+  vs->Code = Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + (UInt32)nowPos;
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs->Buffer = Buffer;
+  vs->BufferLim = BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
Index: linux-2.6.21/kernel/panic.c
===================================================================
--- linux-2.6.21.orig/kernel/panic.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/kernel/panic.c	2009-11-30 12:44:56.000000000 +0100
@@ -39,15 +39,16 @@
 }
 __setup("panic=", panic_setup);
 
+/* Returns how long it waited in ms */
+long (*panic_blink)(long time);
+EXPORT_SYMBOL(panic_blink);
+
+#ifdef CONFIG_PANIC
 static long no_blink(long time)
 {
 	return 0;
 }
 
-/* Returns how long it waited in ms */
-long (*panic_blink)(long time);
-EXPORT_SYMBOL(panic_blink);
-
 /**
  *	panic - halt the system
  *	@fmt: The text string to print
@@ -57,11 +58,16 @@
  *	This function never returns.
  */
  
+#ifdef CONFIG_FULL_PANIC
 NORET_TYPE void panic(const char * fmt, ...)
 {
-	long i;
 	static char buf[1024];
 	va_list args;
+#else
+NORET_TYPE void tiny_panic(int a, ...)
+{
+#endif
+	long i;
 #if defined(CONFIG_S390)
         unsigned long caller = (unsigned long) __builtin_return_address(0);
 #endif
@@ -74,10 +80,14 @@
 	preempt_disable();
 
 	bust_spinlocks(1);
+#ifdef CONFIG_FULL_PANIC
 	va_start(args, fmt);
 	vsnprintf(buf, sizeof(buf), fmt, args);
 	va_end(args);
 	printk(KERN_EMERG "Kernel panic - not syncing: %s\n",buf);
+#else
+	printk(KERN_EMERG "Kernel panic - not syncing\n");
+#endif
 	bust_spinlocks(0);
 
 	/*
@@ -96,7 +106,11 @@
 	smp_send_stop();
 #endif
 
+#ifdef CONFIG_FULL_PANIC
 	atomic_notifier_call_chain(&panic_notifier_list, 0, buf);
+#else
+	atomic_notifier_call_chain(&panic_notifier_list, 0, "");
+#endif
 
 	if (!panic_blink)
 		panic_blink = no_blink;
@@ -139,7 +153,12 @@
 	}
 }
 
+#ifdef CONFIG_FULL_PANIC
 EXPORT_SYMBOL(panic);
+#else
+EXPORT_SYMBOL(tiny_panic);
+#endif
+#endif /* CONFIG_PANIC */
 
 /**
  *	print_tainted - return a string to represent the kernel taint state.
Index: linux-2.6.21/kernel/printk.c
===================================================================
--- linux-2.6.21.orig/kernel/printk.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/kernel/printk.c	2009-11-30 12:44:56.000000000 +0100
@@ -16,6 +16,11 @@
  *	01Mar01 Andrew Morton <andrewm@uow.edu.au>
  */
 
+/*
+ * have kernel.h produce real declarations, depending on configuration
+ */
+#define DO_PRINTK 1
+
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/tty.h>
@@ -115,7 +120,7 @@
 /* Flag: console code may call schedule() */
 static int console_may_schedule;
 
-#ifdef CONFIG_PRINTK
+#ifdef CONFIG_PRINTK_FUNC
 
 static char __log_buf[__LOG_BUF_LEN];
 static char *log_buf = __log_buf;
@@ -639,14 +644,9 @@
 
 #else
 
-asmlinkage long sys_syslog(int type, char __user *buf, int len)
-{
-	return -ENOSYS;
-}
-
-static void call_console_drivers(unsigned long start, unsigned long end)
-{
-}
+asmlinkage long sys_syslog(int type, char __user *buf, int len) { return 0; }
+int do_syslog(int type, char __user *buf, int len) { return 0; }
+static void call_console_drivers(unsigned long start, unsigned long end) {}
 
 #endif
 
Index: linux-2.6.21/kernel/sys.c
===================================================================
--- linux-2.6.21.orig/kernel/sys.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/kernel/sys.c	2009-11-30 12:44:56.000000000 +0100
@@ -2198,7 +2198,7 @@
 		 * need for a compat_getcpu). 32bit has enough
 		 * padding
 		 */
-		unsigned long t0, t1;
+		unsigned long t0=0, t1=0;
 		get_user(t0, &cache->blob[0]);
 		get_user(t1, &cache->blob[1]);
 		t0++;
Index: linux-2.6.21/kernel/sysctl.c
===================================================================
--- linux-2.6.21.orig/kernel/sysctl.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/kernel/sysctl.c	2009-11-30 12:44:56.000000000 +0100
@@ -684,6 +684,7 @@
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec_userhz_jiffies,
 	},
+#ifdef CONFIG_PDFLUSH
 	{
 		.ctl_name	= VM_NR_PDFLUSH_THREADS,
 		.procname	= "nr_pdflush_threads",
@@ -692,6 +693,7 @@
 		.mode		= 0444 /* read-only*/,
 		.proc_handler	= &proc_dointvec,
 	},
+#endif
 	{
 		.ctl_name	= VM_SWAPPINESS,
 		.procname	= "swappiness",
@@ -931,6 +933,7 @@
 		.extra1		= &minolduid,
 		.extra2		= &maxolduid,
 	},
+#ifdef CONFIG_FILE_LOCKING
 	{
 		.ctl_name	= FS_LEASES,
 		.procname	= "leases-enable",
@@ -939,6 +942,7 @@
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
+#endif
 #ifdef CONFIG_DNOTIFY
 	{
 		.ctl_name	= FS_DIR_NOTIFY,
@@ -950,6 +954,7 @@
 	},
 #endif
 #ifdef CONFIG_MMU
+#ifdef CONFIG_FILE_LOCKING
 	{
 		.ctl_name	= FS_LEASE_TIME,
 		.procname	= "lease-break-time",
@@ -958,6 +963,8 @@
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
+#endif
+#ifdef CONFIG_AIO
 	{
 		.ctl_name	= FS_AIO_NR,
 		.procname	= "aio-nr",
@@ -974,6 +981,7 @@
 		.mode		= 0644,
 		.proc_handler	= &proc_doulongvec_minmax,
 	},
+#endif
 #ifdef CONFIG_INOTIFY_USER
 	{
 		.ctl_name	= FS_INOTIFY,
Index: linux-2.6.21/kernel/sys_ni.c
===================================================================
--- linux-2.6.21.orig/kernel/sys_ni.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/kernel/sys_ni.c	2009-11-30 12:44:56.000000000 +0100
@@ -112,6 +112,24 @@
 cond_syscall(sys_vm86);
 cond_syscall(compat_sys_ipc);
 cond_syscall(compat_sys_sysctl);
+cond_syscall(sys_io_setup);
+cond_syscall(sys_io_destroy);
+cond_syscall(sys_io_submit);
+cond_syscall(sys_io_cancel);
+cond_syscall(sys_io_getevents);
+cond_syscall(sys_setxattr);
+cond_syscall(sys_lsetxattr);
+cond_syscall(sys_fsetxattr);
+cond_syscall(sys_getxattr);
+cond_syscall(sys_lgetxattr);
+cond_syscall(sys_fgetxattr);
+cond_syscall(sys_listxattr);
+cond_syscall(sys_llistxattr);
+cond_syscall(sys_flistxattr);
+cond_syscall(sys_removexattr);
+cond_syscall(sys_lremovexattr);
+cond_syscall(sys_fremovexattr);
+cond_syscall(sys_flock);
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read);
Index: linux-2.6.21/Makefile
===================================================================
--- linux-2.6.21.orig/Makefile	2009-11-30 12:44:55.000000000 +0100
+++ linux-2.6.21/Makefile	2009-11-30 12:44:56.000000000 +0100
@@ -158,10 +158,7 @@
 # then ARCH is assigned, getting whatever value it gets normally, and 
 # SUBARCH is subsequently ignored.
 
-SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
-				  -e s/arm.*/arm/ -e s/sa110/arm/ \
-				  -e s/s390x/s390/ -e s/parisc64/parisc/ \
-				  -e s/ppc.*/powerpc/ -e s/mips.*/mips/ )
+SUBARCH := mips
 
 # Cross compiling and selecting different set of gcc/bin-utils
 # ---------------------------------------------------------------------------
@@ -496,6 +493,7 @@
 CFLAGS		+= -fomit-frame-pointer
 endif
 
+CFLAGS		+= -gdwarf-2
 ifdef CONFIG_DEBUG_INFO
 CFLAGS		+= -g
 endif
@@ -510,6 +508,11 @@
 # improve gcc optimization
 CFLAGS += $(call cc-option,-funit-at-a-time,)
 
+CFLAGS += $(call cc-option,-membedded-data,)
+CFLAGS += $(call cc-option,-muninit-const-in-rodata,)
+
+CFLAGS += $(call cc-option,-funit-at-a-time,)
+
 # warn about C99 declaration after statement
 CFLAGS += $(call cc-option,-Wdeclaration-after-statement,)
 
@@ -907,7 +910,6 @@
 
 PHONY += depend dep
 depend dep:
-	@echo '*** Warning: make $@ is unnecessary now.'
 
 # ---------------------------------------------------------------------------
 # Kernel headers
@@ -991,11 +993,11 @@
 ifeq "$(strip $(INSTALL_MOD_PATH))" ""
 depmod_opts	:=
 else
-depmod_opts	:= -b $(INSTALL_MOD_PATH) -r
+depmod_opts	:= -b $(MODLIB) 
 endif
 PHONY += _modinst_post
 _modinst_post: _modinst_
-	if [ -r System.map -a -x $(DEPMOD) ]; then $(DEPMOD) -ae -F System.map $(depmod_opts) $(KERNELRELEASE); fi
+	if [ -r System.map -a -x $(DEPMOD) ]; then $(DEPMOD) -F System.map $(depmod_opts); fi
 
 else # CONFIG_MODULES
 
@@ -1022,7 +1024,8 @@
 # Directories & files removed with 'make clean'
 CLEAN_DIRS  += $(MODVERDIR)
 CLEAN_FILES +=	vmlinux System.map \
-                .tmp_kallsyms* .tmp_version .tmp_vmlinux* .tmp_System.map
+                .tmp_kallsyms* .tmp_version .tmp_vmlinux* .tmp_System.map \
+		scripts/kconfig/mconf scripts/kconfig/conf
 
 # Directories & files removed with 'make mrproper'
 MRPROPER_DIRS  += include/config include2 usr/include
Index: linux-2.6.21/mm/Makefile
===================================================================
--- linux-2.6.21.orig/mm/Makefile	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/mm/Makefile	2009-11-30 12:44:56.000000000 +0100
@@ -8,7 +8,7 @@
 			   vmalloc.o
 
 obj-y			:= bootmem.o filemap.o mempool.o oom_kill.o fadvise.o \
-			   page_alloc.o page-writeback.o pdflush.o \
+			   page_alloc.o page-writeback.o \
 			   readahead.o swap.o truncate.o vmscan.o \
 			   prio_tree.o util.o mmzone.o vmstat.o backing-dev.o \
 			   $(mmu-y)
@@ -16,6 +16,7 @@
 ifeq ($(CONFIG_MMU)$(CONFIG_BLOCK),yy)
 obj-y			+= bounce.o
 endif
+obj-$(CONFIG_PDFLUSH)	+= pdflush.o
 obj-$(CONFIG_SWAP)	+= page_io.o swap_state.o swapfile.o thrash.o
 obj-$(CONFIG_HUGETLBFS)	+= hugetlb.o
 obj-$(CONFIG_NUMA) 	+= mempolicy.o
Index: linux-2.6.21/mm/mempool.c
===================================================================
--- linux-2.6.21.orig/mm/mempool.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/mm/mempool.c	2009-11-30 12:44:56.000000000 +0100
@@ -15,6 +15,8 @@
 #include <linux/blkdev.h>
 #include <linux/writeback.h>
 
+#ifdef CONFIG_MEMPOOL
+
 static void add_element(mempool_t *pool, void *element)
 {
 	BUG_ON(pool->curr_nr >= pool->min_nr);
@@ -278,6 +280,54 @@
 }
 EXPORT_SYMBOL(mempool_free);
 
+#else /* !CONFIG_MEMPOOL */
+
+mempool_t *mempool_create(int min_nr, mempool_alloc_t *alloc_fn,
+		mempool_free_t *free_fn, void *pool_data)
+{
+	mempool_t *m;
+
+	m = (mempool_t *)kmalloc(sizeof(mempool_t), GFP_KERNEL);
+
+	if (m) {
+		m->pool_data = pool_data;
+		m->alloc = alloc_fn;
+		m->free = free_fn;
+		m->cache = alloc_fn(GFP_KERNEL, pool_data);
+	}
+
+	return m;
+}
+EXPORT_SYMBOL(mempool_create);
+
+extern void mempool_destroy(mempool_t *pool)
+{
+	if (pool->cache)
+		pool->free(pool->cache, pool->pool_data);
+	kfree(pool);
+}
+EXPORT_SYMBOL(mempool_destroy);
+
+void * mempool_alloc(mempool_t *pool, int gfp_mask)
+{
+	void *p = pool->alloc(gfp_mask, pool->pool_data);
+	if (!p)
+		p = xchg(&pool->cache, p);
+
+	return p;
+}
+EXPORT_SYMBOL(mempool_alloc);
+
+void mempool_free(void *element, mempool_t *pool)
+{
+	element = xchg(&pool->cache, element);
+	if (element)
+		pool->free(element, pool->pool_data);
+}
+EXPORT_SYMBOL(mempool_free);
+
+#endif
+
 /*
  * A commonly used alloc and free fn.
  */
Index: linux-2.6.21/mm/page_alloc.c
===================================================================
--- linux-2.6.21.orig/mm/page_alloc.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/mm/page_alloc.c	2009-11-30 12:44:56.000000000 +0100
@@ -671,6 +671,7 @@
 /*
  * Figure out the number of possible node ids.
  */
+#ifdef CONFIG_ARCH_POPULATES_NODE_MAP
 static void __init setup_nr_node_ids(void)
 {
 	unsigned int node;
@@ -683,6 +684,7 @@
 #else
 static void __init setup_nr_node_ids(void) {}
 #endif
+#endif
 
 #ifdef CONFIG_NUMA
 /*
Index: linux-2.6.21/mm/page-writeback.c
===================================================================
--- linux-2.6.21.orig/mm/page-writeback.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/mm/page-writeback.c	2009-11-30 12:44:56.000000000 +0100
@@ -100,7 +100,9 @@
 /* End of sysctl-exported parameters */
 
 
+#ifdef CONFIG_PDFLUSH
 static void background_writeout(unsigned long _min_pages);
+#endif
 
 /*
  * Work out the current dirty-memory clamping and background writeout
@@ -239,9 +241,11 @@
 	 * In normal mode, we start background writeout at the lower
 	 * background_thresh, to keep the amount of dirty memory low.
 	 */
+#ifdef CONFIG_PDFLUSH
 	if ((laptop_mode && pages_written) ||
 	     (!laptop_mode && (nr_reclaimable > background_thresh)))
 		pdflush_operation(background_writeout, 0);
+#endif
 }
 
 void set_page_dirty_balance(struct page *page)
@@ -331,6 +335,7 @@
  * writeback at least _min_pages, and keep writing until the amount of dirty
  * memory is less than the background threshold, or until we're all clean.
  */
+#ifdef CONFIG_PDFLUSH
 static void background_writeout(unsigned long _min_pages)
 {
 	long min_pages = _min_pages;
@@ -365,6 +370,7 @@
 		}
 	}
 }
+#endif
 
 /*
  * Start writeback of `nr_pages' pages.  If `nr_pages' is zero, write back
@@ -376,7 +382,11 @@
 	if (nr_pages == 0)
 		nr_pages = global_page_state(NR_FILE_DIRTY) +
 				global_page_state(NR_UNSTABLE_NFS);
+#ifdef CONFIG_PDFLUSH
 	return pdflush_operation(background_writeout, nr_pages);
+#else
+	return 0;
+#endif
 }
 
 static void wb_timer_fn(unsigned long unused);
@@ -400,6 +410,7 @@
  * older_than_this takes precedence over nr_to_write.  So we'll only write back
  * all dirty pages if they are all attached to "old" mappings.
  */
+#ifdef CONFIG_PDFLUSH
 static void wb_kupdate(unsigned long arg)
 {
 	unsigned long oldest_jif;
@@ -441,6 +452,7 @@
 	if (dirty_writeback_interval)
 		mod_timer(&wb_timer, next_jif);
 }
+#endif
 
 /*
  * sysctl handler for /proc/sys/vm/dirty_writeback_centisecs
@@ -460,18 +472,24 @@
 
 static void wb_timer_fn(unsigned long unused)
 {
+#ifdef CONFIG_PDFLUSH
 	if (pdflush_operation(wb_kupdate, 0) < 0)
 		mod_timer(&wb_timer, jiffies + HZ); /* delay 1 second */
+#endif
 }
 
+#ifdef CONFIG_PDFLUSH
 static void laptop_flush(unsigned long unused)
 {
 	sys_sync();
 }
+#endif
 
 static void laptop_timer_fn(unsigned long unused)
 {
+#ifdef CONFIG_PDFLUSH
 	pdflush_operation(laptop_flush, 0);
+#endif
 }
 
 /*
Index: linux-2.6.21/mm/vmscan.c
===================================================================
--- linux-2.6.21.orig/mm/vmscan.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/mm/vmscan.c	2009-11-30 12:44:56.000000000 +0100
@@ -1067,6 +1067,7 @@
 		 * that's undesirable in laptop mode, where we *want* lumpy
 		 * writeout.  So in laptop mode, write out the whole world.
 		 */
+	   
 		if (total_scanned > sc.swap_cluster_max +
 					sc.swap_cluster_max / 2) {
 			wakeup_pdflush(laptop_mode ? 0 : total_scanned);
Index: linux-2.6.21/net/8021q/vlan_dev.c
===================================================================
--- linux-2.6.21.orig/net/8021q/vlan_dev.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/8021q/vlan_dev.c	2009-11-30 12:44:56.000000000 +0100
@@ -440,7 +440,9 @@
 int vlan_dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct net_device_stats *stats = vlan_dev_get_stats(dev);
+#if !defined (CONFIG_ESW_DOUBLE_VLAN_TAG) || defined (VLAN_DEBUG)
 	struct vlan_ethhdr *veth = (struct vlan_ethhdr *)(skb->data);
+#endif
 
 	/* Handle non-VLAN frames if they are sent to us, for example by DHCP.
 	 *
@@ -448,7 +450,9 @@
 	 * OTHER THINGS LIKE FDDI/TokenRing/802.3 SNAPs...
 	 */
 
+#ifndef CONFIG_ESW_DOUBLE_VLAN_TAG
 	if (veth->h_vlan_proto != __constant_htons(ETH_P_8021Q)) {
+#endif
 		int orig_headroom = skb_headroom(skb);
 		unsigned short veth_TCI;
 
@@ -477,7 +481,9 @@
 		if (orig_headroom < VLAN_HLEN) {
 			VLAN_DEV_INFO(dev)->cnt_inc_headroom_on_tx++;
 		}
+#ifndef CONFIG_ESW_DOUBLE_VLAN_TAG
 	}
+#endif
 
 #ifdef VLAN_DEBUG
 	printk(VLAN_DBG "%s: about to send skb: %p to dev: %s\n",
@@ -818,7 +824,11 @@
 		break;
 
 	case SIOCETHTOOL:
+#ifdef CONFIG_ETHTOOL
 		err = dev_ethtool(&ifrr);
+#else
+#endif
+		break;
 	}
 
 	if (!err)
Index: linux-2.6.21/net/bridge/br_if.c
===================================================================
--- linux-2.6.21.orig/net/bridge/br_if.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/bridge/br_if.c	2009-11-30 12:44:56.000000000 +0100
@@ -5,7 +5,7 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id: br_if.c,v 1.7 2001/12/24 00:59:55 davem Exp $
+ *	$Id: br_if.c,v 1.2 2008-08-15 07:51:04 winfred Exp $
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
@@ -38,14 +38,18 @@
 	struct ethtool_cmd ecmd = { ETHTOOL_GSET };
 	struct ifreq ifr;
 	mm_segment_t old_fs;
-	int err;
+	int err = 0;
 
 	strncpy(ifr.ifr_name, dev->name, IFNAMSIZ);
 	ifr.ifr_data = (void __user *) &ecmd;
 
 	old_fs = get_fs();
 	set_fs(KERNEL_DS);
+#ifdef CONFIG_ETHTOOL
 	err = dev_ethtool(&ifr);
+#else
+	ecmd.speed = SPEED_100; //winfred: default 100Mbps
+#endif
 	set_fs(old_fs);
 
 	if (!err) {
Index: linux-2.6.21/net/core/flow.c
===================================================================
--- linux-2.6.21.orig/net/core/flow.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/core/flow.c	2009-11-30 12:44:56.000000000 +0100
@@ -351,7 +351,11 @@
 					sizeof(struct flow_cache_entry),
 					0, SLAB_HWCACHE_ALIGN|SLAB_PANIC,
 					NULL, NULL);
+#ifdef CONFIG_NET_SMALL
+	flow_hash_shift = 3;
+#else
 	flow_hash_shift = 10;
+#endif
 	flow_lwm = 2 * flow_hash_size;
 	flow_hwm = 4 * flow_hash_size;
 
Index: linux-2.6.21/net/core/Makefile
===================================================================
--- linux-2.6.21.orig/net/core/Makefile	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/core/Makefile	2009-11-30 12:44:56.000000000 +0100
@@ -7,13 +7,16 @@
 
 obj-$(CONFIG_SYSCTL) += sysctl_net_core.o
 
-obj-y		     += dev.o ethtool.o dev_mcast.o dst.o netevent.o \
-			neighbour.o rtnetlink.o utils.o link_watch.o filter.o
+obj-y		     += dev.o dst.o netevent.o \
+			neighbour.o rtnetlink.o utils.o link_watch.o
 
 obj-$(CONFIG_XFRM) += flow.o
+obj-$(CONFIG_ETHTOOL) += ethtool.o
 obj-$(CONFIG_SYSFS) += net-sysfs.o
 obj-$(CONFIG_NET_PKTGEN) += pktgen.o
 obj-$(CONFIG_WIRELESS_EXT) += wireless.o
 obj-$(CONFIG_NETPOLL) += netpoll.o
 obj-$(CONFIG_NET_DMA) += user_dma.o
 obj-$(CONFIG_FIB_RULES) += fib_rules.o
+obj-$(CONFIG_NET_DEV_MULTICAST) += dev_mcast.o
+obj-$(CONFIG_NET_SK_FILTER) += filter.o
Index: linux-2.6.21/net/core/sock.c
===================================================================
--- linux-2.6.21.orig/net/core/sock.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/core/sock.c	2009-11-30 12:44:56.000000000 +0100
@@ -7,7 +7,7 @@
  *		handler for protocols to use and generic option handler.
  *
  *
- * Version:	$Id: sock.c,v 1.117 2002/02/01 22:01:03 davem Exp $
+ * Version:	$Id: sock.c,v 1.2 2008-08-15 07:53:58 winfred Exp $
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
@@ -342,7 +342,9 @@
 		    char __user *optval, int optlen)
 {
 	struct sock *sk=sock->sk;
+#ifdef CONFIG_NET_SK_FILTER
 	struct sk_filter *filter;
+#endif
 	int val;
 	int valbool;
 	struct linger ling;
@@ -591,7 +593,7 @@
 		}
 #endif
 
-
+#ifdef CONFIG_NET_SK_FILTER
 		case SO_ATTACH_FILTER:
 			ret = -EINVAL;
 			if (optlen == sizeof(struct sock_fprog)) {
@@ -624,6 +626,7 @@
 			else
 				clear_bit(SOCK_PASSSEC, &sock->flags);
 			break;
+#endif
 
 		/* We implement the SO_SNDLOWAT etc to
 		   not be settable (1003.1g 5.3) */
Index: linux-2.6.21/net/ipv4/af_inet.c
===================================================================
--- linux-2.6.21.orig/net/ipv4/af_inet.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/ipv4/af_inet.c	2009-11-30 12:44:56.000000000 +0100
@@ -5,7 +5,7 @@
  *
  *		PF_INET protocol family socket handler.
  *
- * Version:	$Id: af_inet.c,v 1.137 2002/02/01 22:01:03 davem Exp $
+ * Version:	$Id: af_inet.c,v 1.2 2008-08-15 08:35:08 winfred Exp $
  *
  * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
@@ -118,8 +118,6 @@
 
 DEFINE_SNMP_STAT(struct linux_mib, net_statistics) __read_mostly;
 
-extern void ip_mc_drop_socket(struct sock *sk);
-
 /* The inetsw table contains everything that inet_create needs to
  * build a new socket.
  */
Index: linux-2.6.21/net/ipv4/ip_forward.c
===================================================================
--- linux-2.6.21.orig/net/ipv4/ip_forward.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/ipv4/ip_forward.c	2009-11-30 12:44:56.000000000 +0100
@@ -5,7 +5,7 @@
  *
  *		The IP forwarding functionality.
  *
- * Version:	$Id: ip_forward.c,v 1.48 2000/12/13 18:31:48 davem Exp $
+ * Version:	$Id: ip_forward.c,v 1.4 2009-02-24 08:17:06 steven Exp $
  *
  * Authors:	see ip.c
  *
@@ -100,7 +100,12 @@
 	if (rt->rt_flags&RTCF_DOREDIRECT && !opt->srr)
 		ip_rt_send_redirect(skb);
 
-	skb->priority = rt_tos2priority(iph->tos);
+	/* We should keep skb->priority value if iph->tos=0
+	 * for port-based QoS (by Steven)
+	 */
+	if(iph->tos != 0) {
+	    skb->priority = rt_tos2priority(iph->tos);
+	}
 
 	return NF_HOOK(PF_INET, NF_IP_FORWARD, skb, skb->dev, rt->u.dst.dev,
 		       ip_forward_finish);
Index: linux-2.6.21/net/ipv4/ip_sockglue.c
===================================================================
--- linux-2.6.21.orig/net/ipv4/ip_sockglue.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/ipv4/ip_sockglue.c	2009-11-30 12:44:56.000000000 +0100
@@ -5,7 +5,7 @@
  *
  *		The IP to API glue.
  *
- * Version:	$Id: ip_sockglue.c,v 1.62 2002/02/01 22:01:04 davem Exp $
+ * Version:	$Id: ip_sockglue.c,v 1.2 2008-08-15 07:56:25 winfred Exp $
  *
  * Authors:	see ip.c
  *
@@ -637,6 +637,7 @@
 				err = ip_mc_leave_group(sk, &mreq);
 			break;
 		}
+#ifdef CONFIG_IGMP
 		case IP_MSFILTER:
 		{
 			extern int sysctl_igmp_max_msf;
@@ -674,6 +675,7 @@
 			kfree(msf);
 			break;
 		}
+#endif
 		case IP_BLOCK_SOURCE:
 		case IP_UNBLOCK_SOURCE:
 		case IP_ADD_SOURCE_MEMBERSHIP:
@@ -791,6 +793,7 @@
 				greqs.gsr_interface);
 			break;
 		}
+#ifdef CONFIG_IGMP
 		case MCAST_MSFILTER:
 		{
 			extern int sysctl_igmp_max_msf;
@@ -857,6 +860,7 @@
 			kfree(gsf);
 			break;
 		}
+#endif
 		case IP_ROUTER_ALERT:
 			err = ip_ra_control(sk, val ? 1 : 0, NULL);
 			break;
Index: linux-2.6.21/net/ipv4/Makefile
===================================================================
--- linux-2.6.21.orig/net/ipv4/Makefile	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/ipv4/Makefile	2009-11-30 12:44:56.000000000 +0100
@@ -2,18 +2,20 @@
 # Makefile for the Linux TCP/IP (INET) layer.
 #
 
-obj-y     := route.o inetpeer.o protocol.o \
+obj-y     := route.o protocol.o \
 	     ip_input.o ip_fragment.o ip_forward.o ip_options.o \
 	     ip_output.o ip_sockglue.o inet_hashtables.o \
 	     inet_timewait_sock.o inet_connection_sock.o \
 	     tcp.o tcp_input.o tcp_output.o tcp_timer.o tcp_ipv4.o \
 	     tcp_minisocks.o tcp_cong.o \
 	     datagram.o raw.o udp.o udplite.o \
-	     arp.o icmp.o devinet.o af_inet.o  igmp.o \
+	     arp.o icmp.o devinet.o af_inet.o \
 	     sysctl_net_ipv4.o fib_frontend.o fib_semantics.o
 
 obj-$(CONFIG_IP_FIB_HASH) += fib_hash.o
 obj-$(CONFIG_IP_FIB_TRIE) += fib_trie.o
+obj-$(CONFIG_IGMP) += igmp.o
+obj-$(CONFIG_INETPEER) += inetpeer.o
 obj-$(CONFIG_PROC_FS) += proc.o
 obj-$(CONFIG_IP_MULTIPLE_TABLES) += fib_rules.o
 obj-$(CONFIG_IP_MROUTE) += ipmr.o
Index: linux-2.6.21/net/ipv4/netfilter/ip_conntrack_core.c
===================================================================
--- linux-2.6.21.orig/net/ipv4/netfilter/ip_conntrack_core.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/ipv4/netfilter/ip_conntrack_core.c	2009-11-30 12:44:56.000000000 +0100
@@ -74,6 +74,8 @@
 
 static unsigned int ip_conntrack_next_id;
 static unsigned int ip_conntrack_expect_next_id;
+extern char wan_name[IFNAMSIZ];
+
 #ifdef CONFIG_IP_NF_CONNTRACK_EVENTS
 ATOMIC_NOTIFIER_HEAD(ip_conntrack_chain);
 ATOMIC_NOTIFIER_HEAD(ip_conntrack_expect_chain);
@@ -146,10 +148,22 @@
 static u_int32_t __hash_conntrack(const struct ip_conntrack_tuple *tuple,
 			    unsigned int size, unsigned int rnd)
 {
+#if defined (CONFIG_NAT_FCONE) /* Full Cone */
+        return (jhash_3words(tuple->dst.ip,
+                             (tuple->dst.protonum),
+                             (tuple->dst.u.all),
+                             ip_conntrack_hash_rnd) % ip_conntrack_htable_size);
+#elif defined (CONFIG_NAT_RCONE) /* Restricted Cone */
+        return (jhash_3words(tuple->src.ip,
+                             (tuple->dst.ip ^ tuple->dst.protonum),
+                             (tuple->dst.u.all),
+                             ip_conntrack_hash_rnd) % ip_conntrack_htable_size);
+#else /* CONFIG_NAT_LINUX */
 	return (jhash_3words((__force u32)tuple->src.ip,
 			     ((__force u32)tuple->dst.ip ^ tuple->dst.protonum),
 			     (tuple->src.u.all | (tuple->dst.u.all << 16)),
 			     rnd) % size);
+#endif
 }
 
 static u_int32_t
@@ -385,6 +399,57 @@
 	return NULL;
 }
 
+/* Added by Steven Liu */
+#if defined (CONFIG_NAT_FCONE) || defined (CONFIG_NAT_RCONE)
+static inline int ip_ct_cone_tuple_equal(const struct ip_conntrack_tuple *t1,
+                                    const struct ip_conntrack_tuple *t2)
+{
+#if defined (CONFIG_NAT_FCONE)    /* Full Cone */
+        return ip_ct_tuple_dst_equal(t1, t2);
+#elif defined (CONFIG_NAT_RCONE)  /* Restricted Cone */
+        return ip_ct_tuple_dst_equal(t1, t2) && (t1->src.ip == t2->src.ip);
+#endif
+}
+
+
+static struct ip_conntrack_tuple_hash *
+__ip_cone_conntrack_find(const struct ip_conntrack_tuple *tuple,
+        const struct ip_conntrack *ignored_conntrack)
+{
+    struct ip_conntrack_tuple_hash *h;
+    unsigned int hash = hash_conntrack(tuple);
+
+    list_for_each_entry(h, &ip_conntrack_hash[hash], list) {
+	if (tuplehash_to_ctrack(h) != ignored_conntrack &&
+		ip_ct_cone_tuple_equal(tuple, &h->tuple)) {
+	    CONNTRACK_STAT_INC(found);
+	    return h;
+	}
+	CONNTRACK_STAT_INC(searched);
+    }
+
+    return NULL;
+}
+
+/* Find a connection corresponding to a tuple. */
+struct ip_conntrack_tuple_hash *
+ip_cone_conntrack_find_get(const struct ip_conntrack_tuple *tuple,
+        const struct ip_conntrack *ignored_conntrack)
+{
+    struct ip_conntrack_tuple_hash *h;
+
+    read_lock_bh(&ip_conntrack_lock);
+    h = __ip_cone_conntrack_find(tuple, ignored_conntrack);
+    if (h)
+	atomic_inc(&tuplehash_to_ctrack(h)->ct_general.use);
+    read_unlock_bh(&ip_conntrack_lock);
+
+    return h;
+}
+
+#endif
+
+
 /* Find a connection corresponding to a tuple. */
 struct ip_conntrack_tuple_hash *
 ip_conntrack_find_get(const struct ip_conntrack_tuple *tuple,
@@ -747,6 +812,7 @@
 	struct ip_conntrack_tuple tuple;
 	struct ip_conntrack_tuple_hash *h;
 	struct ip_conntrack *ct;
+	struct iphdr *iph=(struct iphdr *)skb->nh.raw;
 
 	IP_NF_ASSERT((skb->nh.iph->frag_off & htons(IP_OFFSET)) == 0);
 
@@ -755,7 +821,70 @@
 		return NULL;
 
 	/* look for tuple match */
+#if defined (CONFIG_NAT_FCONE) || defined (CONFIG_NAT_RCONE)
+
+        /*
+         * Based on NAT treatments of UDP in RFC3489:
+         *
+         * 1)Full Cone: A full cone NAT is one where all requests from the
+         * same internal IP address and port are mapped to the same external
+         * IP address and port.  Furthermore, any external host can send a
+         * packet to the internal host, by sending a packet to the mapped
+         * external address.
+         *
+         * 2)Restricted Cone: A restricted cone NAT is one where all requests
+         * from the same internal IP address and port are mapped to the same
+         * external IP address and port.  Unlike a full cone NAT, an external
+         * host (with IP address X) can send a packet to the internal host
+         * only if the internal host had previously sent a packet to IP
+         * address X.
+	 *
+         * 3)Port Restricted Cone: A port restricted cone NAT is like a
+         * restricted cone NAT, but the restriction includes port numbers.
+         * Specifically, an external host can send a packet, with source IP
+         * address X and source port P, to the internal host only if the
+         * internal host had previously sent a packet to IP address X and
+         * port P.
+         *
+         * 4)Symmetric: A symmetric NAT is one where all requests from the
+         * same internal IP address and port, to a specific destination IP
+         * address and port, are mapped to the same external IP address and
+         * port.  If the same host sends a packet with the same source
+         * address and port, but to a different destination, a different
+         * mapping is used.  Furthermore, only the external host that
+         * receives a packet can send a UDP packet back to the internal host.
+         *
+         *
+         * Original Linux NAT type is hybrid 'port restricted cone' and
+         * 'symmetric'. XBOX certificate recommands NAT type is 'fully cone'
+         * or 'restricted cone', so i patch the linux kernel to support
+         * this feature
+	 * Tradition scenario from LAN->WAN:
+         *
+         *        (LAN)     (WAN)
+         * Client------>AP---------> Server
+         * -------------> (I)
+         *              -------------->(II)
+         *              <--------------(III)
+         * <------------- (IV)
+         *
+         *
+         * (CASE I/II/IV) Compared Tuple=src_ip/port & dst_ip/port & proto
+         * (CASE III)  Compared Tuple:
+         *             Fully cone=dst_ip/port & proto
+         *             Restricted Cone=dst_ip/port & proto & src_ip
+         *
+         */
+	if( (skb->dev!=NULL) && /* CASE III */
+		(strcmp(skb->dev->name, wan_name)==0) &&
+		(iph->protocol==IPPROTO_UDP)) {
+	    h = ip_cone_conntrack_find_get(&tuple, NULL);
+	}else{ /* CASE I.II.IV */
+	    h = ip_conntrack_find_get(&tuple, NULL);
+	}
+#else //CONFIG_NAT_LINUX
 	h = ip_conntrack_find_get(&tuple, NULL);
+#endif
 	if (!h) {
 		h = init_conntrack(&tuple, proto, skb);
 		if (!h)
Index: linux-2.6.21/net/ipv4/netfilter/ip_conntrack_proto_tcp.c
===================================================================
--- linux-2.6.21.orig/net/ipv4/netfilter/ip_conntrack_proto_tcp.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/ipv4/netfilter/ip_conntrack_proto_tcp.c	2009-11-30 12:44:56.000000000 +0100
@@ -690,6 +690,7 @@
 		before(sack, receiver->td_end + 1),
 		after(ack, receiver->td_end - MAXACKWINDOW(sender)));
 
+#if defined (CONFIG_RA_NAT_NONE)
 	if (before(seq, sender->td_maxend + 1) &&
 	    after(end, sender->td_end - receiver->td_maxwin - 1) &&
 	    before(sack, receiver->td_end + 1) &&
@@ -756,6 +757,9 @@
 			: "SEQ is under the lower bound (already ACKed data retransmitted)"
 			: "SEQ is over the upper bound (over the window of the receiver)");
 	}
+#else
+	res = 1;
+#endif
 
 	DEBUGP("tcp_in_window: res=%i sender end=%u maxend=%u maxwin=%u "
 	       "receiver end=%u maxend=%u maxwin=%u\n",
Index: linux-2.6.21/net/ipv4/netfilter/ip_conntrack_standalone.c
===================================================================
--- linux-2.6.21.orig/net/ipv4/netfilter/ip_conntrack_standalone.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/ipv4/netfilter/ip_conntrack_standalone.c	2009-11-30 12:44:56.000000000 +0100
@@ -418,6 +418,23 @@
 	ct = ip_conntrack_get(*pskb, &ctinfo);
 	if (ct && ct->helper && ctinfo != IP_CT_RELATED + IP_CT_IS_REPLY) {
 		unsigned int ret;
+
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+#include "../../nat/sw_nat/ra_nat.h"
+            if( (skb_headroom(*pskb) >=4)  && (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_NUM) ) {
+                FOE_HASH_NUM(*pskb) |= FOE_ALG_FLAGS;
+            }
+
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+#include "../../nat/hw_nat/ra_nat.h"
+            if( (skb_headroom(*pskb) >=4)  &&
+                    ((FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_PCI) ||
+                     (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_WLAN) ||
+                     (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_GE))){
+                    FOE_ALG_RXIF(*pskb)=1;
+            }
+#endif
+
 		ret = ct->helper->help(pskb, ct, ctinfo);
 		if (ret != NF_ACCEPT)
 			return ret;
Index: linux-2.6.21/net/ipv4/netfilter/ip_tables.c
===================================================================
--- linux-2.6.21.orig/net/ipv4/netfilter/ip_tables.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/ipv4/netfilter/ip_tables.c	2009-11-30 12:44:56.000000000 +0100
@@ -41,6 +41,10 @@
 /*#define DEBUG_ALLOW_ALL*/ /* Useful for remote debugging */
 /*#define DEBUG_IP_FIREWALL_USER*/
 
+#if defined (CONFIG_NAT_FCONE) || defined (CONFIG_NAT_RCONE)
+unsigned char wan_name[IFNAMSIZ];
+#endif
+
 #ifdef DEBUG_IP_FIREWALL
 #define dprintf(format, args...)  printk(format , ## args)
 #else
@@ -1277,6 +1281,15 @@
 		     const struct xt_counters addme[],
 		     unsigned int *i)
 {
+#if defined (CONFIG_NAT_FCONE) || defined (CONFIG_NAT_RCONE)
+        struct ipt_entry_target *f=ipt_get_target(e);
+
+        if(strcmp(f->u.kernel.target->name,"MASQUERADE")==0 && strlen(e->ip.outiface)!=0) {
+		memset(wan_name,0,sizeof(wan_name));
+                memcpy(wan_name,e->ip.outiface, strlen(e->ip.outiface));
+        }
+#endif
+
 #if 0
 	duprintf("add_counter: Entry %u %lu/%lu + %lu/%lu\n",
 		 *i,
@@ -2191,7 +2204,15 @@
 	if (ret < 0)
 		goto err5;
 
-	printk("ip_tables: (C) 2000-2006 Netfilter Core Team\n");
+	printk("ip_tables: (C) 2000-2006 Netfilter Core Team, ");
+#if defined (CONFIG_NAT_FCONE)
+	printk("Type=Fully Cone\n");
+#elif defined (CONFIG_NAT_RCONE)
+	printk("Type=Restricted Cone\n");
+#else
+	printk("Type=Linux\n");
+#endif
+
 	return 0;
 
 err5:
Index: linux-2.6.21/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
===================================================================
--- linux-2.6.21.orig/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2009-11-30 12:44:56.000000000 +0100
@@ -151,6 +151,21 @@
 	if (!help || !help->helper)
 		return NF_ACCEPT;
 
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+#include "../../nat/sw_nat/ra_nat.h"
+            if( (skb_headroom(*pskb) >=4)  && (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_NUM) ) {
+                FOE_HASH_NUM(*pskb) |= FOE_ALG_FLAGS;
+            }
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+#include "../../nat/hw_nat/ra_nat.h"
+            if( (skb_headroom(*pskb) >=4)  &&
+                    ((FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_PCI) ||
+                     (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_WLAN) ||
+                     (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_GE))){
+                    FOE_ALG_RXIF(*pskb)=1;
+            }
+#endif
+
 	return help->helper->help(pskb,
 			       (*pskb)->nh.raw - (*pskb)->data
 					       + (*pskb)->nh.iph->ihl*4,
Index: linux-2.6.21/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c
===================================================================
--- linux-2.6.21.orig/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c	2009-11-30 12:44:56.000000000 +0100
@@ -163,6 +163,12 @@
 		return -ENOSPC;
 #endif
 
+#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	if(ct->layer7.app_proto)
+		if(seq_printf(s, "l7proto=%s ", ct->layer7.app_proto))
+			return -ENOSPC;
+#endif
+
 	if (seq_printf(s, "use=%u\n", atomic_read(&ct->ct_general.use)))
 		return -ENOSPC;
 
Index: linux-2.6.21/net/ipv4/sysctl_net_ipv4.c
===================================================================
--- linux-2.6.21.orig/net/ipv4/sysctl_net_ipv4.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/ipv4/sysctl_net_ipv4.c	2009-11-30 12:44:56.000000000 +0100
@@ -1,7 +1,7 @@
 /*
  * sysctl_net_ipv4.c: sysctl interface to net IPV4 subsystem.
  *
- * $Id: sysctl_net_ipv4.c,v 1.50 2001/10/20 00:00:11 davem Exp $
+ * $Id: sysctl_net_ipv4.c,v 1.2 2008-08-15 07:52:30 winfred Exp $
  *
  * Begun April 1, 1996, Mike Shaver.
  * Added /proc/sys/net/ipv4 directory entry (empty =) ). [MS]
@@ -482,6 +482,8 @@
 	},
 
 #endif
+#ifdef CONFIG_INETPEER
+#ifdef CONFIG_IGMP
 	{
 		.ctl_name	= NET_IPV4_IGMP_MAX_MSF,
 		.procname	= "igmp_max_msf",
@@ -490,6 +492,7 @@
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec
 	},
+#endif
 	{
 		.ctl_name	= NET_IPV4_INET_PEER_THRESHOLD,
 		.procname	= "inet_peer_threshold",
@@ -534,6 +537,7 @@
 		.proc_handler	= &proc_dointvec_jiffies,
 		.strategy	= &sysctl_jiffies
 	},
+#endif
 	{
 		.ctl_name	= NET_TCP_ORPHAN_RETRIES,
 		.procname	= "tcp_orphan_retries",
Index: linux-2.6.21/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
===================================================================
--- linux-2.6.21.orig/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c	2009-11-30 12:44:56.000000000 +0100
@@ -201,6 +201,21 @@
 		return NF_ACCEPT;
 	}
 
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+#include "../../nat/sw_nat/ra_nat.h"
+	if( (skb_headroom(*pskb) >=4)  && (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_NUM) ) {
+	    FOE_HASH_NUM(*pskb) |= FOE_ALG_FLAGS;
+					            }
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+#include "../../nat/hw_nat/ra_nat.h"
+	if( (skb_headroom(*pskb) >=4)  &&
+		((FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_PCI) ||
+		 (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_WLAN) ||
+		 (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_GE))){
+	    FOE_ALG_RXIF(*pskb)=1;
+	}
+#endif
+
 	ret = help->helper->help(pskb, protoff, ct, ctinfo);
 	if (ret != NF_ACCEPT)
 		return ret;
Index: linux-2.6.21/net/Makefile
===================================================================
--- linux-2.6.21.orig/net/Makefile	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/Makefile	2009-11-30 12:44:56.000000000 +0100
@@ -52,3 +52,9 @@
 ifeq ($(CONFIG_NET),y)
 obj-$(CONFIG_SYSCTL)		+= sysctl_net.o
 endif
+
+ifneq ($(CONFIG_RA_NAT_NONE),y)
+obj-y                           += nat/foe_hook/
+endif
+
+#obj-$(CONFIG_RA_HW_NAT)         += nat/hw_nat/
Index: linux-2.6.21/net/nat/foe_hook/hook.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/net/nat/foe_hook/hook.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,42 @@
+/*
+ ***************************************************************************
+ * Ralink Tech Inc.
+ * 4F, No. 2 Technology 5th Rd.
+ * Science-based Industrial Park
+ * Hsin-chu, Taiwan, R.O.C.
+ *
+ * (c) Copyright 2002-2006, Ralink Technology, Inc.
+ *
+ * All rights reserved. Ralink's source code is an unpublished work and the
+ * use of a copyright notice does not imply otherwise. This source code
+ * contains confidential trade secret material of Ralink Tech. Any attempt
+ * or participation in deciphering, decoding, reverse engineering or in any
+ * way altering the source code is stricitly prohibited, unless the prior
+ * written consent of Ralink Technology, Inc. is obtained.
+ ***************************************************************************
+
+    Module Name:
+    
+    hook.c
+
+    Abstract:
+
+    Revision History:
+    Who         When            What
+    --------    ----------      ----------------------------------------------
+    Name        Date            Modification logs
+    Steven Liu  2006-10-06      Initial version
+*/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/skbuff.h>
+
+int (*ra_sw_nat_hook_rx) (struct sk_buff * skb) = NULL;
+int (*ra_sw_nat_hook_tx) (struct sk_buff * skb, int gmac_no) = NULL;
+
+EXPORT_SYMBOL(ra_sw_nat_hook_rx);
+EXPORT_SYMBOL(ra_sw_nat_hook_tx);
+
Index: linux-2.6.21/net/nat/foe_hook/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/net/nat/foe_hook/Makefile	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,2 @@
+obj-y += foe_hook.o
+foe_hook-objs := hook.o
Index: linux-2.6.21/net/nat/foe_hook/Makefile.24
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/net/nat/foe_hook/Makefile.24	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,7 @@
+O_TARGET := foe_hook.o
+
+obj-y := hook.o
+obj-m := $(O_TARGET)
+export-objs :=  hook.o
+
+include $(TOPDIR)/Rules.make
Index: linux-2.6.21/net/nat/foe_hook/Makefile.26
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/net/nat/foe_hook/Makefile.26	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,2 @@
+obj-y += foe_hook.o
+foe_hook-objs := hook.o
Index: linux-2.6.21/net/netfilter/Kconfig
===================================================================
--- linux-2.6.21.orig/net/netfilter/Kconfig	2009-11-30 12:44:55.000000000 +0100
+++ linux-2.6.21/net/netfilter/Kconfig	2009-11-30 12:44:56.000000000 +0100
@@ -1,6 +1,21 @@
 menu "Core Netfilter Configuration"
 	depends on NET && INET && NETFILTER
 
+choice
+        prompt "NAT Types"
+        default NAT_LINUX
+
+        config  NAT_FCONE
+        bool "Full_Cone (EXPERIMENTAL)"
+
+        config  NAT_RCONE
+        bool "Restricted_Cone (EXPERIMENTAL)"
+
+        config  NAT_LINUX
+        bool "Linux"
+
+endchoice
+
 config NETFILTER_NETLINK
        tristate "Netfilter netlink interface"
        help
@@ -217,7 +232,7 @@
 	  To compile it as a module, choose M here.  If unsure, say N.
 
 config NF_CONNTRACK_PPTP
-	tristate "PPtP protocol support"
+	tristate "PPTP protocol support"
 	depends on NF_CONNTRACK
 	select NF_CT_PROTO_GRE
 	help
@@ -640,6 +655,27 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_MATCH_LAYER7
+	tristate '"layer7" match support'
+	depends on NETFILTER_XTABLES
+	depends on IP_NF_CONNTRACK || NF_CONNTRACK
+	depends on NF_CT_ACCT
+	help
+	  Say Y if you want to be able to classify connections (and their
+	  packets) based on regular expression matching of their application
+	  layer data.   This is one way to classify applications such as
+	  peer-to-peer filesharing systems that do not always use the same
+	  port.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_MATCH_LAYER7_DEBUG
+	bool 'layer7 debugging output'
+	depends on NETFILTER_XT_MATCH_LAYER7
+	help
+	  Say Y to get lots of debugging output.
+
+
 config NETFILTER_XT_MATCH_STATISTIC
 	tristate '"statistic" match support'
 	depends on NETFILTER_XTABLES
@@ -662,6 +698,15 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_MATCH_WEBSTR
+	tristate  '"webstr" match support'
+	depends on NETFILTER_XTABLES
+	help
+	  This option adds a `webstr' match, which allows you to look for
+	  pattern matchings in http stream.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config NETFILTER_XT_MATCH_TCPMSS
 	tristate '"tcpmss" match support'
 	depends on NETFILTER_XTABLES
Index: linux-2.6.21/net/netfilter/Makefile
===================================================================
--- linux-2.6.21.orig/net/netfilter/Makefile	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/netfilter/Makefile	2009-11-30 12:44:56.000000000 +0100
@@ -5,6 +5,7 @@
 
 obj-$(CONFIG_NETFILTER) = netfilter.o
 obj-$(CONFIG_SYSCTL) += nf_sysctl.o
+obj-$(CONFIG_RA_NAT_HW) += nf_conntrack_hnat.o
 
 obj-$(CONFIG_NETFILTER_NETLINK) += nfnetlink.o
 obj-$(CONFIG_NETFILTER_NETLINK_QUEUE) += nfnetlink_queue.o
@@ -68,8 +69,10 @@
 obj-$(CONFIG_NETFILTER_XT_MATCH_REALM) += xt_realm.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_SCTP) += xt_sctp.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STATE) += xt_state.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_LAYER7) += xt_layer7.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STATISTIC) += xt_statistic.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STRING) += xt_string.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_WEBSTR) += xt_webstr.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_TCPMSS) += xt_tcpmss.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_PHYSDEV) += xt_physdev.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_HASHLIMIT) += xt_hashlimit.o
Index: linux-2.6.21/net/netfilter/nf_conntrack_core.c
===================================================================
--- linux-2.6.21.orig/net/netfilter/nf_conntrack_core.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/netfilter/nf_conntrack_core.c	2009-11-30 12:44:56.000000000 +0100
@@ -47,6 +47,8 @@
 #include <linux/netdevice.h>
 #include <linux/socket.h>
 #include <linux/mm.h>
+#include <linux/ip.h>
+#include <linux/in.h>
 
 #include <net/netfilter/nf_conntrack.h>
 #include <net/netfilter/nf_conntrack_l3proto.h>
@@ -87,6 +89,10 @@
 
 unsigned int nf_ct_log_invalid __read_mostly;
 LIST_HEAD(unconfirmed);
+#if defined (CONFIG_NAT_FCONE) || defined (CONFIG_NAT_RCONE)
+extern char wan_name[IFNAMSIZ];
+#endif
+
 static int nf_conntrack_vmalloc __read_mostly;
 
 static unsigned int nf_conntrack_next_id;
@@ -128,10 +134,23 @@
 				  unsigned int size, unsigned int rnd)
 {
 	unsigned int a, b;
+
+#if defined (CONFIG_NAT_FCONE) /* Full Cone */
+	a = jhash((void *)tuple->dst.u3.all, sizeof(tuple->dst.u3.all),
+		   tuple->dst.u.all); // dst ip, dst port
+	b = jhash((void *)tuple->dst.u3.all, sizeof(tuple->dst.u3.all),
+		   tuple->dst.protonum); //dst ip, & dst ip protocol
+#elif defined (CONFIG_NAT_RCONE) /* Restricted Cone */
+	a = jhash((void *)tuple->src.u3.all, sizeof(tuple->src.u3.all), //src ip
+		   (tuple->src.l3num << 16) | tuple->dst.protonum);
+	b = jhash((void *)tuple->dst.u3.all, sizeof(tuple->dst.u3.all), //dst ip & dst port
+		  (tuple->dst.u.all << 16) | tuple->dst.protonum);
+#else /* CONFIG_NAT_LINUX */
 	a = jhash((void *)tuple->src.u3.all, sizeof(tuple->src.u3.all),
 		  ((tuple->src.l3num) << 16) | tuple->dst.protonum);
 	b = jhash((void *)tuple->dst.u3.all, sizeof(tuple->dst.u3.all),
 			(tuple->src.u.all << 16) | tuple->dst.u.all);
+#endif
 
 	return jhash_2words(a, b, rnd) % size;
 }
@@ -356,6 +375,14 @@
 	 * too. */
 	nf_ct_remove_expectations(ct);
 
+	#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	if(ct->layer7.app_proto)
+		kfree(ct->layer7.app_proto);
+	if(ct->layer7.app_data)
+	kfree(ct->layer7.app_data);
+	#endif
+
+
 	/* We overload first tuple to link into unconfirmed list. */
 	if (!nf_ct_is_confirmed(ct)) {
 		BUG_ON(list_empty(&ct->tuplehash[IP_CT_DIR_ORIGINAL].list));
@@ -405,6 +432,65 @@
 }
 EXPORT_SYMBOL_GPL(__nf_conntrack_find);
 
+/* Added by Steven Liu */
+#if defined (CONFIG_NAT_FCONE) || defined (CONFIG_NAT_RCONE)
+static inline int nf_ct_cone_tuple_equal(const struct nf_conntrack_tuple *t1,
+                                    const struct nf_conntrack_tuple *t2)
+{
+#if defined (CONFIG_NAT_FCONE)    /* Full Cone */
+        return nf_ct_tuple_dst_equal(t1, t2);
+#elif defined (CONFIG_NAT_RCONE)  /* Restricted Cone */
+        return (nf_ct_tuple_dst_equal(t1, t2) && 
+	        t1->src.u3.all[0] == t2->src.u3.all[0] &&
+                t1->src.u3.all[1] == t2->src.u3.all[1] && 
+		t1->src.u3.all[2] == t2->src.u3.all[2] &&
+                t1->src.u3.all[3] == t2->src.u3.all[3] &&
+		t1->src.l3num == t2->src.l3num &&
+		t1->dst.protonum == t2->dst.protonum);
+#endif
+}
+
+
+static struct nf_conntrack_tuple_hash *
+__nf_cone_conntrack_find(const struct nf_conntrack_tuple *tuple,
+        const struct nf_conn *ignored_conntrack)
+{
+    struct nf_conntrack_tuple_hash *h;
+    unsigned int hash = hash_conntrack(tuple);
+
+    list_for_each_entry(h, &nf_conntrack_hash[hash], list) {
+        if (nf_ct_tuplehash_to_ctrack(h) != ignored_conntrack &&
+                nf_ct_cone_tuple_equal(tuple, &h->tuple)) {
+            NF_CT_STAT_INC(found);
+            return h;
+        }
+        NF_CT_STAT_INC(searched);
+    }
+
+    return NULL;
+	
+}
+
+
+/* Find a connection corresponding to a tuple. */
+struct nf_conntrack_tuple_hash *
+nf_cone_conntrack_find_get(const struct nf_conntrack_tuple *tuple,
+        const struct nf_conn *ignored_conntrack)
+{
+    struct nf_conntrack_tuple_hash *h;
+
+    read_lock_bh(&nf_conntrack_lock);
+    h = __nf_cone_conntrack_find(tuple, ignored_conntrack);
+    if (h)
+        atomic_inc(&nf_ct_tuplehash_to_ctrack(h)->ct_general.use);
+    read_unlock_bh(&nf_conntrack_lock);
+
+    return h;
+}
+EXPORT_SYMBOL_GPL(nf_cone_conntrack_find_get);
+
+#endif
+
 /* Find a connection corresponding to a tuple. */
 struct nf_conntrack_tuple_hash *
 nf_conntrack_find_get(const struct nf_conntrack_tuple *tuple,
@@ -776,7 +862,74 @@
 	}
 
 	/* look for tuple match */
-	h = nf_conntrack_find_get(&tuple, NULL);
+#if defined (CONFIG_NAT_FCONE) || defined (CONFIG_NAT_RCONE)
+	struct iphdr *iph=(struct iphdr *)skb->nh.raw;
+
+        /*
+         * Based on NAT treatments of UDP in RFC3489:
+         *
+         * 1)Full Cone: A full cone NAT is one where all requests from the
+         * same internal IP address and port are mapped to the same external
+         * IP address and port.  Furthermore, any external host can send a
+         * packet to the internal host, by sending a packet to the mapped
+         * external address.
+         *
+         * 2)Restricted Cone: A restricted cone NAT is one where all requests
+         * from the same internal IP address and port are mapped to the same
+         * external IP address and port.  Unlike a full cone NAT, an external
+         * host (with IP address X) can send a packet to the internal host
+         * only if the internal host had previously sent a packet to IP
+         * address X.
+         *
+         * 3)Port Restricted Cone: A port restricted cone NAT is like a
+         * restricted cone NAT, but the restriction includes port numbers.
+         * Specifically, an external host can send a packet, with source IP
+         * address X and source port P, to the internal host only if the
+         * internal host had previously sent a packet to IP address X and
+         * port P.
+         *
+         * 4)Symmetric: A symmetric NAT is one where all requests from the
+         * same internal IP address and port, to a specific destination IP
+         * address and port, are mapped to the same external IP address and
+         * port.  If the same host sends a packet with the same source
+         * address and port, but to a different destination, a different
+         * mapping is used.  Furthermore, only the external host that
+         * receives a packet can send a UDP packet back to the internal host.
+         *
+         *
+	 *
+         *
+         * Original Linux NAT type is hybrid 'port restricted cone' and
+         * 'symmetric'. XBOX certificate recommands NAT type is 'fully cone'
+         * or 'restricted cone', so i patch the linux kernel to support
+         * this feature
+         * Tradition scenario from LAN->WAN:
+         *
+         *        (LAN)     (WAN)
+         * Client------>AP---------> Server
+         * -------------> (I)
+         *              -------------->(II)
+         *              <--------------(III)
+         * <------------- (IV)
+         *
+         *
+         * (CASE I/II/IV) Compared Tuple=src_ip/port & dst_ip/port & proto
+         * (CASE III)  Compared Tuple:
+         *             Fully cone=dst_ip/port & proto
+         *             Restricted Cone=dst_ip/port & proto & src_ip
+         *
+         */
+	if( (skb->dev!=NULL) && (iph!=NULL) && /* CASE III */
+		(strcmp(skb->dev->name, wan_name)==0) &&
+		(iph->protocol==IPPROTO_UDP)) {
+	    h = nf_cone_conntrack_find_get(&tuple, NULL);
+        }else{ /* CASE I.II.IV */
+            h = nf_conntrack_find_get(&tuple, NULL);
+        }
+#else //CONFIG_NAT_LINUX
+        h = nf_conntrack_find_get(&tuple, NULL);
+#endif
+
 	if (!h) {
 		h = init_conntrack(&tuple, l3proto, l4proto, skb, dataoff);
 		if (!h)
@@ -875,6 +1028,26 @@
 		return -ret;
 	}
 
+	
+#if defined(CONFIG_RA_SW_NAT) || defined(CONFIG_RA_SW_NAT_MODULE)
+#include "../nat/sw_nat/ra_nat.h"
+	if (nfct_help(ct)->helper) {
+            if( (skb_headroom(*pskb) >=4)  && (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_NUM) ) {
+                FOE_HASH_NUM(*pskb) |= FOE_CONNTRACKING_FLAGS;
+            }
+	}
+#elif  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
+#include "../nat/hw_nat/ra_nat.h"
+	if (nfct_help(ct)->helper) {
+            if( (skb_headroom(*pskb) >=4)  &&
+                    ((FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_PCI) ||
+                     (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_WLAN) ||
+                     (FOE_MAGIC_TAG(*pskb) == FOE_MAGIC_GE))){
+                    FOE_ALG_RXIF(*pskb)=1;
+	    }
+	}
+#endif
+
 	if (set_reply && !test_and_set_bit(IPS_SEEN_REPLY_BIT, &ct->status))
 		nf_conntrack_event_cache(IPCT_STATUS, *pskb);
 
Index: linux-2.6.21/net/netfilter/nf_conntrack_hnat.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/net/netfilter/nf_conntrack_hnat.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,89 @@
+/* This ALG just used by Ralink HNAT */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/in.h>
+#include <linux/udp.h>
+#include <linux/netfilter.h>
+
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_tuple.h>
+#include <net/netfilter/nf_conntrack_expect.h>
+#include <net/netfilter/nf_conntrack_ecache.h>
+#include <net/netfilter/nf_conntrack_helper.h>
+
+MODULE_AUTHOR("Steven <steven_liu@ralinktech.com.tw>");
+MODULE_DESCRIPTION("connection tracking pseudo helper");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ip_conntrack_hnat");
+
+#define MAX_PORTS 1
+#define HTTP_PORT 80
+static unsigned short ports[MAX_PORTS]={HTTP_PORT};
+
+unsigned int (*nf_nat_hnat_hook)(struct sk_buff **pskb,
+				 enum ip_conntrack_info ctinfo,
+				 struct nf_conntrack_expect *exp) __read_mostly;
+EXPORT_SYMBOL_GPL(nf_nat_hnat_hook);
+
+static int hnat_help(struct sk_buff **pskb,
+		     unsigned int protoff,
+		     struct nf_conn *ct,
+		     enum ip_conntrack_info ctinfo)
+{
+    return NF_ACCEPT;
+}
+
+static struct nf_conntrack_helper hnat[MAX_PORTS][2] __read_mostly;
+static char hnat_names[MAX_PORTS][2][sizeof("hnat-65535")] __read_mostly;
+
+static void nf_conntrack_hnat_fini(void)
+{
+	int i, j;
+
+	for (i = 0; i < MAX_PORTS ; i++) {
+		for (j = 0; j < 2; j++)
+			nf_conntrack_helper_unregister(&hnat[i][j]);
+	}
+}
+
+static int __init nf_conntrack_hnat_init(void)
+{
+	int i, j, ret;
+	char *tmpname;
+
+	for (i = 0; i < MAX_PORTS; i++) {
+		memset(&hnat[i], 0, sizeof(hnat[i]));
+
+		hnat[i][0].tuple.src.l3num = AF_INET;
+		hnat[i][1].tuple.src.l3num = AF_INET6;
+		for (j = 0; j < 2; j++) {
+			hnat[i][j].tuple.dst.protonum = IPPROTO_TCP;
+			hnat[i][j].tuple.src.u.udp.port = htons(ports[i]);
+			hnat[i][j].mask.src.l3num = 0xFFFF;
+			hnat[i][j].mask.dst.protonum = 0xFF;
+			hnat[i][j].mask.src.u.udp.port = htons(0xFFFF);
+			hnat[i][j].max_expected = 1;
+			hnat[i][j].timeout = 5 * 60; /* 5 minutes */
+			hnat[i][j].me = THIS_MODULE;
+			hnat[i][j].help = hnat_help;
+
+			tmpname = &hnat_names[i][j][0];
+			sprintf(tmpname, "hnat");
+			hnat[i][j].name = tmpname;
+
+			ret = nf_conntrack_helper_register(&hnat[i][j]);
+			if (ret) {
+				printk("nf_ct_hnat: failed to register helper "
+				       "for pf: %u port: %u\n",
+					hnat[i][j].tuple.src.l3num, ports[i]);
+				nf_conntrack_hnat_fini();
+				return ret;
+			}
+		}
+	}
+	return 0;
+}
+
+module_init(nf_conntrack_hnat_init);
+module_exit(nf_conntrack_hnat_fini);
Index: linux-2.6.21/net/netfilter/nf_conntrack_proto_tcp.c
===================================================================
--- linux-2.6.21.orig/net/netfilter/nf_conntrack_proto_tcp.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/netfilter/nf_conntrack_proto_tcp.c	2009-11-30 12:44:56.000000000 +0100
@@ -646,6 +646,7 @@
 		before(sack, receiver->td_end + 1),
 		after(ack, receiver->td_end - MAXACKWINDOW(sender)));
 
+#if defined (CONFIG_RA_NAT_NONE)
 	if (before(seq, sender->td_maxend + 1) &&
 	    after(end, sender->td_end - receiver->td_maxwin - 1) &&
 	    before(sack, receiver->td_end + 1) &&
@@ -712,6 +713,9 @@
 			: "SEQ is under the lower bound (already ACKed data retransmitted)"
 			: "SEQ is over the upper bound (over the window of the receiver)");
 	}
+#else
+	res = 1;
+#endif
 
 	DEBUGP("tcp_in_window: res=%i sender end=%u maxend=%u maxwin=%u "
 	       "receiver end=%u maxend=%u maxwin=%u\n",
Index: linux-2.6.21/net/netfilter/nf_conntrack_standalone.c
===================================================================
--- linux-2.6.21.orig/net/netfilter/nf_conntrack_standalone.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/netfilter/nf_conntrack_standalone.c	2009-11-30 12:44:56.000000000 +0100
@@ -195,6 +195,11 @@
 		return -ENOSPC;
 #endif
 
+#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	if(conntrack->layer7.app_proto)
+		if(seq_printf(s, "l7proto=%s ",conntrack->layer7.app_proto))
+			return -ENOSPC;
+#endif
 	if (seq_printf(s, "use=%u\n", atomic_read(&conntrack->ct_general.use)))
 		return -ENOSPC;
 	
Index: linux-2.6.21/net/netfilter/regexp/regexp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/net/netfilter/regexp/regexp.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,1197 @@
+/*
+ * regcomp and regexec -- regsub and regerror are elsewhere
+ * @(#)regexp.c	1.3 of 18 April 87
+ *
+ *	Copyright (c) 1986 by University of Toronto.
+ *	Written by Henry Spencer.  Not derived from licensed software.
+ *
+ *	Permission is granted to anyone to use this software for any
+ *	purpose on any computer system, and to redistribute it freely,
+ *	subject to the following restrictions:
+ *
+ *	1. The author is not responsible for the consequences of use of
+ *		this software, no matter how awful, even if they arise
+ *		from defects in it.
+ *
+ *	2. The origin of this software must not be misrepresented, either
+ *		by explicit claim or by omission.
+ *
+ *	3. Altered versions must be plainly marked as such, and must not
+ *		be misrepresented as being the original software.
+ *
+ * Beware that some of this code is subtly aware of the way operator
+ * precedence is structured in regular expressions.  Serious changes in
+ * regular-expression syntax might require a total rethink.
+ *
+ * This code was modified by Ethan Sommer to work within the kernel
+ * (it now uses kmalloc etc..)
+ *
+ * Modified slightly by Matthew Strait to use more modern C.
+ */
+
+#include "regexp.h"
+#include "regmagic.h"
+
+/* added by ethan and matt.  Lets it work in both kernel and user space.
+(So iptables can use it, for instance.)  Yea, it goes both ways... */
+#if __KERNEL__
+  #define malloc(foo) kmalloc(foo,GFP_ATOMIC)
+#else
+  #define printk(format,args...) printf(format,##args)
+#endif
+
+void regerror(char * s)
+{
+        printk("<3>Regexp: %s\n", s);
+        /* NOTREACHED */
+}
+
+/*
+ * The "internal use only" fields in regexp.h are present to pass info from
+ * compile to execute that permits the execute phase to run lots faster on
+ * simple cases.  They are:
+ *
+ * regstart	char that must begin a match; '\0' if none obvious
+ * reganch	is the match anchored (at beginning-of-line only)?
+ * regmust	string (pointer into program) that match must include, or NULL
+ * regmlen	length of regmust string
+ *
+ * Regstart and reganch permit very fast decisions on suitable starting points
+ * for a match, cutting down the work a lot.  Regmust permits fast rejection
+ * of lines that cannot possibly match.  The regmust tests are costly enough
+ * that regcomp() supplies a regmust only if the r.e. contains something
+ * potentially expensive (at present, the only such thing detected is * or +
+ * at the start of the r.e., which can involve a lot of backup).  Regmlen is
+ * supplied because the test in regexec() needs it and regcomp() is computing
+ * it anyway.
+ */
+
+/*
+ * Structure for regexp "program".  This is essentially a linear encoding
+ * of a nondeterministic finite-state machine (aka syntax charts or
+ * "railroad normal form" in parsing technology).  Each node is an opcode
+ * plus a "next" pointer, possibly plus an operand.  "Next" pointers of
+ * all nodes except BRANCH implement concatenation; a "next" pointer with
+ * a BRANCH on both ends of it is connecting two alternatives.  (Here we
+ * have one of the subtle syntax dependencies:  an individual BRANCH (as
+ * opposed to a collection of them) is never concatenated with anything
+ * because of operator precedence.)  The operand of some types of node is
+ * a literal string; for others, it is a node leading into a sub-FSM.  In
+ * particular, the operand of a BRANCH node is the first node of the branch.
+ * (NB this is *not* a tree structure:  the tail of the branch connects
+ * to the thing following the set of BRANCHes.)  The opcodes are:
+ */
+
+/* definition	number	opnd?	meaning */
+#define	END	0	/* no	End of program. */
+#define	BOL	1	/* no	Match "" at beginning of line. */
+#define	EOL	2	/* no	Match "" at end of line. */
+#define	ANY	3	/* no	Match any one character. */
+#define	ANYOF	4	/* str	Match any character in this string. */
+#define	ANYBUT	5	/* str	Match any character not in this string. */
+#define	BRANCH	6	/* node	Match this alternative, or the next... */
+#define	BACK	7	/* no	Match "", "next" ptr points backward. */
+#define	EXACTLY	8	/* str	Match this string. */
+#define	NOTHING	9	/* no	Match empty string. */
+#define	STAR	10	/* node	Match this (simple) thing 0 or more times. */
+#define	PLUS	11	/* node	Match this (simple) thing 1 or more times. */
+#define	OPEN	20	/* no	Mark this point in input as start of #n. */
+			/*	OPEN+1 is number 1, etc. */
+#define	CLOSE	30	/* no	Analogous to OPEN. */
+
+/*
+ * Opcode notes:
+ *
+ * BRANCH	The set of branches constituting a single choice are hooked
+ *		together with their "next" pointers, since precedence prevents
+ *		anything being concatenated to any individual branch.  The
+ *		"next" pointer of the last BRANCH in a choice points to the
+ *		thing following the whole choice.  This is also where the
+ *		final "next" pointer of each individual branch points; each
+ *		branch starts with the operand node of a BRANCH node.
+ *
+ * BACK		Normal "next" pointers all implicitly point forward; BACK
+ *		exists to make loop structures possible.
+ *
+ * STAR,PLUS	'?', and complex '*' and '+', are implemented as circular
+ *		BRANCH structures using BACK.  Simple cases (one character
+ *		per match) are implemented with STAR and PLUS for speed
+ *		and to minimize recursive plunges.
+ *
+ * OPEN,CLOSE	...are numbered at compile time.
+ */
+
+/*
+ * A node is one char of opcode followed by two chars of "next" pointer.
+ * "Next" pointers are stored as two 8-bit pieces, high order first.  The
+ * value is a positive offset from the opcode of the node containing it.
+ * An operand, if any, simply follows the node.  (Note that much of the
+ * code generation knows about this implicit relationship.)
+ *
+ * Using two bytes for the "next" pointer is vast overkill for most things,
+ * but allows patterns to get big without disasters.
+ */
+#define	OP(p)	(*(p))
+#define	NEXT(p)	(((*((p)+1)&0377)<<8) + (*((p)+2)&0377))
+#define	OPERAND(p)	((p) + 3)
+
+/*
+ * See regmagic.h for one further detail of program structure.
+ */
+
+
+/*
+ * Utility definitions.
+ */
+#ifndef CHARBITS
+#define	UCHARAT(p)	((int)*(unsigned char *)(p))
+#else
+#define	UCHARAT(p)	((int)*(p)&CHARBITS)
+#endif
+
+#define	FAIL(m)	{ regerror(m); return(NULL); }
+#define	ISMULT(c)	((c) == '*' || (c) == '+' || (c) == '?')
+#define	META	"^$.[()|?+*\\"
+
+/*
+ * Flags to be passed up and down.
+ */
+#define	HASWIDTH	01	/* Known never to match null string. */
+#define	SIMPLE		02	/* Simple enough to be STAR/PLUS operand. */
+#define	SPSTART		04	/* Starts with * or +. */
+#define	WORST		0	/* Worst case. */
+
+/*
+ * Global work variables for regcomp().
+ */
+struct match_globals {
+char *reginput;		/* String-input pointer. */
+char *regbol;		/* Beginning of input, for ^ check. */
+char **regstartp;	/* Pointer to startp array. */
+char **regendp;		/* Ditto for endp. */
+char *regparse;		/* Input-scan pointer. */
+int regnpar;		/* () count. */
+char regdummy;
+char *regcode;		/* Code-emit pointer; &regdummy = don't. */
+long regsize;		/* Code size. */
+};
+
+/*
+ * Forward declarations for regcomp()'s friends.
+ */
+#ifndef STATIC
+#define	STATIC	static
+#endif
+STATIC char *reg(struct match_globals *g, int paren,int *flagp);
+STATIC char *regbranch(struct match_globals *g, int *flagp);
+STATIC char *regpiece(struct match_globals *g, int *flagp);
+STATIC char *regatom(struct match_globals *g, int *flagp);
+STATIC char *regnode(struct match_globals *g, char op);
+STATIC char *regnext(struct match_globals *g, char *p);
+STATIC void regc(struct match_globals *g, char b);
+STATIC void reginsert(struct match_globals *g, char op, char *opnd);
+STATIC void regtail(struct match_globals *g, char *p, char *val);
+STATIC void regoptail(struct match_globals *g, char *p, char *val);
+
+
+__kernel_size_t my_strcspn(const char *s1,const char *s2)
+{
+        char *scan1;
+        char *scan2;
+        int count;
+
+        count = 0;
+        for (scan1 = (char *)s1; *scan1 != '\0'; scan1++) {
+                for (scan2 = (char *)s2; *scan2 != '\0';)       /* ++ moved down. */
+                        if (*scan1 == *scan2++)
+                                return(count);
+                count++;
+        }
+        return(count);
+}
+
+/*
+ - regcomp - compile a regular expression into internal code
+ *
+ * We can't allocate space until we know how big the compiled form will be,
+ * but we can't compile it (and thus know how big it is) until we've got a
+ * place to put the code.  So we cheat:  we compile it twice, once with code
+ * generation turned off and size counting turned on, and once "for real".
+ * This also means that we don't allocate space until we are sure that the
+ * thing really will compile successfully, and we never have to move the
+ * code and thus invalidate pointers into it.  (Note that it has to be in
+ * one piece because free() must be able to free it all.)
+ *
+ * Beware that the optimization-preparation code in here knows about some
+ * of the structure of the compiled regexp.
+ */
+regexp *
+regcomp(char *exp,int *patternsize)
+{
+	register regexp *r;
+	register char *scan;
+	register char *longest;
+	register int len;
+	int flags;
+	struct match_globals g;
+	
+	/* commented out by ethan
+	   extern char *malloc();
+	*/
+
+	if (exp == NULL)
+		FAIL("NULL argument");
+
+	/* First pass: determine size, legality. */
+	g.regparse = exp;
+	g.regnpar = 1;
+	g.regsize = 0L;
+	g.regcode = &g.regdummy;
+	regc(&g, MAGIC);
+	if (reg(&g, 0, &flags) == NULL)
+		return(NULL);
+
+	/* Small enough for pointer-storage convention? */
+	if (g.regsize >= 32767L)		/* Probably could be 65535L. */
+		FAIL("regexp too big");
+
+	/* Allocate space. */
+	*patternsize=sizeof(regexp) + (unsigned)g.regsize;
+	r = (regexp *)malloc(sizeof(regexp) + (unsigned)g.regsize);
+	if (r == NULL)
+		FAIL("out of space");
+
+	/* Second pass: emit code. */
+	g.regparse = exp;
+	g.regnpar = 1;
+	g.regcode = r->program;
+	regc(&g, MAGIC);
+	if (reg(&g, 0, &flags) == NULL)
+		return(NULL);
+
+	/* Dig out information for optimizations. */
+	r->regstart = '\0';	/* Worst-case defaults. */
+	r->reganch = 0;
+	r->regmust = NULL;
+	r->regmlen = 0;
+	scan = r->program+1;			/* First BRANCH. */
+	if (OP(regnext(&g, scan)) == END) {		/* Only one top-level choice. */
+		scan = OPERAND(scan);
+
+		/* Starting-point info. */
+		if (OP(scan) == EXACTLY)
+			r->regstart = *OPERAND(scan);
+		else if (OP(scan) == BOL)
+			r->reganch++;
+
+		/*
+		 * If there's something expensive in the r.e., find the
+		 * longest literal string that must appear and make it the
+		 * regmust.  Resolve ties in favor of later strings, since
+		 * the regstart check works with the beginning of the r.e.
+		 * and avoiding duplication strengthens checking.  Not a
+		 * strong reason, but sufficient in the absence of others.
+		 */
+		if (flags&SPSTART) {
+			longest = NULL;
+			len = 0;
+			for (; scan != NULL; scan = regnext(&g, scan))
+				if (OP(scan) == EXACTLY && strlen(OPERAND(scan)) >= len) {
+					longest = OPERAND(scan);
+					len = strlen(OPERAND(scan));
+				}
+			r->regmust = longest;
+			r->regmlen = len;
+		}
+	}
+
+	return(r);
+}
+
+/*
+ - reg - regular expression, i.e. main body or parenthesized thing
+ *
+ * Caller must absorb opening parenthesis.
+ *
+ * Combining parenthesis handling with the base level of regular expression
+ * is a trifle forced, but the need to tie the tails of the branches to what
+ * follows makes it hard to avoid.
+ */
+static char *
+reg(struct match_globals *g, int paren, int *flagp /* Parenthesized? */ )
+{
+	register char *ret;
+	register char *br;
+	register char *ender;
+	register int parno = 0; /* 0 makes gcc happy */
+	int flags;
+
+	*flagp = HASWIDTH;	/* Tentatively. */
+
+	/* Make an OPEN node, if parenthesized. */
+	if (paren) {
+		if (g->regnpar >= NSUBEXP)
+			FAIL("too many ()");
+		parno = g->regnpar;
+		g->regnpar++;
+		ret = regnode(g, OPEN+parno);
+	} else
+		ret = NULL;
+
+	/* Pick up the branches, linking them together. */
+	br = regbranch(g, &flags);
+	if (br == NULL)
+		return(NULL);
+	if (ret != NULL)
+		regtail(g, ret, br);	/* OPEN -> first. */
+	else
+		ret = br;
+	if (!(flags&HASWIDTH))
+		*flagp &= ~HASWIDTH;
+	*flagp |= flags&SPSTART;
+	while (*g->regparse == '|') {
+		g->regparse++;
+		br = regbranch(g, &flags);
+		if (br == NULL)
+			return(NULL);
+		regtail(g, ret, br);	/* BRANCH -> BRANCH. */
+		if (!(flags&HASWIDTH))
+			*flagp &= ~HASWIDTH;
+		*flagp |= flags&SPSTART;
+	}
+
+	/* Make a closing node, and hook it on the end. */
+	ender = regnode(g, (paren) ? CLOSE+parno : END);	
+	regtail(g, ret, ender);
+
+	/* Hook the tails of the branches to the closing node. */
+	for (br = ret; br != NULL; br = regnext(g, br))
+		regoptail(g, br, ender);
+
+	/* Check for proper termination. */
+	if (paren && *g->regparse++ != ')') {
+		FAIL("unmatched ()");
+	} else if (!paren && *g->regparse != '\0') {
+		if (*g->regparse == ')') {
+			FAIL("unmatched ()");
+		} else
+			FAIL("junk on end");	/* "Can't happen". */
+		/* NOTREACHED */
+	}
+
+	return(ret);
+}
+
+/*
+ - regbranch - one alternative of an | operator
+ *
+ * Implements the concatenation operator.
+ */
+static char *
+regbranch(struct match_globals *g, int *flagp)
+{
+	register char *ret;
+	register char *chain;
+	register char *latest;
+	int flags;
+
+	*flagp = WORST;		/* Tentatively. */
+
+	ret = regnode(g, BRANCH);
+	chain = NULL;
+	while (*g->regparse != '\0' && *g->regparse != '|' && *g->regparse != ')') {
+		latest = regpiece(g, &flags);
+		if (latest == NULL)
+			return(NULL);
+		*flagp |= flags&HASWIDTH;
+		if (chain == NULL)	/* First piece. */
+			*flagp |= flags&SPSTART;
+		else
+			regtail(g, chain, latest);
+		chain = latest;
+	}
+	if (chain == NULL)	/* Loop ran zero times. */
+		(void) regnode(g, NOTHING);
+
+	return(ret);
+}
+
+/*
+ - regpiece - something followed by possible [*+?]
+ *
+ * Note that the branching code sequences used for ? and the general cases
+ * of * and + are somewhat optimized:  they use the same NOTHING node as
+ * both the endmarker for their branch list and the body of the last branch.
+ * It might seem that this node could be dispensed with entirely, but the
+ * endmarker role is not redundant.
+ */
+static char *
+regpiece(struct match_globals *g, int *flagp)
+{
+	register char *ret;
+	register char op;
+	register char *next;
+	int flags;
+
+	ret = regatom(g, &flags);
+	if (ret == NULL)
+		return(NULL);
+
+	op = *g->regparse;
+	if (!ISMULT(op)) {
+		*flagp = flags;
+		return(ret);
+	}
+
+	if (!(flags&HASWIDTH) && op != '?')
+		FAIL("*+ operand could be empty");
+	*flagp = (op != '+') ? (WORST|SPSTART) : (WORST|HASWIDTH);
+
+	if (op == '*' && (flags&SIMPLE))
+		reginsert(g, STAR, ret);
+	else if (op == '*') {
+		/* Emit x* as (x&|), where & means "self". */
+		reginsert(g, BRANCH, ret);			/* Either x */
+		regoptail(g, ret, regnode(g, BACK));		/* and loop */
+		regoptail(g, ret, ret);			/* back */
+		regtail(g, ret, regnode(g, BRANCH));		/* or */
+		regtail(g, ret, regnode(g, NOTHING));		/* null. */
+	} else if (op == '+' && (flags&SIMPLE))
+		reginsert(g, PLUS, ret);
+	else if (op == '+') {
+		/* Emit x+ as x(&|), where & means "self". */
+		next = regnode(g, BRANCH);			/* Either */
+		regtail(g, ret, next);
+		regtail(g, regnode(g, BACK), ret);		/* loop back */
+		regtail(g, next, regnode(g, BRANCH));		/* or */
+		regtail(g, ret, regnode(g, NOTHING));		/* null. */
+	} else if (op == '?') {
+		/* Emit x? as (x|) */
+		reginsert(g, BRANCH, ret);			/* Either x */
+		regtail(g, ret, regnode(g, BRANCH));		/* or */
+		next = regnode(g, NOTHING);		/* null. */
+		regtail(g, ret, next);
+		regoptail(g, ret, next);
+	}
+	g->regparse++;
+	if (ISMULT(*g->regparse))
+		FAIL("nested *?+");
+
+	return(ret);
+}
+
+/*
+ - regatom - the lowest level
+ *
+ * Optimization:  gobbles an entire sequence of ordinary characters so that
+ * it can turn them into a single node, which is smaller to store and
+ * faster to run.  Backslashed characters are exceptions, each becoming a
+ * separate node; the code is simpler that way and it's not worth fixing.
+ */
+static char *
+regatom(struct match_globals *g, int *flagp)
+{
+	register char *ret;
+	int flags;
+
+	*flagp = WORST;		/* Tentatively. */
+
+	switch (*g->regparse++) {
+	case '^':
+		ret = regnode(g, BOL);
+		break;
+	case '$':
+		ret = regnode(g, EOL);
+		break;
+	case '.':
+		ret = regnode(g, ANY);
+		*flagp |= HASWIDTH|SIMPLE;
+		break;
+	case '[': {
+			register int class;
+			register int classend;
+
+			if (*g->regparse == '^') {	/* Complement of range. */
+				ret = regnode(g, ANYBUT);
+				g->regparse++;
+			} else
+				ret = regnode(g, ANYOF);
+			if (*g->regparse == ']' || *g->regparse == '-')
+				regc(g, *g->regparse++);
+			while (*g->regparse != '\0' && *g->regparse != ']') {
+				if (*g->regparse == '-') {
+					g->regparse++;
+					if (*g->regparse == ']' || *g->regparse == '\0')
+						regc(g, '-');
+					else {
+						class = UCHARAT(g->regparse-2)+1;
+						classend = UCHARAT(g->regparse);
+						if (class > classend+1)
+							FAIL("invalid [] range");
+						for (; class <= classend; class++)
+							regc(g, class);
+						g->regparse++;
+					}
+				} else
+					regc(g, *g->regparse++);
+			}
+			regc(g, '\0');
+			if (*g->regparse != ']')
+				FAIL("unmatched []");
+			g->regparse++;
+			*flagp |= HASWIDTH|SIMPLE;
+		}
+		break;
+	case '(':
+		ret = reg(g, 1, &flags);
+		if (ret == NULL)
+			return(NULL);
+		*flagp |= flags&(HASWIDTH|SPSTART);
+		break;
+	case '\0':
+	case '|':
+	case ')':
+		FAIL("internal urp");	/* Supposed to be caught earlier. */
+		break;
+	case '?':
+	case '+':
+	case '*':
+		FAIL("?+* follows nothing");
+		break;
+	case '\\':
+		if (*g->regparse == '\0')
+			FAIL("trailing \\");
+		ret = regnode(g, EXACTLY);
+		regc(g, *g->regparse++);
+		regc(g, '\0');
+		*flagp |= HASWIDTH|SIMPLE;
+		break;
+	default: {
+			register int len;
+			register char ender;
+
+			g->regparse--;
+			len = my_strcspn((const char *)g->regparse, (const char *)META);
+			if (len <= 0)
+				FAIL("internal disaster");
+			ender = *(g->regparse+len);
+			if (len > 1 && ISMULT(ender))
+				len--;		/* Back off clear of ?+* operand. */
+			*flagp |= HASWIDTH;
+			if (len == 1)
+				*flagp |= SIMPLE;
+			ret = regnode(g, EXACTLY);
+			while (len > 0) {
+				regc(g, *g->regparse++);
+				len--;
+			}
+			regc(g, '\0');
+		}
+		break;
+	}
+
+	return(ret);
+}
+
+/*
+ - regnode - emit a node
+ */
+static char *			/* Location. */
+regnode(struct match_globals *g, char op)
+{
+	register char *ret;
+	register char *ptr;
+
+	ret = g->regcode;
+	if (ret == &g->regdummy) {
+		g->regsize += 3;
+		return(ret);
+	}
+
+	ptr = ret;
+	*ptr++ = op;
+	*ptr++ = '\0';		/* Null "next" pointer. */
+	*ptr++ = '\0';
+	g->regcode = ptr;
+
+	return(ret);
+}
+
+/*
+ - regc - emit (if appropriate) a byte of code
+ */
+static void
+regc(struct match_globals *g, char b)
+{
+	if (g->regcode != &g->regdummy)
+		*g->regcode++ = b;
+	else
+		g->regsize++;
+}
+
+/*
+ - reginsert - insert an operator in front of already-emitted operand
+ *
+ * Means relocating the operand.
+ */
+static void
+reginsert(struct match_globals *g, char op, char* opnd)
+{
+	register char *src;
+	register char *dst;
+	register char *place;
+
+	if (g->regcode == &g->regdummy) {
+		g->regsize += 3;
+		return;
+	}
+
+	src = g->regcode;
+	g->regcode += 3;
+	dst = g->regcode;
+	while (src > opnd)
+		*--dst = *--src;
+
+	place = opnd;		/* Op node, where operand used to be. */
+	*place++ = op;
+	*place++ = '\0';
+	*place++ = '\0';
+}
+
+/*
+ - regtail - set the next-pointer at the end of a node chain
+ */
+static void
+regtail(struct match_globals *g, char *p, char *val)
+{
+	register char *scan;
+	register char *temp;
+	register int offset;
+
+	if (p == &g->regdummy)
+		return;
+
+	/* Find last node. */
+	scan = p;
+	for (;;) {
+		temp = regnext(g, scan);
+		if (temp == NULL)
+			break;
+		scan = temp;
+	}
+
+	if (OP(scan) == BACK)
+		offset = scan - val;
+	else
+		offset = val - scan;
+	*(scan+1) = (offset>>8)&0377;
+	*(scan+2) = offset&0377;
+}
+
+/*
+ - regoptail - regtail on operand of first argument; nop if operandless
+ */
+static void
+regoptail(struct match_globals *g, char *p, char *val)
+{
+	/* "Operandless" and "op != BRANCH" are synonymous in practice. */
+	if (p == NULL || p == &g->regdummy || OP(p) != BRANCH)
+		return;
+	regtail(g, OPERAND(p), val);
+}
+
+/*
+ * regexec and friends
+ */
+
+
+/*
+ * Forwards.
+ */
+STATIC int regtry(struct match_globals *g, regexp *prog, char *string);
+STATIC int regmatch(struct match_globals *g, char *prog);
+STATIC int regrepeat(struct match_globals *g, char *p);
+
+#ifdef DEBUG
+int regnarrate = 0;
+void regdump();
+STATIC char *regprop(char *op);
+#endif
+
+/*
+ - regexec - match a regexp against a string
+ */
+int
+regexec(regexp *prog, char *string)
+{
+	register char *s;
+	struct match_globals g;
+
+	/* Be paranoid... */
+	if (prog == NULL || string == NULL) {
+		printk("<3>Regexp: NULL parameter\n");
+		return(0);
+	}
+
+	/* Check validity of program. */
+	if (UCHARAT(prog->program) != MAGIC) {
+		printk("<3>Regexp: corrupted program\n");
+		return(0);
+	}
+
+	/* If there is a "must appear" string, look for it. */
+	if (prog->regmust != NULL) {
+		s = string;
+		while ((s = strchr(s, prog->regmust[0])) != NULL) {
+			if (strncmp(s, prog->regmust, prog->regmlen) == 0)
+				break;	/* Found it. */
+			s++;
+		}
+		if (s == NULL)	/* Not present. */
+			return(0);
+	}
+
+	/* Mark beginning of line for ^ . */
+	g.regbol = string;
+
+	/* Simplest case:  anchored match need be tried only once. */
+	if (prog->reganch)
+		return(regtry(&g, prog, string));
+
+	/* Messy cases:  unanchored match. */
+	s = string;
+	if (prog->regstart != '\0')
+		/* We know what char it must start with. */
+		while ((s = strchr(s, prog->regstart)) != NULL) {
+			if (regtry(&g, prog, s))
+				return(1);
+			s++;
+		}
+	else
+		/* We don't -- general case. */
+		do {
+			if (regtry(&g, prog, s))
+				return(1);
+		} while (*s++ != '\0');
+
+	/* Failure. */
+	return(0);
+}
+
+/*
+ - regtry - try match at specific point
+ */
+static int			/* 0 failure, 1 success */
+regtry(struct match_globals *g, regexp *prog, char *string)
+{
+	register int i;
+	register char **sp;
+	register char **ep;
+
+	g->reginput = string;
+	g->regstartp = prog->startp;
+	g->regendp = prog->endp;
+
+	sp = prog->startp;
+	ep = prog->endp;
+	for (i = NSUBEXP; i > 0; i--) {
+		*sp++ = NULL;
+		*ep++ = NULL;
+	}
+	if (regmatch(g, prog->program + 1)) {
+		prog->startp[0] = string;
+		prog->endp[0] = g->reginput;
+		return(1);
+	} else
+		return(0);
+}
+
+/*
+ - regmatch - main matching routine
+ *
+ * Conceptually the strategy is simple:  check to see whether the current
+ * node matches, call self recursively to see whether the rest matches,
+ * and then act accordingly.  In practice we make some effort to avoid
+ * recursion, in particular by going through "ordinary" nodes (that don't
+ * need to know whether the rest of the match failed) by a loop instead of
+ * by recursion.
+ */
+static int			/* 0 failure, 1 success */
+regmatch(struct match_globals *g, char *prog)
+{
+	register char *scan = prog; /* Current node. */
+	char *next;		    /* Next node. */
+
+#ifdef DEBUG
+	if (scan != NULL && regnarrate)
+		fprintf(stderr, "%s(\n", regprop(scan));
+#endif
+	while (scan != NULL) {
+#ifdef DEBUG
+		if (regnarrate)
+			fprintf(stderr, "%s...\n", regprop(scan));
+#endif
+		next = regnext(g, scan);
+
+		switch (OP(scan)) {
+		case BOL:
+			if (g->reginput != g->regbol)
+				return(0);
+			break;
+		case EOL:
+			if (*g->reginput != '\0')
+				return(0);
+			break;
+		case ANY:
+			if (*g->reginput == '\0')
+				return(0);
+			g->reginput++;
+			break;
+		case EXACTLY: {
+				register int len;
+				register char *opnd;
+
+				opnd = OPERAND(scan);
+				/* Inline the first character, for speed. */
+				if (*opnd != *g->reginput)
+					return(0);
+				len = strlen(opnd);
+				if (len > 1 && strncmp(opnd, g->reginput, len) != 0)
+					return(0);
+				g->reginput += len;
+			}
+			break;
+		case ANYOF:
+			if (*g->reginput == '\0' || strchr(OPERAND(scan), *g->reginput) == NULL)
+				return(0);
+			g->reginput++;
+			break;
+		case ANYBUT:
+			if (*g->reginput == '\0' || strchr(OPERAND(scan), *g->reginput) != NULL)
+				return(0);
+			g->reginput++;
+			break;
+		case NOTHING:
+		case BACK:
+			break;
+		case OPEN+1:
+		case OPEN+2:
+		case OPEN+3:
+		case OPEN+4:
+		case OPEN+5:
+		case OPEN+6:
+		case OPEN+7:
+		case OPEN+8:
+		case OPEN+9: {
+				register int no;
+				register char *save;
+
+				no = OP(scan) - OPEN;
+				save = g->reginput;
+
+				if (regmatch(g, next)) {
+					/*
+					 * Don't set startp if some later
+					 * invocation of the same parentheses
+					 * already has.
+					 */
+					if (g->regstartp[no] == NULL)
+						g->regstartp[no] = save;
+					return(1);
+				} else
+					return(0);
+			}
+			break;
+		case CLOSE+1:
+		case CLOSE+2:
+		case CLOSE+3:
+		case CLOSE+4:
+		case CLOSE+5:
+		case CLOSE+6:
+		case CLOSE+7:
+		case CLOSE+8:
+		case CLOSE+9:
+			{
+				register int no;
+				register char *save;
+
+				no = OP(scan) - CLOSE;
+				save = g->reginput;
+
+				if (regmatch(g, next)) {
+					/*
+					 * Don't set endp if some later
+					 * invocation of the same parentheses
+					 * already has.
+					 */
+					if (g->regendp[no] == NULL)
+						g->regendp[no] = save;
+					return(1);
+				} else
+					return(0);
+			}
+			break;
+		case BRANCH: {
+				register char *save;
+
+				if (OP(next) != BRANCH)		/* No choice. */
+					next = OPERAND(scan);	/* Avoid recursion. */
+				else {
+					do {
+						save = g->reginput;
+						if (regmatch(g, OPERAND(scan)))
+							return(1);
+						g->reginput = save;
+						scan = regnext(g, scan);
+					} while (scan != NULL && OP(scan) == BRANCH);
+					return(0);
+					/* NOTREACHED */
+				}
+			}
+			break;
+		case STAR:
+		case PLUS: {
+				register char nextch;
+				register int no;
+				register char *save;
+				register int min;
+
+				/*
+				 * Lookahead to avoid useless match attempts
+				 * when we know what character comes next.
+				 */
+				nextch = '\0';
+				if (OP(next) == EXACTLY)
+					nextch = *OPERAND(next);
+				min = (OP(scan) == STAR) ? 0 : 1;
+				save = g->reginput;
+				no = regrepeat(g, OPERAND(scan));
+				while (no >= min) {
+					/* If it could work, try it. */
+					if (nextch == '\0' || *g->reginput == nextch)
+						if (regmatch(g, next))
+							return(1);
+					/* Couldn't or didn't -- back up. */
+					no--;
+					g->reginput = save + no;
+				}
+				return(0);
+			}
+			break;
+		case END:
+			return(1);	/* Success! */
+			break;
+		default:
+			printk("<3>Regexp: memory corruption\n");
+			return(0);
+			break;
+		}
+
+		scan = next;
+	}
+
+	/*
+	 * We get here only if there's trouble -- normally "case END" is
+	 * the terminating point.
+	 */
+	printk("<3>Regexp: corrupted pointers\n");
+	return(0);
+}
+
+/*
+ - regrepeat - repeatedly match something simple, report how many
+ */
+static int
+regrepeat(struct match_globals *g, char *p)
+{
+	register int count = 0;
+	register char *scan;
+	register char *opnd;
+
+	scan = g->reginput;
+	opnd = OPERAND(p);
+	switch (OP(p)) {
+	case ANY:
+		count = strlen(scan);
+		scan += count;
+		break;
+	case EXACTLY:
+		while (*opnd == *scan) {
+			count++;
+			scan++;
+		}
+		break;
+	case ANYOF:
+		while (*scan != '\0' && strchr(opnd, *scan) != NULL) {
+			count++;
+			scan++;
+		}
+		break;
+	case ANYBUT:
+		while (*scan != '\0' && strchr(opnd, *scan) == NULL) {
+			count++;
+			scan++;
+		}
+		break;
+	default:		/* Oh dear.  Called inappropriately. */
+		printk("<3>Regexp: internal foulup\n");
+		count = 0;	/* Best compromise. */
+		break;
+	}
+	g->reginput = scan;
+
+	return(count);
+}
+
+/*
+ - regnext - dig the "next" pointer out of a node
+ */
+static char*
+regnext(struct match_globals *g, char *p)
+{
+	register int offset;
+
+	if (p == &g->regdummy)
+		return(NULL);
+
+	offset = NEXT(p);
+	if (offset == 0)
+		return(NULL);
+
+	if (OP(p) == BACK)
+		return(p-offset);
+	else
+		return(p+offset);
+}
+
+#ifdef DEBUG
+
+STATIC char *regprop();
+
+/*
+ - regdump - dump a regexp onto stdout in vaguely comprehensible form
+ */
+void
+regdump(regexp *r)
+{
+	register char *s;
+	register char op = EXACTLY;	/* Arbitrary non-END op. */
+	register char *next;
+	/* extern char *strchr(); */
+
+
+	s = r->program + 1;
+	while (op != END) {	/* While that wasn't END last time... */
+		op = OP(s);
+		printf("%2d%s", s-r->program, regprop(s));	/* Where, what. */
+		next = regnext(s);
+		if (next == NULL)		/* Next ptr. */
+			printf("(0)");
+		else
+			printf("(%d)", (s-r->program)+(next-s));
+		s += 3;
+		if (op == ANYOF || op == ANYBUT || op == EXACTLY) {
+			/* Literal string, where present. */
+			while (*s != '\0') {
+				putchar(*s);
+				s++;
+			}
+			s++;
+		}
+		putchar('\n');
+	}
+
+	/* Header fields of interest. */
+	if (r->regstart != '\0')
+		printf("start `%c' ", r->regstart);
+	if (r->reganch)
+		printf("anchored ");
+	if (r->regmust != NULL)
+		printf("must have \"%s\"", r->regmust);
+	printf("\n");
+}
+
+/*
+ - regprop - printable representation of opcode
+ */
+static char *
+regprop(char *op)
+{
+#define BUFLEN 50
+	register char *p;
+	static char buf[BUFLEN];
+
+	strcpy(buf, ":");
+
+	switch (OP(op)) {
+	case BOL:
+		p = "BOL";
+		break;
+	case EOL:
+		p = "EOL";
+		break;
+	case ANY:
+		p = "ANY";
+		break;
+	case ANYOF:
+		p = "ANYOF";
+		break;
+	case ANYBUT:
+		p = "ANYBUT";
+		break;
+	case BRANCH:
+		p = "BRANCH";
+		break;
+	case EXACTLY:
+		p = "EXACTLY";
+		break;
+	case NOTHING:
+		p = "NOTHING";
+		break;
+	case BACK:
+		p = "BACK";
+		break;
+	case END:
+		p = "END";
+		break;
+	case OPEN+1:
+	case OPEN+2:
+	case OPEN+3:
+	case OPEN+4:
+	case OPEN+5:
+	case OPEN+6:
+	case OPEN+7:
+	case OPEN+8:
+	case OPEN+9:
+		snprintf(buf+strlen(buf),BUFLEN-strlen(buf), "OPEN%d", OP(op)-OPEN);
+		p = NULL;
+		break;
+	case CLOSE+1:
+	case CLOSE+2:
+	case CLOSE+3:
+	case CLOSE+4:
+	case CLOSE+5:
+	case CLOSE+6:
+	case CLOSE+7:
+	case CLOSE+8:
+	case CLOSE+9:
+		snprintf(buf+strlen(buf),BUFLEN-strlen(buf), "CLOSE%d", OP(op)-CLOSE);
+		p = NULL;
+		break;
+	case STAR:
+		p = "STAR";
+		break;
+	case PLUS:
+		p = "PLUS";
+		break;
+	default:
+		printk("<3>Regexp: corrupted opcode\n");
+		break;
+	}
+	if (p != NULL)
+		strncat(buf, p, BUFLEN-strlen(buf));
+	return(buf);
+}
+#endif
+
+
Index: linux-2.6.21/net/netfilter/regexp/regexp.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/net/netfilter/regexp/regexp.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,41 @@
+/*
+ * Definitions etc. for regexp(3) routines.
+ *
+ * Caveat:  this is V8 regexp(3) [actually, a reimplementation thereof],
+ * not the System V one.
+ */
+
+#ifndef REGEXP_H
+#define REGEXP_H
+
+
+/*
+http://www.opensource.apple.com/darwinsource/10.3/expect-1/expect/expect.h ,
+which contains a version of this library, says:
+
+ *
+ * NSUBEXP must be at least 10, and no greater than 117 or the parser
+ * will not work properly.
+ *
+
+However, it looks rather like this library is limited to 10.  If you think
+otherwise, let us know.
+*/
+
+#define NSUBEXP  10
+typedef struct regexp {
+	char *startp[NSUBEXP];
+	char *endp[NSUBEXP];
+	char regstart;		/* Internal use only. */
+	char reganch;		/* Internal use only. */
+	char *regmust;		/* Internal use only. */
+	int regmlen;		/* Internal use only. */
+	char program[1];	/* Unwarranted chumminess with compiler. */
+} regexp;
+
+regexp * regcomp(char *exp, int *patternsize);
+int regexec(regexp *prog, char *string);
+void regsub(regexp *prog, char *source, char *dest);
+void regerror(char *s);
+
+#endif
Index: linux-2.6.21/net/netfilter/regexp/regmagic.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/net/netfilter/regexp/regmagic.h	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,5 @@
+/*
+ * The first byte of the regexp internal "program" is actually this magic
+ * number; the start node begins in the second byte.
+ */
+#define	MAGIC	0234
Index: linux-2.6.21/net/netfilter/regexp/regsub.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/net/netfilter/regexp/regsub.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,95 @@
+/*
+ * regsub
+ * @(#)regsub.c	1.3 of 2 April 86
+ *
+ *	Copyright (c) 1986 by University of Toronto.
+ *	Written by Henry Spencer.  Not derived from licensed software.
+ *
+ *	Permission is granted to anyone to use this software for any
+ *	purpose on any computer system, and to redistribute it freely,
+ *	subject to the following restrictions:
+ *
+ *	1. The author is not responsible for the consequences of use of
+ *		this software, no matter how awful, even if they arise
+ *		from defects in it.
+ *
+ *	2. The origin of this software must not be misrepresented, either
+ *		by explicit claim or by omission.
+ *
+ *	3. Altered versions must be plainly marked as such, and must not
+ *		be misrepresented as being the original software.
+ *
+ *
+ * This code was modified by Ethan Sommer to work within the kernel
+ * (it now uses kmalloc etc..)
+ *
+ */
+#include "regexp.h"
+#include "regmagic.h"
+#include <linux/string.h>
+
+
+#ifndef CHARBITS
+#define	UCHARAT(p)	((int)*(unsigned char *)(p))
+#else
+#define	UCHARAT(p)	((int)*(p)&CHARBITS)
+#endif
+
+#if 0
+//void regerror(char * s)
+//{
+//        printk("regexp(3): %s", s);
+//        /* NOTREACHED */
+//}
+#endif
+
+/*
+ - regsub - perform substitutions after a regexp match
+ */
+void
+regsub(regexp * prog, char * source, char * dest)
+{
+	register char *src;
+	register char *dst;
+	register char c;
+	register int no;
+	register int len;
+	
+	/* Not necessary and gcc doesn't like it -MLS */
+	/*extern char *strncpy();*/
+
+	if (prog == NULL || source == NULL || dest == NULL) {
+		regerror("NULL parm to regsub");
+		return;
+	}
+	if (UCHARAT(prog->program) != MAGIC) {
+		regerror("damaged regexp fed to regsub");
+		return;
+	}
+
+	src = source;
+	dst = dest;
+	while ((c = *src++) != '\0') {
+		if (c == '&')
+			no = 0;
+		else if (c == '\\' && '0' <= *src && *src <= '9')
+			no = *src++ - '0';
+		else
+			no = -1;
+
+		if (no < 0) {	/* Ordinary character. */
+			if (c == '\\' && (*src == '\\' || *src == '&'))
+				c = *src++;
+			*dst++ = c;
+		} else if (prog->startp[no] != NULL && prog->endp[no] != NULL) {
+			len = prog->endp[no] - prog->startp[no];
+			(void) strncpy(dst, prog->startp[no], len);
+			dst += len;
+			if (len != 0 && *(dst-1) == '\0') {	/* strncpy hit NUL. */
+				regerror("damaged match string");
+				return;
+			}
+		}
+	}
+	*dst++ = '\0';
+}
Index: linux-2.6.21/net/netfilter/xt_layer7.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/net/netfilter/xt_layer7.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,626 @@
+/*
+  Kernel module to match application layer (OSI layer 7) data in connections.
+
+  http://l7-filter.sf.net
+
+  (C) 2003, 2004, 2005, 2006, 2007 Matthew Strait and Ethan Sommer.
+
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU General Public License
+  as published by the Free Software Foundation; either version
+  2 of the License, or (at your option) any later version.
+  http://www.gnu.org/licenses/gpl.txt
+
+  Based on ipt_string.c (C) 2000 Emmanuel Roger <winfield@freegates.be>,
+  xt_helper.c (C) 2002 Harald Welte and cls_layer7.c (C) 2003 Matthew Strait,
+  Ethan Sommer, Justin Levandoski.
+*/
+
+#include <linux/spinlock.h>
+#include <net/ip.h>
+#include <net/tcp.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/netfilter.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_core.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_layer7.h>
+#include <net/netfilter/nf_conntrack_compat.h>
+#include <linux/ctype.h>
+#include <linux/proc_fs.h>
+
+#include "regexp/regexp.c"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Matthew Strait <quadong@users.sf.net>, Ethan Sommer <sommere@users.sf.net>");
+MODULE_DESCRIPTION("iptables application layer match module");
+MODULE_ALIAS("ipt_layer7");
+MODULE_VERSION("2.0");
+
+static int maxdatalen = 2048; // this is the default
+module_param(maxdatalen, int, 0444);
+MODULE_PARM_DESC(maxdatalen, "maximum bytes of data looked at by l7-filter");
+#ifdef CONFIG_NETFILTER_XT_MATCH_LAYER7_DEBUG
+	#define DPRINTK(format,args...) printk(format,##args)
+#else
+	#define DPRINTK(format,args...)
+#endif
+
+#define TOTAL_PACKETS master_conntrack->counters[IP_CT_DIR_ORIGINAL].packets + \
+		      master_conntrack->counters[IP_CT_DIR_REPLY].packets
+
+/* Number of packets whose data we look at.
+This can be modified through /proc/net/layer7_numpackets */
+static int num_packets = 10;
+
+static struct pattern_cache {
+	char * regex_string;
+	regexp * pattern;
+	struct pattern_cache * next;
+} * first_pattern_cache = NULL;
+
+DEFINE_SPINLOCK(l7_lock);
+
+#ifdef CONFIG_IP_NF_MATCH_LAYER7_DEBUG
+/* Converts an unfriendly string into a friendly one by
+replacing unprintables with periods and all whitespace with " ". */
+static char * friendly_print(unsigned char * s)
+{
+	char * f = kmalloc(strlen(s) + 1, GFP_ATOMIC);
+	int i;
+
+	if(!f) {
+		if (net_ratelimit())
+			printk(KERN_ERR "layer7: out of memory in "
+					"friendly_print, bailing.\n");
+		return NULL;
+	}
+
+	for(i = 0; i < strlen(s); i++){
+		if(isprint(s[i]) && s[i] < 128)	f[i] = s[i];
+		else if(isspace(s[i]))		f[i] = ' ';
+		else 				f[i] = '.';
+	}
+	f[i] = '\0';
+	return f;
+}
+
+static char dec2hex(int i)
+{
+	switch (i) {
+		case 0 ... 9:
+			return (char)(i + '0');
+			break;
+		case 10 ... 15:
+			return (char)(i - 10 + 'a');
+			break;
+		default:
+			if (net_ratelimit())
+				printk("Problem in dec2hex\n");
+			return '\0';
+	}
+}
+
+static char * hex_print(unsigned char * s)
+{
+	char * g = kmalloc(strlen(s)*3 + 1, GFP_ATOMIC);
+	int i;
+
+	if(!g) {
+	       if (net_ratelimit())
+			printk(KERN_ERR "layer7: out of memory in hex_print, "
+					"bailing.\n");
+	       return NULL;
+	}
+
+	for(i = 0; i < strlen(s); i++) {
+		g[i*3    ] = dec2hex(s[i]/16);
+		g[i*3 + 1] = dec2hex(s[i]%16);
+		g[i*3 + 2] = ' ';
+	}
+	g[i*3] = '\0';
+
+	return g;
+}
+#endif // DEBUG
+
+/* Use instead of regcomp.  As we expect to be seeing the same regexps over and
+over again, it make sense to cache the results. */
+static regexp * compile_and_cache(char * regex_string, char * protocol)
+{
+	struct pattern_cache * node               = first_pattern_cache;
+	struct pattern_cache * last_pattern_cache = first_pattern_cache;
+	struct pattern_cache * tmp;
+	unsigned int len;
+
+	while (node != NULL) {
+		if (!strcmp(node->regex_string, regex_string))
+		return node->pattern;
+
+		last_pattern_cache = node;/* points at the last non-NULL node */
+		node = node->next;
+	}
+
+	/* If we reach the end of the list, then we have not yet cached
+	   the pattern for this regex. Let's do that now.
+	   Be paranoid about running out of memory to avoid list corruption. */
+	tmp = kmalloc(sizeof(struct pattern_cache), GFP_ATOMIC);
+
+	if(!tmp) {
+		if (net_ratelimit())
+			printk(KERN_ERR "layer7: out of memory in "
+					"compile_and_cache, bailing.\n");
+		return NULL;
+	}
+
+	tmp->regex_string  = kmalloc(strlen(regex_string) + 1, GFP_ATOMIC);
+	tmp->pattern       = kmalloc(sizeof(struct regexp),    GFP_ATOMIC);
+	tmp->next = NULL;
+
+	if(!tmp->regex_string || !tmp->pattern) {
+		if (net_ratelimit())
+			printk(KERN_ERR "layer7: out of memory in "
+					"compile_and_cache, bailing.\n");
+		kfree(tmp->regex_string);
+		kfree(tmp->pattern);
+		kfree(tmp);
+		return NULL;
+	}
+
+	/* Ok.  The new node is all ready now. */
+	node = tmp;
+
+	if(first_pattern_cache == NULL) /* list is empty */
+		first_pattern_cache = node; /* make node the beginning */
+	else
+		last_pattern_cache->next = node; /* attach node to the end */
+
+	/* copy the string and compile the regex */
+	len = strlen(regex_string);
+	DPRINTK("About to compile this: \"%s\"\n", regex_string);
+	node->pattern = regcomp(regex_string, &len);
+	if ( !node->pattern ) {
+		if (net_ratelimit())
+			printk(KERN_ERR "layer7: Error compiling regexp "
+					"\"%s\" (%s)\n", 
+					regex_string, protocol);
+		/* pattern is now cached as NULL, so we won't try again. */
+	}
+
+	strcpy(node->regex_string, regex_string);
+	return node->pattern;
+}
+
+static int can_handle(const struct sk_buff *skb)
+{
+	if(!skb->nh.iph) /* not IP */
+		return 0;
+	if(skb->nh.iph->protocol != IPPROTO_TCP &&
+	   skb->nh.iph->protocol != IPPROTO_UDP &&
+	   skb->nh.iph->protocol != IPPROTO_ICMP)
+		return 0;
+	return 1;
+}
+
+/* Returns offset the into the skb->data that the application data starts */
+static int app_data_offset(const struct sk_buff *skb)
+{
+	/* In case we are ported somewhere (ebtables?) where skb->nh.iph
+	isn't set, this can be gotten from 4*(skb->data[0] & 0x0f) as well. */
+	int ip_hl = 4*skb->nh.iph->ihl;
+
+	if( skb->nh.iph->protocol == IPPROTO_TCP ) {
+		/* 12 == offset into TCP header for the header length field.
+		Can't get this with skb->h.th->doff because the tcphdr
+		struct doesn't get set when routing (this is confirmed to be
+		true in Netfilter as well as QoS.) */
+		int tcp_hl = 4*(skb->data[ip_hl + 12] >> 4);
+
+		return ip_hl + tcp_hl;
+	} else if( skb->nh.iph->protocol == IPPROTO_UDP  ) {
+		return ip_hl + 8; /* UDP header is always 8 bytes */
+	} else if( skb->nh.iph->protocol == IPPROTO_ICMP ) {
+		return ip_hl + 8; /* ICMP header is 8 bytes */
+	} else {
+		if (net_ratelimit())
+			printk(KERN_ERR "layer7: tried to handle unknown "
+					"protocol!\n");
+		return ip_hl + 8; /* something reasonable */
+	}
+}
+
+/* handles whether there's a match when we aren't appending data anymore */
+static int match_no_append(struct nf_conn * conntrack, 
+                           struct nf_conn * master_conntrack, 
+                           enum ip_conntrack_info ctinfo,
+                           enum ip_conntrack_info master_ctinfo,
+                           struct xt_layer7_info * info)
+{
+	/* If we're in here, throw the app data away */
+	if(master_conntrack->layer7.app_data != NULL) {
+
+	#ifdef CONFIG_IP_NF_MATCH_LAYER7_DEBUG
+		if(!master_conntrack->layer7.app_proto) {
+			char * f = 
+			  friendly_print(master_conntrack->layer7.app_data);
+			char * g = 
+			  hex_print(master_conntrack->layer7.app_data);
+			DPRINTK("\nl7-filter gave up after %d bytes "
+				"(%d packets):\n%s\n",
+				strlen(f), TOTAL_PACKETS, f);
+			kfree(f);
+			DPRINTK("In hex: %s\n", g);
+			kfree(g);
+		}
+	#endif
+
+		kfree(master_conntrack->layer7.app_data);
+		master_conntrack->layer7.app_data = NULL; /* don't free again */
+	}
+
+	if(master_conntrack->layer7.app_proto){
+		/* Here child connections set their .app_proto (for /proc) */
+		if(!conntrack->layer7.app_proto) {
+			conntrack->layer7.app_proto = 
+			  kmalloc(strlen(master_conntrack->layer7.app_proto)+1, 
+			    GFP_ATOMIC);
+			if(!conntrack->layer7.app_proto){
+				if (net_ratelimit())
+					printk(KERN_ERR "layer7: out of memory "
+							"in match_no_append, "
+							"bailing.\n");
+				return 1;
+			}
+			strcpy(conntrack->layer7.app_proto, 
+				master_conntrack->layer7.app_proto);
+		}
+
+		return (!strcmp(master_conntrack->layer7.app_proto, 
+				info->protocol));
+	}
+	else {
+		/* If not classified, set to "unknown" to distinguish from
+		connections that are still being tested. */
+		master_conntrack->layer7.app_proto = 
+			kmalloc(strlen("unknown")+1, GFP_ATOMIC);
+		if(!master_conntrack->layer7.app_proto){
+			if (net_ratelimit())
+				printk(KERN_ERR "layer7: out of memory in "
+						"match_no_append, bailing.\n");
+			return 1;
+		}
+		strcpy(master_conntrack->layer7.app_proto, "unknown");
+		return 0;
+	}
+}
+
+/* add the new app data to the conntrack.  Return number of bytes added. */
+static int add_data(struct nf_conn * master_conntrack,
+                    char * app_data, int appdatalen)
+{
+	int length = 0, i;
+	int oldlength = master_conntrack->layer7.app_data_len;
+
+	/* This is a fix for a race condition by Deti Fliegl. However, I'm not 
+	   clear on whether the race condition exists or whether this really 
+	   fixes it.  I might just be being dense... Anyway, if it's not really 
+	   a fix, all it does is waste a very small amount of time. */
+	if(!master_conntrack->layer7.app_data) return 0;
+
+	/* Strip nulls. Make everything lower case (our regex lib doesn't
+	do case insensitivity).  Add it to the end of the current data. */
+	for(i = 0; i < maxdatalen-oldlength-1 &&
+		   i < appdatalen; i++) {
+		if(app_data[i] != '\0') {
+			/* the kernel version of tolower mungs 'upper ascii' */
+			master_conntrack->layer7.app_data[length+oldlength] =
+				isascii(app_data[i])? 
+					tolower(app_data[i]) : app_data[i];
+			length++;
+		}
+	}
+
+	master_conntrack->layer7.app_data[length+oldlength] = '\0';
+	master_conntrack->layer7.app_data_len = length + oldlength;
+
+	return length;
+}
+
+/* taken from drivers/video/modedb.c */
+static int my_atoi(const char *s)
+{
+	int val = 0;
+
+	for (;; s++) {
+		switch (*s) {
+			case '0'...'9':
+			val = 10*val+(*s-'0');
+			break;
+		default:
+			return val;
+		}
+	}
+}
+
+/* write out num_packets to userland. */
+static int layer7_read_proc(char* page, char ** start, off_t off, int count,
+                            int* eof, void * data)
+{
+	if(num_packets > 99 && net_ratelimit())
+		printk(KERN_ERR "layer7: NOT REACHED. num_packets too big\n");
+
+	page[0] = num_packets/10 + '0';
+	page[1] = num_packets%10 + '0';
+	page[2] = '\n';
+	page[3] = '\0';
+
+	*eof=1;
+
+	return 3;
+}
+
+/* Read in num_packets from userland */
+static int layer7_write_proc(struct file* file, const char* buffer,
+                             unsigned long count, void *data)
+{
+	char * foo = kmalloc(count, GFP_ATOMIC);
+
+	if(!foo){
+		if (net_ratelimit())
+			printk(KERN_ERR "layer7: out of memory, bailing. "
+					"num_packets unchanged.\n");
+		return count;
+	}
+
+	if(copy_from_user(foo, buffer, count)) {
+		return -EFAULT;
+	}
+
+
+	num_packets = my_atoi(foo);
+	kfree (foo);
+
+	/* This has an arbitrary limit to make the math easier. I'm lazy.
+	But anyway, 99 is a LOT! If you want more, you're doing it wrong! */
+	if(num_packets > 99) {
+		printk(KERN_WARNING "layer7: num_packets can't be > 99.\n");
+		num_packets = 99;
+	} else if(num_packets < 1) {
+		printk(KERN_WARNING "layer7: num_packets can't be < 1.\n");
+		num_packets = 1;
+	}
+
+	return count;
+}
+
+static int
+match(const struct sk_buff *skbin,
+      const struct net_device *in,
+      const struct net_device *out,
+      const struct xt_match *match,
+      const void *matchinfo,
+      int offset,
+      unsigned int protoff,
+      int *hotdrop)
+{
+	/* sidestep const without getting a compiler warning... */
+	struct sk_buff * skb = (struct sk_buff *)skbin; 
+
+	struct xt_layer7_info * info = (struct xt_layer7_info *)matchinfo;
+	enum ip_conntrack_info master_ctinfo, ctinfo;
+	struct nf_conn *master_conntrack, *conntrack;
+	unsigned char * app_data;
+	unsigned int pattern_result, appdatalen;
+	regexp * comppattern;
+
+	/* Be paranoid/incompetent - lock the entire match function. */
+	spin_lock_bh(&l7_lock);
+
+	if(!can_handle(skb)){
+		DPRINTK("layer7: This is some protocol I can't handle.\n");
+		spin_unlock_bh(&l7_lock);
+		return info->invert;
+	}
+
+	/* Treat parent & all its children together as one connection, except
+	for the purpose of setting conntrack->layer7.app_proto in the actual
+	connection. This makes /proc/net/ip_conntrack more satisfying. */
+	if(!(conntrack = nf_ct_get((struct sk_buff *)skb, &ctinfo)) ||
+	   !(master_conntrack=nf_ct_get((struct sk_buff *)skb,&master_ctinfo))){
+		DPRINTK("layer7: couldn't get conntrack.\n");
+		spin_unlock_bh(&l7_lock);
+		return info->invert;
+	}
+
+	/* Try to get a master conntrack (and its master etc) for FTP, etc. */
+	while (master_ct(master_conntrack) != NULL)
+		master_conntrack = master_ct(master_conntrack);
+
+	/* if we've classified it or seen too many packets */
+	if(TOTAL_PACKETS > num_packets ||
+	   master_conntrack->layer7.app_proto) {
+
+		pattern_result = match_no_append(conntrack, master_conntrack, 
+						 ctinfo, master_ctinfo, info);
+
+		/* skb->cb[0] == seen. Don't do things twice if there are 
+		multiple l7 rules. I'm not sure that using cb for this purpose 
+		is correct, even though it says "put your private variables 
+		there". But it doesn't look like it is being used for anything
+		else in the skbs that make it here. */
+		skb->cb[0] = 1; /* marking it seen here's probably irrelevant */
+
+		spin_unlock_bh(&l7_lock);
+		return (pattern_result ^ info->invert);
+	}
+
+	if(skb_is_nonlinear(skb)){
+		if(skb_linearize(skb) != 0){
+			if (net_ratelimit())
+				printk(KERN_ERR "layer7: failed to linearize "
+						"packet, bailing.\n");
+			spin_unlock_bh(&l7_lock);
+			return info->invert;
+		}
+	}
+
+	/* now that the skb is linearized, it's safe to set these. */
+	app_data = skb->data + app_data_offset(skb);
+	appdatalen = skb->tail - app_data;
+
+	/* the return value gets checked later, when we're ready to use it */
+	comppattern = compile_and_cache(info->pattern, info->protocol);
+
+	/* On the first packet of a connection, allocate space for app data */
+	if(TOTAL_PACKETS == 1 && !skb->cb[0] && 
+	   !master_conntrack->layer7.app_data){
+		master_conntrack->layer7.app_data = 
+			kmalloc(maxdatalen, GFP_ATOMIC);
+		if(!master_conntrack->layer7.app_data){
+			if (net_ratelimit())
+				printk(KERN_ERR "layer7: out of memory in "
+						"match, bailing.\n");
+			spin_unlock_bh(&l7_lock);
+			return info->invert;
+		}
+
+		master_conntrack->layer7.app_data[0] = '\0';
+	}
+
+	/* Can be here, but unallocated, if numpackets is increased near
+	the beginning of a connection */
+	if(master_conntrack->layer7.app_data == NULL){
+		spin_unlock_bh(&l7_lock);
+		return (info->invert); /* unmatched */
+	}
+
+	if(!skb->cb[0]){
+		int newbytes;
+		newbytes = add_data(master_conntrack, app_data, appdatalen);
+
+		if(newbytes == 0) { /* didn't add any data */
+			skb->cb[0] = 1;
+			/* Didn't match before, not going to match now */
+			spin_unlock_bh(&l7_lock);
+			return info->invert;
+		}
+	}
+
+	/* If looking for "unknown", then never match.  "Unknown" means that
+	we've given up; we're still trying with these packets. */
+	if(!strcmp(info->protocol, "unknown")) {
+		pattern_result = 0;
+	/* If looking for "unset", then always match. "Unset" means that we
+	haven't yet classified the connection. */
+	} else if(!strcmp(info->protocol, "unset")) {
+		pattern_result = 2;
+		DPRINTK("layer7: matched unset: not yet classified "
+			"(%d/%d packets)\n", TOTAL_PACKETS, num_packets);
+	/* If the regexp failed to compile, don't bother running it */
+	} else if(comppattern && 
+		  regexec(comppattern, master_conntrack->layer7.app_data)){
+		DPRINTK("layer7: matched %s\n", info->protocol);
+		pattern_result = 1;
+	} else pattern_result = 0;
+
+	if(pattern_result == 1) {
+		master_conntrack->layer7.app_proto = 
+			kmalloc(strlen(info->protocol)+1, GFP_ATOMIC);
+		if(!master_conntrack->layer7.app_proto){
+			if (net_ratelimit())
+				printk(KERN_ERR "layer7: out of memory in "
+						"match, bailing.\n");
+			spin_unlock_bh(&l7_lock);
+			return (pattern_result ^ info->invert);
+		}
+		strcpy(master_conntrack->layer7.app_proto, info->protocol);
+	} else if(pattern_result > 1) { /* cleanup from "unset" */
+		pattern_result = 1;
+	}
+
+	/* mark the packet seen */
+	skb->cb[0] = 1;
+
+	spin_unlock_bh(&l7_lock);
+	return (pattern_result ^ info->invert);
+}
+
+static int check(const char *tablename,
+		 const void *inf,
+		 const struct xt_match *match,
+		 void *matchinfo,
+		 unsigned int hook_mask)
+
+{
+	// load nf_conntrack_ipv4
+        if (nf_ct_l3proto_try_module_get(match->family) < 0) {
+                printk(KERN_WARNING "can't load conntrack support for "
+                                    "proto=%d\n", match->family);
+                return 0;
+        }
+	return 1;
+}
+
+static void
+destroy(const struct xt_match *match, void *matchinfo)
+{
+	nf_ct_l3proto_module_put(match->family);
+}
+
+static struct xt_match xt_layer7_match[] = {
+{
+	.name		= "layer7",
+	.family		= AF_INET,
+	.checkentry	= check,
+	.match		= match,
+	.destroy	= destroy,
+	.matchsize	= sizeof(struct xt_layer7_info),
+	.me		= THIS_MODULE
+}
+};
+
+static void layer7_cleanup_proc(void)
+{
+	remove_proc_entry("layer7_numpackets", proc_net);
+}
+
+/* register the proc file */
+static void layer7_init_proc(void)
+{
+	struct proc_dir_entry* entry;
+	entry = create_proc_entry("layer7_numpackets", 0644, proc_net);
+	entry->read_proc = layer7_read_proc;
+	entry->write_proc = layer7_write_proc;
+}
+
+static int __init xt_layer7_init(void)
+{
+	need_conntrack();
+
+	layer7_init_proc();
+	if(maxdatalen < 1) {
+		printk(KERN_WARNING "layer7: maxdatalen can't be < 1, "
+			"using 1\n");
+		maxdatalen = 1;
+	}
+	/* This is not a hard limit.  It's just here to prevent people from
+	bringing their slow machines to a grinding halt. */
+	else if(maxdatalen > 65536) {
+		printk(KERN_WARNING "layer7: maxdatalen can't be > 65536, "
+			"using 65536\n");
+		maxdatalen = 65536;
+	}
+	return xt_register_matches(xt_layer7_match,
+				   ARRAY_SIZE(xt_layer7_match));
+}
+
+static void __exit xt_layer7_fini(void)
+{
+	layer7_cleanup_proc();
+	xt_unregister_matches(xt_layer7_match, ARRAY_SIZE(xt_layer7_match));
+}
+
+module_init(xt_layer7_init);
+module_exit(xt_layer7_fini);
+
Index: linux-2.6.21/net/netfilter/xt_realm.c
===================================================================
--- linux-2.6.21.orig/net/netfilter/xt_realm.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/netfilter/xt_realm.c	2009-11-30 12:44:56.000000000 +0100
@@ -1,6 +1,6 @@
 /* IP tables module for matching the routing realm
  *
- * $Id: ipt_realm.c,v 1.3 2004/03/05 13:25:40 laforge Exp $
+ * $Id: xt_realm.c,v 1.1.1.1 2007-05-25 06:49:59 bruce Exp $
  *
  * (C) 2003 by Sampsa Ranta <sampsa@netsonic.fi>
  *
Index: linux-2.6.21/net/netfilter/xt_webstr.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/net/netfilter/xt_webstr.c	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,469 @@
+/* Kernel module to match a string into a packet.
+ *
+ * Copyright (C) 2000 Emmanuel Roger  <winfield@freegates.be>
+ * 
+ * ChangeLog
+ *	19.02.2002: Gianni Tedesco <gianni@ecsc.co.uk>
+ *		Fixed SMP re-entrancy problem using per-cpu data areas
+ *		for the skip/shift tables.
+ *	02.05.2001: Gianni Tedesco <gianni@ecsc.co.uk>
+ *		Fixed kernel panic, due to overrunning boyer moore string
+ *		tables. Also slightly tweaked heuristic for deciding what
+ * 		search algo to use.
+ * 	27.01.2001: Gianni Tedesco <gianni@ecsc.co.uk>
+ * 		Implemented Boyer Moore Sublinear search algorithm
+ * 		alongside the existing linear search based on memcmp().
+ * 		Also a quick check to decide which method to use on a per
+ * 		packet basis.
+ */
+
+/* Kernel module to match a http header string into a packet.
+ *
+ * Copyright (C) 2003, CyberTAN Corporation
+ * All Rights Reserved.
+ *
+ * Description:
+ *   This is kernel module for web content inspection. It was derived from 
+ *   'string' match module, declared as above.
+ *
+ *   The module follows the Netfilter framework, called extended packet 
+ *   matching modules. 
+ */
+
+/* Linux Kernel 2.6 Port ( 2.4 ipt-> 2.6 xt)
+ * Copyright (C) 2008, Ralink Technology Corporation. 
+ * All Rights Reserved.
+ */
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <net/sock.h>
+
+#define BM_MAX_NLEN 256
+#define BM_MAX_HLEN 1024
+
+#define BLK_JAVA        0x01
+#define BLK_ACTIVE      0x02
+#define BLK_COOKIE      0x04
+#define BLK_PROXY       0x08
+
+typedef char *(*proc_ipt_search) (char *, char *, int, int);
+
+struct ipt_webstr_info {
+    char string[BM_MAX_NLEN];
+    u_int16_t invert;
+    u_int16_t len;
+    u_int8_t type;
+};
+
+enum xt_webstr_type
+{
+    IPT_WEBSTR_HOST,
+    IPT_WEBSTR_URL,
+    IPT_WEBSTR_CONTENT
+};
+
+
+#define	isdigit(x) ((x) >= '0' && (x) <= '9')
+#define	isupper(x) (((unsigned)(x) >= 'A') && ((unsigned)(x) <= 'Z'))
+#define	islower(x) (((unsigned)(x) >= 'a') && ((unsigned)(x) <= 'z'))
+#define	isalpha(x) (isupper(x) || islower(x))
+#define	toupper(x) (isupper(x) ? (x) : (x) - 'a' + 'A')
+#define tolower(x) (isupper(x) ? ((x) - 'A' + 'a') : (x))
+
+#define split(word, wordlist, next, delim) \
+    for (next = wordlist, \
+	strncpy(word, next, sizeof(word)), \
+	word[(next=strstr(next, delim)) ? strstr(word, delim) - word : sizeof(word) - 1] = '\0', \
+	next = next ? next + sizeof(delim) - 1 : NULL ; \
+	strlen(word); \
+	next = next ? : "", \
+	strncpy(word, next, sizeof(word)), \
+	word[(next=strstr(next, delim)) ? strstr(word, delim) - word : sizeof(word) - 1] = '\0', \
+	next = next ? next + sizeof(delim) - 1 : NULL)
+
+#define BUFSIZE 	1024
+
+/* Flags for get_http_info() */
+#define HTTP_HOST	0x01
+#define HTTP_URL	0x02
+/* Flags for mangle_http_header() */
+#define HTTP_COOKIE	0x04
+
+#if 0
+#define SPARQ_LOG       printk
+#else
+#define SPARQ_LOG(format, args...)
+#endif
+
+typedef struct httpinfo {
+    char host[BUFSIZE + 1];
+    int hostlen;
+    char url[BUFSIZE + 1];
+    int urllen;
+} httpinfo_t;
+
+/* Return 1 for match, 0 for accept, -1 for partial. */
+static int find_pattern2(const char *data, size_t dlen,
+	const char *pattern, size_t plen,
+	char term,
+	unsigned int *numoff,
+	unsigned int *numlen)
+{
+    size_t i, j, k;
+    int state = 0;
+    *numoff = *numlen = 0;
+
+    SPARQ_LOG("%s: pattern = '%s', dlen = %u\n",__FUNCTION__, pattern, dlen);
+    if (dlen == 0)
+	return 0;
+
+    if (dlen <= plen) {	/* Short packet: try for partial? */
+	if (strnicmp(data, pattern, dlen) == 0)
+	    return -1;
+	else 
+	    return 0;
+    }
+    for (i = 0; i <= (dlen - plen); i++) {
+	/* DFA : \r\n\r\n :: 1234 */
+	if (*(data + i) == '\r') {
+	    if (!(state % 2)) state++;	/* forwarding move */
+	    else state = 0;		/* reset */
+	}
+	else if (*(data + i) == '\n') {
+	    if (state % 2) state++;
+	    else state = 0;
+	}
+	else state = 0;
+
+	if (state >= 4)
+	    break;
+
+	/* pattern compare */
+	if (memcmp(data + i, pattern, plen ) != 0)
+	    continue;
+
+	/* Here, it means patten match!! */
+	*numoff=i + plen;
+	for (j = *numoff, k = 0; data[j] != term; j++, k++)
+	    if (j > dlen) return -1 ;	/* no terminal char */
+
+	*numlen = k;
+	return 1;
+    }
+    return 0;
+}
+
+#if 0
+static int mangle_http_header(const struct sk_buff *skb, int flags)
+{
+    struct iphdr *iph = (skb)->nh.iph;
+    struct tcphdr *tcph = (void *)iph + iph->ihl*4;
+    unsigned char *data = (void *)tcph + tcph->doff*4;
+    unsigned int datalen = (skb)->len - (iph->ihl*4) - (tcph->doff*4);
+
+    int found, offset, len;
+    int ret = 0;
+
+
+    SPARQ_LOG("%s: seq=%u\n", __FUNCTION__, ntohl(tcph->seq));
+
+    /* Basic checking, is it HTTP packet? */
+    if (datalen < 10)
+	return ret;	/* Not enough length, ignore it */
+    if (memcmp(data, "GET ", sizeof("GET ") - 1) != 0 &&
+        memcmp(data, "POST ", sizeof("POST ") - 1) != 0 &&
+        memcmp(data, "HEAD ", sizeof("HEAD ") - 1) != 0) //zg add 2006.09.28 for cdrouter3.3 item 186(cdrouter_urlfilter_15)
+	return ret;	/* Pass it */
+
+    /* COOKIE modification */
+    if (flags & HTTP_COOKIE) {
+	found = find_pattern2(data, datalen, "Cookie: ", 
+		sizeof("Cookie: ")-1, '\r', &offset, &len);
+	if (found) {
+	    char c;
+	    offset -= (sizeof("Cookie: ") - 1);
+	    /* Swap the 2rd and 4th bit */
+	    c = *(data + offset + 2) ;
+	    *(data + offset + 2) = *(data + offset + 4) ;
+	    *(data + offset + 4) = c ;
+	    ret++;
+	}
+    }
+
+    return ret;
+}
+#endif
+
+static int get_http_info(const struct sk_buff *skb, int flags, httpinfo_t *info)
+{
+    struct iphdr *iph = (skb)->nh.iph;
+    struct tcphdr *tcph = (void *)iph + iph->ihl*4;
+    unsigned char *data = (void *)tcph + tcph->doff*4;
+    unsigned int datalen = (skb)->len - (iph->ihl*4) - (tcph->doff*4);
+
+    int found, offset;
+    int hostlen, pathlen;
+    int ret = 0;
+
+
+    SPARQ_LOG("%s: seq=%u\n", __FUNCTION__, ntohl(tcph->seq));
+
+    /* Basic checking, is it HTTP packet? */
+    if (datalen < 10)
+	return ret;	/* Not enough length, ignore it */
+    if (memcmp(data, "GET ", sizeof("GET ") - 1) != 0 &&
+        memcmp(data, "POST ", sizeof("POST ") - 1) != 0 &&
+        memcmp(data, "HEAD ", sizeof("HEAD ") - 1) != 0) //zg add 2006.09.28 for cdrouter3.3 item 186(cdrouter_urlfilter_15)
+	return ret;	/* Pass it */
+
+    if (!(flags & (HTTP_HOST | HTTP_URL)))
+	return ret;
+
+    /* find the 'Host: ' value */
+    found = find_pattern2(data, datalen, "Host: ", 
+	    sizeof("Host: ") - 1, '\r', &offset, &hostlen);
+    SPARQ_LOG("Host found=%d\n", found);
+
+    if (!found || !hostlen)
+	return ret;
+
+    ret++;	/* Host found, increase the return value */
+    hostlen = (hostlen < BUFSIZE) ? hostlen : BUFSIZE;
+    strncpy(info->host, data + offset, hostlen);
+    *(info->host + hostlen) = 0;		/* null-terminated */
+    info->hostlen = hostlen;
+    SPARQ_LOG("HOST=%s, hostlen=%d\n", info->host, info->hostlen);
+
+    if (!(flags & HTTP_URL))
+	return ret;
+
+    /* find the 'GET ' or 'POST ' or 'HEAD ' value */
+    found = find_pattern2(data, datalen, "GET ",
+	    sizeof("GET ") - 1, '\r', &offset, &pathlen);
+    if (!found)
+	found = find_pattern2(data, datalen, "POST ",
+		sizeof("POST ") - 1, '\r', &offset, &pathlen);
+    /******* zg add 2006.09.28 for cdrouter3.3 item 186(cdrouter_urlfilter_15) ******/
+    if (!found)
+        found = find_pattern2(data, datalen, "HEAD ",
+                sizeof("HEAD ") - 1, '\r', &offset, &pathlen);
+    /************************* zg end 2006.09.28 ****************************/
+    SPARQ_LOG("GET/POST found=%d\n", found);
+
+    if (!found || (pathlen -= (sizeof(" HTTP/x.x") - 1)) <= 0)/* ignor this field */
+	return ret;
+
+    ret++;	/* GET/POST/HEAD found, increase the return value */
+    pathlen = ((pathlen + hostlen) < BUFSIZE) ? pathlen : BUFSIZE - hostlen;
+    strncpy(info->url, info->host, hostlen);
+    strncpy(info->url + hostlen, data + offset, pathlen);
+    *(info->url + hostlen + pathlen) = 0;	/* null-terminated */
+    info->urllen = hostlen + pathlen;
+    SPARQ_LOG("URL=%s, urllen=%d\n", info->url, info->urllen);
+
+    return ret;
+}
+
+/* Linear string search based on memcmp() */
+static char *search_linear (char *needle, char *haystack, int needle_len, int haystack_len) 
+{
+	char *k = haystack + (haystack_len-needle_len);
+	char *t = haystack;
+	
+	SPARQ_LOG("%s: haystack=%s, needle=%s\n", __FUNCTION__, t, needle);
+	for(; t <= k; t++) {
+		//SPARQ_LOG("%s: haystack=%s, needle=%s\n", __FUNCTION__, t, needle);
+		if (strnicmp(t, needle, needle_len) == 0) return t;
+		//if ( memcmp(t, needle, needle_len) == 0 ) return t;
+	}
+
+	return NULL;
+}
+
+
+static int
+match(const struct sk_buff *skb,
+      const struct net_device *in,
+      const struct net_device *out,
+      const struct xt_match *match,
+      const void *matchinfo,
+      int offset,
+      unsigned int protoff,
+      int *hotdrop)
+{
+	const struct ipt_webstr_info *info = matchinfo;
+	struct iphdr *ip = skb->nh.iph;
+	proc_ipt_search search=search_linear;
+
+	char token[] = "<&nbsp;>";
+	char *wordlist = (char *)&info->string;
+	httpinfo_t htinfo;
+	int flags = 0;
+	int found = 0;
+	long int opt = 0;
+
+
+	if (!ip || info->len < 1)
+	    return 0;
+
+	SPARQ_LOG("\n************************************************\n"
+		"%s: type=%s\n", __FUNCTION__, (info->type == IPT_WEBSTR_URL) 
+		? "IPT_WEBSTR_URL"  : (info->type == IPT_WEBSTR_HOST) 
+		? "IPT_WEBSTR_HOST" : "IPT_WEBSTR_CONTENT" );
+	
+	/* Determine the flags value for get_http_info(), and mangle packet 
+	 * if needed. */
+	switch(info->type)
+	{
+	    case IPT_WEBSTR_URL:	/* fall through */
+		flags |= HTTP_URL;
+
+	    case IPT_WEBSTR_HOST:
+		flags |= HTTP_HOST;
+		break;
+
+	    case IPT_WEBSTR_CONTENT:
+		opt = simple_strtol(wordlist, (char **)NULL, 10);
+		SPARQ_LOG("%s: string=%s, opt=%#lx\n", __FUNCTION__, wordlist, opt);
+
+		if (opt & (BLK_JAVA | BLK_ACTIVE | BLK_PROXY))
+		    flags |= HTTP_URL;
+		if (opt & BLK_PROXY)
+		    flags |= HTTP_HOST;
+#if 0
+		// Could we modify the packet payload in a "match" module?  --YY@Ralink
+		if (opt & BLK_COOKIE)
+		    mangle_http_header(skb, HTTP_COOKIE);
+#endif
+		break;
+
+	    default:
+		printk("%s: Sorry! Cannot find this match option.\n", __FILE__);
+		return 0;
+	}
+
+	/* Get the http header info */
+	if (get_http_info(skb, flags, &htinfo) < 1)
+	    return 0;
+
+	/* Check if the http header content contains the forbidden keyword */
+	if (info->type == IPT_WEBSTR_HOST || info->type == IPT_WEBSTR_URL) {
+	    int nlen = 0, hlen = 0;
+	    char needle[BUFSIZE], *haystack = NULL;
+	    char *next;
+
+	    if (info->type == IPT_WEBSTR_HOST) {
+		haystack = htinfo.host;
+		hlen = htinfo.hostlen;
+	    }
+	    else {
+		haystack = htinfo.url;
+		hlen = htinfo.urllen;
+	    }
+	    split(needle, wordlist, next, token) {
+		nlen = strlen(needle);
+		SPARQ_LOG("keyword=%s, nlen=%d, hlen=%d\n", needle, nlen, hlen);
+		if (!nlen || !hlen || nlen > hlen) continue;
+		if (search(needle, haystack, nlen, hlen) != NULL) {
+		    found = 1;
+		    break;
+		}
+	    }
+	}
+	else {		/* IPT_WEBSTR_CONTENT */
+	    int vicelen;
+
+	    if (opt & BLK_JAVA) {
+		vicelen = sizeof(".js") - 1;
+		if (strnicmp(htinfo.url + htinfo.urllen - vicelen, ".js", vicelen) == 0) {
+		    SPARQ_LOG("%s: MATCH....java\n", __FUNCTION__);
+		    found = 1;
+		    goto match_ret;
+		}
+		vicelen = sizeof(".class") - 1;
+		if (strnicmp(htinfo.url + htinfo.urllen - vicelen, ".class", vicelen) == 0) {
+		    SPARQ_LOG("%s: MATCH....java\n", __FUNCTION__);
+		    found = 1;
+		    goto match_ret;
+		}
+	    }
+	    if (opt & BLK_ACTIVE){
+		vicelen = sizeof(".ocx") - 1;
+		if (strnicmp(htinfo.url + htinfo.urllen - vicelen, ".ocx", vicelen) == 0) {
+		    SPARQ_LOG("%s: MATCH....activex\n", __FUNCTION__);
+		    found = 1;
+		    goto match_ret;
+		}
+		vicelen = sizeof(".cab") - 1;
+		if (strnicmp(htinfo.url + htinfo.urllen - vicelen, ".cab", vicelen) == 0) {
+		    SPARQ_LOG("%s: MATCH....activex\n", __FUNCTION__);
+		    found = 1;
+		    goto match_ret;
+		}
+	    }
+	    if (opt & BLK_PROXY){
+		if (strnicmp(htinfo.url + htinfo.hostlen, "http://", sizeof("http://") - 1) == 0) {
+		    SPARQ_LOG("%s: MATCH....proxy\n", __FUNCTION__);
+		    found = 1;
+		    goto match_ret;
+		}
+	    }
+	}
+
+match_ret:
+	SPARQ_LOG("%s: Verdict =======> %s \n",__FUNCTION__
+		, found ? "DROP" : "ACCEPT");
+
+	return (found ^ info->invert);
+}
+
+static int
+checkentry(const char *tablename,
+	   const void *entry,
+	   const struct xt_match *match,
+           void *matchinfo,
+           unsigned int hook_mask)
+{
+#if 0
+       if (matchsize != IPT_ALIGN(sizeof(struct ipt_webstr_info)))
+               return 0;
+#endif
+       return 1;
+}
+
+static struct xt_match xt_webstr_match[] = {
+	{
+	.name		= "webstr",
+	.family		= AF_INET,
+	.match		= match,
+	.checkentry	= checkentry,
+	.matchsize	= sizeof(struct ipt_webstr_info),
+	.me		= THIS_MODULE
+	},
+	{
+	.name		= "webstr",
+	.family		= AF_INET6,
+	.match		= match,
+	.checkentry	= checkentry,
+	.matchsize	= sizeof(struct ipt_webstr_info),
+	.me		= THIS_MODULE
+	},
+
+};
+
+static int __init init(void)
+{
+	return xt_register_matches(xt_webstr_match, ARRAY_SIZE(xt_webstr_match));
+}
+
+static void __exit fini(void)
+{
+	xt_unregister_matches(xt_webstr_match, ARRAY_SIZE(xt_webstr_match));
+}
+
+module_init(init);
+module_exit(fini);
Index: linux-2.6.21/net/sunrpc/cache.c
===================================================================
--- linux-2.6.21.orig/net/sunrpc/cache.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/sunrpc/cache.c	2009-11-30 12:44:56.000000000 +0100
@@ -516,7 +516,11 @@
  * it to be revisited when cache info is available
  */
 
+#ifdef CONFIG_NET_SMALL
+#define	DFR_HASHSIZE	(512/sizeof(struct list_head))
+#else
 #define	DFR_HASHSIZE	(PAGE_SIZE/sizeof(struct list_head))
+#endif
 #define	DFR_HASH(item)	((((long)item)>>4 ^ (((long)item)>>13)) % DFR_HASHSIZE)
 
 #define	DFR_MAX	300	/* ??? */
Index: linux-2.6.21/net/sysctl_net.c
===================================================================
--- linux-2.6.21.orig/net/sysctl_net.c	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/net/sysctl_net.c	2009-11-30 12:44:56.000000000 +0100
@@ -5,6 +5,10 @@
  * Added /proc/sys/net directories for each protocol family. [MS]
  *
  * $Log: sysctl_net.c,v $
+ * Revision 1.1.1.1  2007-05-25 06:49:59  bruce
+ * linux-2.6.21 support RT2880. UART, PCI, ETHERNET, IRQ.... workable
+ * initial version. 
+ *
  * Revision 1.2  1996/05/08  20:24:40  shaver
  * Added bits for NET_BRIDGE and the NET_IPV4_ARP stuff and
  * NET_IPV4_IP_FORWARD.
Index: linux-2.6.21/ralink/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/ralink/Kconfig	2009-11-30 12:44:56.000000000 +0100
@@ -0,0 +1,64 @@
+menu "Ralink Module"
+
+#############
+# Wire
+#############
+source "drivers/net/raeth/Kconfig"
+
+#############
+# Wireless
+#############
+
+config  RT2860V2_2850
+        bool "Dual Band"
+        depends on RALINK_RT2880
+
+choice
+        prompt "RF Type"
+        depends on RALINK_RT3052
+        default RALINK_RT3052_2T2R
+
+        config  RALINK_RT3050_1T1R
+        bool "RT3050-1T1R"
+
+        config  RALINK_RT3051_1T2R
+        bool "RT3051-1T2R"
+
+        config  RALINK_RT3052_2T2R
+        bool "RT3052-2T2R"
+endchoice
+
+source "ralink/wireless/Kconfig"
+#source "drivers/net/wireless/iNIC/Kconfig"
+#source "drivers/net/wireless/iNIC_RT305x/Kconfig"
+
+#config INIC_USB
+#bool
+#default y if RT305x_INIC_USB
+
+#config INIC_MII
+#bool
+#default y if RT2880v2_INIC_MII || RT305x_INIC_MII
+
+#config INIC_PCI
+#bool
+#default y if RT2880v2_INIC_PCI
+
+#######
+# USB
+#######
+source "drivers/usb/dwc_otg/Kconfig"
+
+#choice
+#prompt "Ralink NAT Type"
+	
+#config  RA_NAT_NONE
+#bool "None"
+#config  RA_NAT_HW
+#bool "Hardware"
+#endchoice
+
+#source "net/nat/hw_nat/Kconfig"
+
+endmenu
+
Index: linux-2.6.21/scripts/gen_initramfs_list.sh
===================================================================
--- linux-2.6.21.orig/scripts/gen_initramfs_list.sh	2009-11-30 12:44:56.000000000 +0100
+++ linux-2.6.21/scripts/gen_initramfs_list.sh	2009-11-30 12:44:56.000000000 +0100
@@ -223,6 +223,7 @@
 cpio_list=
 output="/dev/stdout"
 output_file=""
+use_lzma="n"
 
 arg="$1"
 case "$arg" in
@@ -259,6 +260,9 @@
 			usage
 			exit 0
 			;;
+		"-l")
+			use_lzma="y"
+			;;
 		*)
 			case "$arg" in
 				"-"*)
@@ -282,7 +286,12 @@
 		cpio_tfile=${cpio_file}
 	fi
 	rm ${cpio_list}
-	cat ${cpio_tfile} | gzip -f -9 - > ${output_file}
+	if [ "$use_lzma" == "y" ]; then
+		cross_compile_path=`echo ${CONFIG_CROSS_COMPILER_PATH} | sed -e 's/\"//g'`
+		${cross_compile_path}/lzma_alone e ${cpio_tfile} ${output_file} -d20
+	else
+		cat ${cpio_tfile} | gzip -f -9 - > ${output_file}
+	fi
 	[ -z ${cpio_file} ] && rm ${cpio_tfile}
 fi
 exit 0
Index: linux-2.6.21/scripts/mod/sumversion.c
===================================================================
--- linux-2.6.21.orig/scripts/mod/sumversion.c	2009-11-30 12:44:56.000000000 +0100
+++ linux-2.6.21/scripts/mod/sumversion.c	2009-11-30 12:44:56.000000000 +0100
@@ -8,9 +8,7 @@
 #include <errno.h>
 #include <string.h>
 #include "modpost.h"
-#ifdef __APPLE__
 #include <limits.h>
-#endif
 
 /*
  * Stolen form Cryptographic API.
@@ -470,7 +468,7 @@
 	full_len = strlen(version) + strlen(version + strlen(version) + 1) + 2;
 
 	/* Move string to start with version number: prefix will be
-	 * $Revision$ or $Revision: */
+	 * $Revision: 1.2 $ or $Revision: */
 	len = strlen("$Revision");
 	if (version[len] == ':' || version[len] == '$')
 		len++;
Index: linux-2.6.21/usr/Kconfig
===================================================================
--- linux-2.6.21.orig/usr/Kconfig	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/usr/Kconfig	2009-11-30 12:44:56.000000000 +0100
@@ -4,7 +4,7 @@
 
 config INITRAMFS_SOURCE
 	string "Initramfs source file(s)"
-	default ""
+	default "../romfs"
 	help
 	  This can be either a single cpio archive with a .cpio suffix or a
 	  space-separated list of directories and files for building the
Index: linux-2.6.21/usr/Makefile
===================================================================
--- linux-2.6.21.orig/usr/Makefile	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/usr/Makefile	2009-11-30 12:44:56.000000000 +0100
@@ -23,7 +23,8 @@
 			$(shell echo $(CONFIG_INITRAMFS_SOURCE)),-d)
 ramfs-args  := \
         $(if $(CONFIG_INITRAMFS_ROOT_UID), -u $(CONFIG_INITRAMFS_ROOT_UID)) \
-        $(if $(CONFIG_INITRAMFS_ROOT_GID), -g $(CONFIG_INITRAMFS_ROOT_GID))
+        $(if $(CONFIG_INITRAMFS_ROOT_GID), -g $(CONFIG_INITRAMFS_ROOT_GID)) \
+	$(if $(CONFIG_INITRAMFS_LZMA), -l)
 
 # .initramfs_data.cpio.gz.d is used to identify all files included
 # in initramfs and to detect if any files are added/removed.
Index: linux-2.6.21/drivers/mtd/maps/Kconfig
===================================================================
--- linux-2.6.21.orig/drivers/mtd/maps/Kconfig	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/drivers/mtd/maps/Kconfig	2009-11-30 12:44:56.000000000 +0100
@@ -4,6 +4,10 @@
 menu "Mapping drivers for chip access"
 	depends on MTD!=n
 
+config MTD_RALINK
+	bool "Ralink MTD support"
+	depends on MTD
+
 config MTD_COMPLEX_MAPPINGS
 	bool "Support non-linear mappings of flash chips"
 	depends on MTD
Index: linux-2.6.21/drivers/mtd/maps/Makefile
===================================================================
--- linux-2.6.21.orig/drivers/mtd/maps/Makefile	2009-11-30 12:44:53.000000000 +0100
+++ linux-2.6.21/drivers/mtd/maps/Makefile	2009-11-30 12:44:56.000000000 +0100
@@ -72,3 +72,5 @@
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
 obj-$(CONFIG_MTD_MTX1)		+= mtx-1_flash.o
 obj-$(CONFIG_MTD_TQM834x)	+= tqm834x.o
+obj-$(CONFIG_MTD_RALINK)	+= ralink-flash.o
+
Index: linux-2.6.21/ralink/wireless/Kconfig
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/ralink/wireless/Kconfig	2009-11-30 13:12:59.000000000 +0100
@@ -0,0 +1,126 @@
+config RT2860V2_AP
+	tristate "Ralink RT2860 802.11n AP support"
+	depends on NET_RADIO 
+	
+config  RT2860V2_AP_LED
+	bool "LED Support"
+	depends on RT2860V2_AP
+
+config  RT2860V2_AP_WSC
+	bool "WSC (WiFi Simple Config)"
+	depends on RT2860V2_AP
+
+config  RT2860V2_AP_LLTD
+	bool "LLTD (Link Layer Topology Discovery Protocol)"
+	depends on RT2860V2_AP
+
+config  RT2860V2_AP_WDS
+	bool "WDS"
+	depends on RT2860V2_AP
+
+config  RT2860V2_AP_WMM_ACM
+	bool "WMM ACM"
+	depends on RT2860V2_AP
+
+config  RT2860V2_AP_NINTENDO
+	bool "Nintendo"
+	depends on RT2860V2_AP
+
+config  RT2860V2_AP_MBSS
+	bool "MBSSID"
+	depends on RT2860V2_AP
+
+config  RT2860V2_AP_APCLI
+	bool "AP-CLient Support"
+	depends on RT2860V2_AP
+
+config  RT2860V2_AP_IGMP_SNOOP
+	bool "IGMP snooping"
+	depends on RT2860V2_AP
+
+config  RT2860V2_AP_NETIF_BLOCK
+	bool "NETIF Block"
+	depends on RT2860V2_AP
+	help
+	Support Net interface block while Tx-Sw queue full
+
+config  RT2860V2_AP_DFS
+	bool "DFS"
+	depends on RT2860V2_AP
+	select RALINK_TIMER
+	select RALINK_TIMER_DFS
+
+config  RT2860V2_AP_CARRIER
+	bool "Carrier Detect"
+	depends on RT2860V2_AP
+	select RALINK_TIMER
+	select RALINK_TIMER_DFS
+
+config  RT2860V2_AP_DLS
+	bool "DLS ((Direct-Link Setup) Support"
+	depends on RT2860V2_AP
+
+config  RT2860V2_AP_IDS
+	bool "IDS (Intrusion Detection System) Support"
+	depends on RT2860V2_AP
+
+#config  RT2860V2_AP_MESH
+#	bool "MESH Support"
+#	depends on RT2860V2_AP
+
+config  RT2860V2_RT3XXX_AP_ANTENNA_DIVERSITY
+	bool "Antenna Diversity Support"
+	depends on RT2860V2_AP
+
+#config  RT2860V2_AP_WAPI
+#	bool "WAPI Support"
+#	depends on RT2860V2_AP
+
+config  RT2860V2_AP_COC
+	bool "CoC Support"
+	depends on RT2860V2_AP
+
+config  RT2860V2_AP_MEMORY_OPTIMIZATION
+	bool "Memory Optimization"
+	depends on RT2860V2_AP
+
+#config  RT2860V2_AP_INTELLIGENT_RATE_ADAPTION
+#        bool "Intelligent Rate Adaption"
+#	depends on RT2860V2_AP
+
+
+#config  RT2860V2_EXT_CHANNEL_LIST
+#	bool "Extension Channel List"
+#	depends on RT2860V2_AP
+
+#config  RT2860V2_KTHREAD
+#	bool "Kernel Thread"
+#	depends on RT2860V2_AP
+
+#config  RT2860V2_AUTO_CH_SELECT_ENHANCE
+#	bool "Auto Channel Selection Enhancement"
+#	depends on RT2860V2_AP
+
+config  RT2860V2_80211N_DRAFT3
+	bool "802.11n Draft3"
+	depends on RT2860V2_AP
+
+#config  RT2860V2_80211R_FT
+#	bool "802.11r Fast BSS Transition"
+#	depends on RT2860V2_AP
+
+#config  RT2860V2_80211R_RR
+#	bool "802.11k Radio Resource Management"
+#	depends on RT2860V2_AP
+
+#config  RT2860V2_SINGLE_SKU
+#	bool "Single SKU"
+#	depends on RT2860V2_AP
+
+#config  RT2860V2_MCAST_RATE_SPECIFIC
+#	bool "User specific tx rate of mcast pkt"
+#	depends on RT2860V2_AP
+
+#config  RT2860V2_SNMP
+#	bool "Net-SNMP Support"
+#	depends on RT2860V2_AP
