Let the kernel generate hotplug events when the link status on any of
the ethernet ports (on the embedded switch) changes.

--- a/drivers/net/raeth/raether.c
+++ b/drivers/net/raeth/raether.c
@@ -8,6 +8,7 @@
 #include <linux/if_vlan.h>
 #include <linux/if_ether.h>
 #include <asm/uaccess.h>
+#include <net/sock.h>
 #include <asm/rt2880/surfboardint.h>
 #include <linux/delay.h>
 
@@ -1111,14 +1112,71 @@
 	return IRQ_HANDLED;
 }
 
+static inline void add_msg_mv(struct sk_buff *skb, char *msg)
+{
+	char *scratch;
+	scratch = skb_put(skb, strlen(msg) + 1);
+	sprintf(scratch, msg);
+}
+
+extern struct sock *uevent_sock;
+extern u64 uevent_next_seqnum(void);
+
+static void hotplug_esw(char *port, int link, int resolved, int duplex, int speed)
+{
+	struct sk_buff *skb;
+	size_t len;
+	char *scratch, *s;
+	char buf[128];
+
+	if (!uevent_sock)
+		goto done;
+
+	/* allocate message with the maximum possible size */
+	s = resolved ? "add" : "remove";
+	len = strlen(s) + 2;
+	skb = alloc_skb(len + 2048, GFP_KERNEL);
+	if (!skb)
+		goto done;
+
+	/* add header */
+	scratch = skb_put(skb, len);
+	sprintf(scratch, "%s@",s);
+
+	/* copy keys to our continuous event payload buffer */
+	add_msg_mv(skb, "HOME=/");
+	add_msg_mv(skb, "PATH=/sbin:/bin:/usr/sbin:/usr/bin");
+	add_msg_mv(skb, "SUBSYSTEM=switch");
+	snprintf(buf, 128, "SEQNUM=%llu", uevent_next_seqnum());
+	add_msg_mv(skb, buf);
+	snprintf(buf, 128, "PORT=%s", port);
+	add_msg_mv(skb, buf);
+	snprintf(buf, 128, "LINK=%d", link);
+	add_msg_mv(skb, buf);
+	snprintf(buf, 128, "RESOLVED=%d", resolved);
+	add_msg_mv(skb, buf);
+	snprintf(buf, 128, "DUPLEX=%d", duplex);
+	add_msg_mv(skb, buf);
+	snprintf(buf, 128, "SPEED=%d", speed);
+	add_msg_mv(skb, buf);
+
+	NETLINK_CB(skb).dst_group = 1;
+	netlink_broadcast(uevent_sock, skb, 0, 1, GFP_KERNEL);
+done:
+	return;
+}
+
 #if defined (CONFIG_RALINK_RT3052) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350)
 static int sw_dev_seen = 0;
 static int sw_dev_val = 0;
+static int wan_state = 0xffff;
 
 static irqreturn_t esw_interrupt(int irq, void *dev_id)
 {
 	unsigned long flags;
 	unsigned long reg_int_val;
+	unsigned int port_status;
+	unsigned int speed_status;
 	struct net_device *dev = (struct net_device *) dev_id;
 	static u32 stat;
 	u32 stat_curr;
@@ -1128,7 +1186,7 @@
 	reg_int_val = (*((volatile u32 *)(RALINK_ETH_SW_BASE))); //Interrupt Status Register
 
 	if (reg_int_val & PORT_ST_CHG) {
-		//printk("RT305x_ESW: Link Status Changed\n");
+		printk("RT305x_ESW: Link Status Changed\n");
 
 		stat_curr = *((volatile u32 *)(RALINK_ETH_SW_BASE+0x80));
 
@@ -1139,6 +1197,21 @@
 		}
 
 		stat = stat_curr;
+
+		port_status = (stat_curr >> 25) & 0x1F;
+		speed_status = stat_curr & 0x1F;
+
+		/* Generate a hotplug event whenever the WAN link status
+		 * changes */
+		if(wan_state != (port_status & 0x10))
+		{
+			hotplug_esw("wan",
+				(port_status % 0x10)?(1):(0),
+				(port_status & 0x10)?(1):(0),
+				(speed_status & 0x10)?(100):(10),
+				(speed_status & 0x10)?(100):(10));
+			wan_state = port_status & 0x10;
+		}
 	}
 	sysRegWrite(RALINK_ETH_SW_BASE, reg_int_val);
 
