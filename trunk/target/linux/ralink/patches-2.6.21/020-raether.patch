This patch contains the FON specific changes to the Ralink ethernet
driver. Changes include (incomplete list):

 - Remove ethtool related code
 - Add code for /dev/switch device to query link status
 - Remove some debug prints
 - Remove some hardcoded udhcp reload code (?)
 - Load the correct MAC address from eeprom
 - Change some hardware settings

--- a/drivers/net/raeth/mcast.c
+++ b/drivers/net/raeth/mcast.c
@@ -1,4 +1,4 @@
-#include <linux/config.h>
+#include <linux/autoconf.h>
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/skbuff.h>
--- a/drivers/net/raeth/ra_mac.c
+++ b/drivers/net/raeth/ra_mac.c
@@ -1,4 +1,4 @@
-#include <linux/config.h>
+#include <linux/autoconf.h>
 #include <linux/module.h>
 #include <linux/version.h>
 #include <linux/kernel.h>
@@ -37,8 +37,6 @@
 #include <linux/proc_fs.h>
 #include <asm/uaccess.h>
 
-#include "../../../../config/autoconf.h"
-
 #if defined(CONFIG_USER_SNMPD)
 #include <linux/seq_file.h>
 #endif
@@ -227,17 +225,6 @@
 	else
 		printk("HWnetInit() failed!!!\n");
 
-#if defined (CONFIG_ETHTOOL)
-	// init mii structure
-	ei_local->mii_info.dev = dev;
-	ei_local->mii_info.mdio_read = mdio_read;
-	ei_local->mii_info.mdio_write = mdio_write;
-	ei_local->mii_info.phy_id_mask = 0x1f;
-	ei_local->mii_info.reg_num_mask = 0x1f;
-	ei_local->mii_info.supports_gmii = mii_check_gmii_support(&ei_local->mii_info);
-	// TODO:   phy_id: 0~4
-	ei_local->mii_info.phy_id = 1;
-#endif
 	return;
 }
 
@@ -446,11 +433,6 @@
 	printk("GDMA_RX_CERCNT0(0x%08x)     : 0x%08x\n\n", GDMA_RX_CERCNT0, sysRegRead(GDMA_RX_CERCNT0));	
 #endif
 
-#if defined (CONFIG_ETHTOOL)
-	// just for debug
-	printk("The current PHY address selected by ethtool is %d\n", get_current_phy_address());
-#endif
-
 #if defined (CONFIG_RALINK_RT2883) || defined(CONFIG_RALINK_RT3883)
 	printk("GDMA_RX_FCCNT1(0x%08x)     : 0x%08x\n\n", GDMA_RX_FCCNT1, sysRegRead(GDMA_RX_FCCNT1));	
 #endif
@@ -524,56 +506,6 @@
 }
 #endif
 
-#if defined (CONFIG_ETHTOOL)
-/*
- * proc write procedure
- */
-static int change_phyid(struct file *file, const char *buffer, unsigned long count, void *data)
-{
-	char buf[32];
-	struct net_device *cur_dev_p;
-	END_DEVICE *ei_local;
-	char if_name[64];
-	unsigned int phy_id;
-
-	if (count > 32)
-		count = 32;
-	memset(buf, 0, 32);
-	if (copy_from_user(buf, buffer, count))
-		return -EFAULT;
-
-	/* determine interface name */
-    strcpy(if_name, DEV_NAME);	/* "eth2" by default */
-    if(isalpha(buf[0]))
-		sscanf(buf, "%s %d", if_name, &phy_id);
-	else
-		phy_id = simple_strtol(buf, 0, 10);
-
-	for(cur_dev_p=dev_base; cur_dev_p!=NULL; cur_dev_p=cur_dev_p->next){
-		if (strncmp(cur_dev_p->name, if_name, 4) == 0)
-			break;
-	}
-	if (cur_dev_p == NULL)
-		return -EFAULT;
-
-#ifdef CONFIG_PSEUDO_SUPPORT
-	/* This may be wrong when more than 2 gmacs */
-	if(!strcmp(cur_dev_p->name, DEV_NAME)){
-		ei_local = cur_dev_p->priv;
-		ei_local->mii_info.phy_id = (unsigned char)phy_id;
-	}else{
-		PSEUDO_ADAPTER *pPseudoAd;
-		pPseudoAd = cur_dev_p->priv;
-		pPseudoAd->mii_info.phy_id = (unsigned char)phy_id;
-	}
-#else
-	ei_local = cur_dev_p->priv;
-	ei_local->mii_info.phy_id = (unsigned char)phy_id;
-#endif
-	return count;
-}
-#endif
-
 int debug_proc_init(void)
 {
     if (procRegDir == NULL)
@@ -581,9 +513,6 @@
    
     if ((procGmac = create_proc_entry(PROCREG_GMAC, 0, procRegDir))){
 	 procGmac->read_proc = (read_proc_t*)&RegReadMain;
-#if defined (CONFIG_ETHTOOL)
-	 procGmac->write_proc = (write_proc_t*)&change_phyid;
-#endif
 	}
 
     if ((procSysCP0 = create_proc_entry(PROCREG_CP0, 0, procRegDir)))
--- a/drivers/net/raeth/ra_rfrw.c
+++ b/drivers/net/raeth/ra_rfrw.c
@@ -1,4 +1,4 @@
-#include <linux/config.h>
+#include <linux/autoconf.h>
 #include <linux/module.h>
 #include <linux/version.h>
 #include <linux/kernel.h>
--- a/drivers/net/raeth/raether.c
+++ b/drivers/net/raeth/raether.c
@@ -33,6 +33,7 @@
 #include "../../../net/nat/hw_nat/ra_nat.h"
 #endif
 
+#include <asm/rt2880/fon.h>
 
 #ifdef CONFIG_RAETH_NAPI
 static int raeth_clean(struct net_device *dev, int *budget);
@@ -92,14 +93,6 @@
 static struct PDMA_rxdesc	*rx_ring;
 static unsigned long tx_ring_full=0;
 
-#if defined (CONFIG_ETHTOOL)
-#include "ra_ethtool.h"
-extern struct ethtool_ops	ra_ethtool_ops;
-#ifdef CONFIG_PSEUDO_SUPPORT
-extern struct ethtool_ops	ra_virt_ethtool_ops;
-#endif // CONFIG_PSEUDO_SUPPORT //
-#endif // (CONFIG_ETHTOOL //
-
 #ifdef CONFIG_RALINK_VISTA_BASIC
 int is_switch_175c = 1;
 #endif
@@ -390,13 +383,13 @@
 	sysRegWrite(FE_RST_GL, 0);	// update for RSTCTL issue
 
 	regCsg = sysRegRead(CDMA_CSG_CFG);
-	printk("CDMA_CSG_CFG = %0X\n",regCsg);
+	//printk("CDMA_CSG_CFG = %0X\n",regCsg);
 	regVal = sysRegRead(GDMA1_FWD_CFG);
-	printk("GDMA1_FWD_CFG = %0X\n",regVal);
+	//printk("GDMA1_FWD_CFG = %0X\n",regVal);
 
 #ifdef CONFIG_PSEUDO_SUPPORT
 	regVal = sysRegRead(GDMA2_FWD_CFG);
-	printk("GDMA2_FWD_CFG = %0X\n",regVal);
+	//printk("GDMA2_FWD_CFG = %0X\n",regVal);
 #endif
 #endif
 	return 1;
@@ -453,9 +446,9 @@
 		return 0;
 	}
 
-	printk("\nphy_tx_ring0 = %08x, tx_ring0 = %p, size: %d bytes\n", ei_local->phy_tx_ring0, ei_local->tx_ring0, sizeof(struct PDMA_txdesc));
+//	printk("\nphy_tx_ring0 = %08x, tx_ring0 = %p, size: %d bytes\n", ei_local->phy_tx_ring0, ei_local->tx_ring0, sizeof(struct PDMA_txdesc));
 
-	printk("\nphy_tx_ring1 = %08x, tx_ring1 = %p, size: %d bytes\n", ei_local->phy_tx_ring1, ei_local->tx_ring1, sizeof(struct PDMA_txdesc));
+//	printk("\nphy_tx_ring1 = %08x, tx_ring1 = %p, size: %d bytes\n", ei_local->phy_tx_ring1, ei_local->tx_ring1, sizeof(struct PDMA_txdesc));
 
 #if defined (CONFIG_RALINK_RT2883) || defined (CONFIG_RALINK_RT3052) || defined (CONFIG_RALINK_RT3352) || defined(CONFIG_RALINK_RT3883) || defined(CONFIG_RALINK_RT5350)
 	fe_tx_desc_init(dev, 2, 3, 1);
@@ -470,9 +463,9 @@
 		return 0;
 	}
 
-	printk("\nphy_tx_ring2 = %08x, tx_ring2 = %p, size: %d bytes\n", ei_local->phy_tx_ring2, ei_local->tx_ring2, sizeof(struct PDMA_txdesc));
+//	printk("\nphy_tx_ring2 = %08x, tx_ring2 = %p, size: %d bytes\n", ei_local->phy_tx_ring2, ei_local->tx_ring2, sizeof(struct PDMA_txdesc));
 
-	printk("\nphy_tx_ring3 = %08x, tx_ring3 = %p, size: %d bytes\n", ei_local->phy_tx_ring3, ei_local->tx_ring3, sizeof(struct PDMA_txdesc));
+//	printk("\nphy_tx_ring3 = %08x, tx_ring3 = %p, size: %d bytes\n", ei_local->phy_tx_ring3, ei_local->tx_ring3, sizeof(struct PDMA_txdesc));
 
 #endif // CONFIG_RALINK_RT2883 || CONFIG_RALINK_RT3052 || CONFIG_RALINK_RT3352 || CONFIG_RALINK_RT3883 || CONFIG_RALINK_RT5350 //
 #else
@@ -481,7 +474,7 @@
 	}
 	ei_local->free_idx =0;
     	ei_local->tx_ring0 = pci_alloc_consistent(NULL, NUM_TX_DESC * sizeof(struct PDMA_txdesc), &ei_local->phy_tx_ring0);
- 	printk("\nphy_tx_ring = 0x%08x, tx_ring = 0x%p\n", ei_local->phy_tx_ring0, ei_local->tx_ring0);
+ 	//printk("\nphy_tx_ring = 0x%08x, tx_ring = 0x%p\n", ei_local->phy_tx_ring0, ei_local->tx_ring0);
 
 	for (i=0; i < NUM_TX_DESC; i++) {
 		memset(&ei_local->tx_ring0[i],0,sizeof(struct PDMA_txdesc));
@@ -499,7 +492,7 @@
 		ei_local->rx_ring0[i].rxd_info2.LS0 = 1;
 		ei_local->rx_ring0[i].rxd_info1.PDP0 = dma_map_single(NULL, skb_put(ei_local->netrx0_skbuf[i], 2), MAX_RX_LENGTH, PCI_DMA_FROMDEVICE);
 	}
-	printk("\nphy_rx_ring0 = 0x%08x, rx_ring0 = 0x%p\n",ei_local->phy_rx_ring0,ei_local->rx_ring0);
+	//printk("\nphy_rx_ring0 = 0x%08x, rx_ring0 = 0x%p\n",ei_local->phy_rx_ring0,ei_local->rx_ring0);
 
 #if defined (CONFIG_RAETH_MULTIPLE_RX_RING)
 	/* Initial RX Ring 1*/
@@ -510,7 +503,7 @@
 		ei_local->rx_ring1[i].rxd_info2.LS0 = 1;
 		ei_local->rx_ring1[i].rxd_info1.PDP0 = dma_map_single(NULL, skb_put(ei_local->netrx1_skbuf[i], 2), MAX_RX_LENGTH, PCI_DMA_FROMDEVICE);
 	}
-	printk("\nphy_rx_ring1 = 0x%08x, rx_ring1 = 0x%p\n",ei_local->phy_rx_ring1,ei_local->rx_ring1);
+	//printk("\nphy_rx_ring1 = 0x%08x, rx_ring1 = 0x%p\n",ei_local->phy_rx_ring1,ei_local->rx_ring1);
 #endif
 
 	regVal = sysRegRead(PDMA_GLO_CFG);
@@ -890,32 +883,6 @@
 	return &ei_local->stat;
 }
 
-#if defined (CONFIG_RALINK_RT3052) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350)
-void kill_sig_workq(struct work_struct *work)
-{
-	struct file *fp;
-	char pid[8];
-	struct task_struct *p = NULL;
-
-	//read udhcpc pid from file, and send signal USR2,USR1 to get a new IP
-	fp = filp_open("/var/run/udhcpc.pid", O_RDONLY, 0);
-	if (IS_ERR(fp))
-	    return;
-
-	if (fp->f_op && fp->f_op->read) {
-	    if (fp->f_op->read(fp, pid, 8, &fp->f_pos) > 0) {
-		p = find_task_by_pid(simple_strtoul(pid, NULL, 10));
-		if (NULL != p) {
-		    send_sig(SIGUSR2, p, 0);
-		    send_sig(SIGUSR1, p, 0);
-		}
-	    }
-	}
-	filp_close(fp, NULL);
-
-}
-#endif
-
 ///////////////////////////////////////////////////////////////////
 /////
 ///// ra2880Recv - process the next incoming packet
@@ -1145,6 +1112,8 @@
 }
 
 #if defined (CONFIG_RALINK_RT3052) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350)
+static int sw_dev_seen = 0;
+static int sw_dev_val = 0;
 
 static irqreturn_t esw_interrupt(int irq, void *dev_id)
 {
@@ -1159,22 +1128,16 @@
 	reg_int_val = (*((volatile u32 *)(RALINK_ETH_SW_BASE))); //Interrupt Status Register
 
 	if (reg_int_val & PORT_ST_CHG) {
-		printk("RT305x_ESW: Link Status Changed\n");
+		//printk("RT305x_ESW: Link Status Changed\n");
 
 		stat_curr = *((volatile u32 *)(RALINK_ETH_SW_BASE+0x80));
-#ifdef CONFIG_WAN_AT_P0
-		//if Port0 link down --> link up
-		if ((stat & (1<<25)) || !(stat_curr & (1<<25)))
-#else
-		//if Port4 link down --> link up
-		if ((stat & (1<<29)) || !(stat_curr & (1<<29)))
-#endif
-			goto out;
 
-#if defined (CONFIG_RALINK_RT3052) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350)
-		schedule_work(&ei_local->kill_sig_wq);
-#endif
-out:
+		if(stat_curr != stat);
+		{
+			sw_dev_seen = 1;
+			sw_dev_val = ((stat_curr >> 25) & 0x1f) | 0x80;
+		}
+
 		stat = stat_curr;
 	}
 	sysRegWrite(RALINK_ETH_SW_BASE, reg_int_val);
@@ -1495,9 +1458,6 @@
 #endif
 #endif
 
-#if defined (CONFIG_ETHTOOL)
-	dev->ethtool_ops	= &ra_ethtool_ops;
-#endif
 	dev->do_ioctl		= ei_ioctl;
 }
 
@@ -1584,9 +1544,9 @@
 	sysRegWrite(RSTCTRL, val);
 	//Get mac0 address from flash
 #ifdef RA_MTD_RW_BY_NUM
-	i = ra_mtd_read(2, GMAC0_OFFSET, 6, addr.sa_data);
+	i = ra_mtd_read(1, GMAC0_OFFSET, 6, addr.sa_data);
 #else
-	i = ra_mtd_read_nm("Factory", GMAC0_OFFSET, 6, addr.sa_data);
+	i = ra_mtd_read_nm("boardconfig", GMAC0_OFFSET, 6, addr.sa_data);
 #endif
 
 	//If reading mtd failed or mac0 is empty, generate a mac address
@@ -1595,6 +1555,14 @@
 		net_srandom(jiffies);
 		memcpy(addr.sa_data, mac_addr01234, 5);
 		addr.sa_data[5] = net_random()&0xFF;
+	} else {
+		/* Set the last two bits of the mac address, to force
+		 * ethernet to use the fourth MAC address, regardless of
+		 * which of the four addresses is stored in mtd (2.0n
+		 * and SIMPL store a different address, so this works
+		 * for both).
+		 */
+		addr.sa_data[5] |= 0x3;
 	}
 
 	ei_set_mac_addr(dev, &addr);
@@ -1818,9 +1786,9 @@
 
 	//Get mac2 address from flash
 #ifdef RA_MTD_RW_BY_NUM
-	i = ra_mtd_read(2, GMAC2_OFFSET, 6, addr.sa_data);
+	i = ra_mtd_read(0, GMAC2_OFFSET, 6, addr.sa_data);
 #else
-	i = ra_mtd_read_nm("Factory", GMAC2_OFFSET, 6, addr.sa_data);
+	i = ra_mtd_read_nm("boardconfig", GMAC2_OFFSET, 6, addr.sa_data);
 #endif
 
 	//If reading mtd failed or mac0 is empty, generate a mac address
@@ -1848,18 +1816,6 @@
 	dev->get_stats = VirtualIF_get_stats;
 	dev->change_mtu = ei_change_mtu;
 	dev->mtu = 1500;
-#if defined (CONFIG_ETHTOOL)
-	dev->ethtool_ops = &ra_virt_ethtool_ops;
-    // init mii structure
-	pPseudoAd->mii_info.dev = dev;
-	pPseudoAd->mii_info.mdio_read = mdio_virt_read;
-	pPseudoAd->mii_info.mdio_write = mdio_virt_write;
-	pPseudoAd->mii_info.phy_id_mask = 0x1f;
-	pPseudoAd->mii_info.reg_num_mask = 0x1f;
-	pPseudoAd->mii_info.phy_id = 0x1e;
-	pPseudoAd->mii_info.supports_gmii = mii_check_gmii_support(&pPseudoAd->mii_info);
-#endif
-
 	// Register this device
 	register_netdevice(dev);
     }
@@ -1927,9 +1883,6 @@
 
 	*((volatile u32 *)(RALINK_INTCL_BASE + 0x34)) = (1<<17);
 	*((volatile u32 *)(RALINK_ETH_SW_BASE + 0x04)) &= ~(ESW_INT_ALL);
-#if defined (CONFIG_RALINK_RT3052) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350)
-	INIT_WORK(&ei_local->kill_sig_wq, kill_sig_workq);
-#endif
 	request_irq(SURFBOARDINT_ESW, esw_interrupt, SA_INTERRUPT, "Ralink_ESW", dev);
 #endif // CONFIG_RALINK_RT3052 || CONFIG_RALINK_RT3352 || CONFIG_RALINK_RT5350 //
 
@@ -2089,157 +2042,54 @@
         *(unsigned long *)(0xb01100C8) = 0x3f502b28; //Change polling Ext PHY Addr=0x1F
         *(unsigned long *)(0xb0110084) = 0x00000000;
         *(unsigned long *)(0xb0110110) = 0x7d000000; //1us cycle number=125 (FE's clock=125Mhz)
-#elif defined (CONFIG_RT3052_FPGA) || defined (CONFIG_RT3352_FPGA) || defined (CONFIG_RT5350_FPGA)
-        *(unsigned long *)(0xb01100C8) = 0x20f02b28; //Change polling Ext PHY Addr=0x0
-        *(unsigned long *)(0xb0110084) = 0xffdf1f00;
-        *(unsigned long *)(0xb0110110) = 0x0d000000; //1us cycle number=13 (FE's clock=12.5Mhz)
-
-	/* In order to use 10M/Full on FPGA board. We configure phy capable to
-	 * 10M Full/Half duplex, so we can use auto-negotiation on PC side */
-        for(i=0;i<5;i++){
-	    mii_mgr_write(i, 4, 0x0461);   //Capable of 10M Full/Half Duplex, flow control on/off
-	    mii_mgr_write(i, 0, 0xB100);   //reset all digital logic, except phy_reg
-	}
-#endif
-	
-	/*
-	 * set port 5 force to 1000M/Full when connecting to switch or iNIC
-	 */
-#if defined (CONFIG_P5_RGMII_TO_MAC_MODE)
-	*(unsigned long *)(0xb0000060) &= ~(1 << 9); //set RGMII to Normal mode
-        *(unsigned long *)(0xb01100C8) &= ~(1<<29); //disable port 5 auto-polling
-        *(unsigned long *)(0xb01100C8) |= 0x3fff; //force 1000M full duplex
-        *(unsigned long *)(0xb01100C8) &= ~(0xf<<20); //rxclk_skew, txclk_skew = 0
-#elif defined (CONFIG_P5_MII_TO_MAC_MODE)
-	*(unsigned long *)(0xb0000060) &= ~(1 << 9); //set RGMII to Normal mode
-        *(unsigned long *)(0xb01100C8) &= ~(1<<29); //disable port 5 auto-polling
-        *(unsigned long *)(0xb01100C8) &= ~(0x3fff); 
-        *(unsigned long *)(0xb01100C8) |= 0x3ffd; //force 100M full duplex
-#elif defined (CONFIG_P5_MAC_TO_PHY_MODE)
-	*(unsigned long *)(0xb0000060) &= ~(1 << 9); //set RGMII to Normal mode
-	*(unsigned long *)(0xb0000060) &= ~(1 << 7); //set MDIO to Normal mode
-	enable_auto_negotiate(1);
-        if (isMarvellGigaPHY(1)) {
-#if defined (CONFIG_RT3052_FPGA) || defined (CONFIG_RT3352_FPGA) || defined (CONFIG_RT5350_FPGA)
-		mii_mgr_read(CONFIG_MAC_TO_GIGAPHY_MODE_ADDR, 9, &phy_val);
-		phy_val &= ~(3<<8); //turn off 1000Base-T Advertisement  (9.9=1000Full, 9.8=1000Half)
-		mii_mgr_write(CONFIG_MAC_TO_GIGAPHY_MODE_ADDR, 9, phy_val);
 #endif
-		printk("\n Reset MARVELL phy\n");
-		mii_mgr_read(CONFIG_MAC_TO_GIGAPHY_MODE_ADDR, 20, &phy_val);
-		phy_val |= 1<<7; //Add delay to RX_CLK for RXD Outputs
-		mii_mgr_write(CONFIG_MAC_TO_GIGAPHY_MODE_ADDR, 20, phy_val);
-
-		mii_mgr_read(CONFIG_MAC_TO_GIGAPHY_MODE_ADDR, 0, &phy_val);
-		phy_val |= 1<<15; //PHY Software Reset
-	 	mii_mgr_write(CONFIG_MAC_TO_GIGAPHY_MODE_ADDR, 0, phy_val);
-        }
-	if (isVtssGigaPHY(1)) {
-		mii_mgr_write(CONFIG_MAC_TO_GIGAPHY_MODE_ADDR, 31, 0x0001); //extended page
-		mii_mgr_read(CONFIG_MAC_TO_GIGAPHY_MODE_ADDR, 28, &phy_val);
-		printk("Vitesse phy skew: %x --> ", phy_val);
-		phy_val |= (0x3<<12); // RGMII RX skew compensation= 2.0 ns
-		phy_val &= ~(0x3<<14);// RGMII TX skew compensation= 0 ns
-		printk("%x\n", phy_val);
-		mii_mgr_write(CONFIG_MAC_TO_GIGAPHY_MODE_ADDR, 28, phy_val);
-		mii_mgr_write(CONFIG_MAC_TO_GIGAPHY_MODE_ADDR, 31, 0x0000); //main registers
-        }
-       
-#elif defined (CONFIG_P5_RMII_TO_MAC_MODE)
-	*(unsigned long *)(0xb0000060) &= ~(1 << 9); //set RGMII to Normal mode
-        *(unsigned long *)(0xb01100C8) &= ~(1<<29); //disable port 5 auto-polling
-        *(unsigned long *)(0xb01100C8) &= ~(0x3fff); 
-        *(unsigned long *)(0xb01100C8) |= 0x3ffd; //force 100M full duplex
-#else // Port 5 Disabled //
+	// Port 5 Disabled //
         *(unsigned long *)(0xb01100C8) &= ~(1 << 29); //port5 auto polling disable
         *(unsigned long *)(0xb0000060) |= (1 << 9); //set RGMII to GPIO mode (GPIO41-GPIO50)
         *(unsigned long *)(0xb0000674) = 0xFFF; //GPIO41-GPIO50 output mode
         *(unsigned long *)(0xb0000670) = 0x0; //GPIO41-GPIO50 output low
-#endif // CONFIG_P5_RGMII_TO_MAC_MODE //
 
 
 #if defined (CONFIG_RT3052_ASIC) || defined (CONFIG_RT3352_ASIC) || defined (CONFIG_RT5350_ASIC)
 						//
 #if defined (CONFIG_RT3052_ASIC)
-	rw_rf_reg(0, 0, &phy_val);
-        phy_val = phy_val >> 4;
-
-        if(phy_val > 0x5) {
-
-            rw_rf_reg(0, 26, &phy_val);
-            phy_val2 = (phy_val | (0x3 << 5));
-            rw_rf_reg(1, 26, &phy_val2);
-
-			// reset EPHY
-			val = sysRegRead(RSTCTRL);
-			val = val | RALINK_EPHY_RST;
-			sysRegWrite(RSTCTRL, val);
-			val = val & ~(RALINK_EPHY_RST);
-			sysRegWrite(RSTCTRL, val);
-
-            rw_rf_reg(1, 26, &phy_val);
-
-            //select local register
-            mii_mgr_write(0, 31, 0x8000);
-            for(i=0;i<5;i++){
-                mii_mgr_write(i, 26, 0x1600);   //TX10 waveform coefficient //LSB=0 disable PHY
-                mii_mgr_write(i, 29, 0x7015);   //TX100/TX10 AD/DA current bias
-                mii_mgr_write(i, 30, 0x0038);   //TX100 slew rate control
-            }
-
-            //select global register
-            mii_mgr_write(0, 31, 0x0);
-            mii_mgr_write(0,  1, 0x4a40); //enlarge agcsel threshold 3 and threshold 2
-            mii_mgr_write(0,  2, 0x6254); //enlarge agcsel threshold 5 and threshold 4
-            mii_mgr_write(0,  3, 0xa17f); //enlarge agcsel threshold 6
-            mii_mgr_write(0, 12, 0x7eaa);
-            mii_mgr_write(0, 14, 0x65);   //longer TP_IDL tail length
-            mii_mgr_write(0, 16, 0x0684); //increased squelch pulse count threshold.
-            mii_mgr_write(0, 17, 0x0fe0); //set TX10 signal amplitude threshold to minimum
-            mii_mgr_write(0, 18, 0x40ba); //set squelch amplitude to higher threshold
-            mii_mgr_write(0, 22, 0x252f); //tune TP_IDL tail and head waveform, enable power down slew rate control
-            mii_mgr_write(0, 27, 0x2fda); //set PLL/Receive bias current are calibrated
-            mii_mgr_write(0, 28, 0xc410); //change PLL/Receive bias current to internal(RT3350)
-            mii_mgr_write(0, 29, 0x598b); //change PLL bias current to internal(RT3052_MP3)
-	    mii_mgr_write(0, 31, 0x8000); //select local register
-
-            for(i=0;i<5;i++){
-                //LSB=1 enable PHY
-                mii_mgr_read(i, 26, &phy_val);
-                phy_val |= 0x0001;
-                mii_mgr_write(i, 26, phy_val);
-            }
+	mii_mgr_write(0, 31, 0x8000);   //---> select local register
+	for(i = 0; i < 5; i++)
+	{
+		mii_mgr_write(i, 0, 0x3100);   //TX10 waveform coefficient
+		mii_mgr_write(i, 26, 0x1601);   //TX10 waveform coefficient
+		mii_mgr_write(i, 29, 0x7058);   //TX100/TX10 AD/DA current bias
+		mii_mgr_write(i, 30, 0x0018);   //TX100 slew rate control
+	}
+	/* PHY IOT */
+	mii_mgr_write(0, 31, 0x0);      //select global register
+	mii_mgr_write(0, 22, 0x052f);   //tune TP_IDL tail and head waveform
+	mii_mgr_write(0, 17, 0x0fe0);   //set TX10 signal amplitude threshold to minimum
+	mii_mgr_write(0, 18, 0x40ba);   //set squelch amplitude to higher threshold
+	mii_mgr_write(0, 14, 0x65);     //longer TP_IDL tail length
+	mii_mgr_write(0, 31, 0x8000);   //select local register
+
+	if(fonera_sku->type == FON20N) {
+		printk("setting fonera20n ethernet\n");
+	} else if(fonera_sku->type == SIMPL_EDIMAX)
+	{
+		printk("setting edimax ethernet\n");
+		mii_mgr_write( 1, 0, 0x3900); //set port 1 register0 bit11
+		mii_mgr_write( 2, 0, 0x3900); //set port 2 register0 bit11
+		mii_mgr_write( 3, 0, 0x3900); //set port 3 register0 bit11
+		*(unsigned long *)(0xb0110040) = 0x00001002;
+		*(unsigned long *)(0xb0110050) = 0x00002001;
+		*(unsigned long *)(0xb0110070) = 0x00004150;
 	} else {
-	    //select local register
-            mii_mgr_write(0, 31, 0x8000);
-            for(i=0;i<5;i++){
-                mii_mgr_write(i, 26, 0x1600);   //TX10 waveform coefficient //LSB=0 disable PHY
-                mii_mgr_write(i, 29, 0x7058);   //TX100/TX10 AD/DA current bias
-                mii_mgr_write(i, 30, 0x0018);   //TX100 slew rate control
-            }
-
-            //select global register
-            mii_mgr_write(0, 31, 0x0);
-            mii_mgr_write(0,  1, 0x4a40); //enlarge agcsel threshold 3 and threshold 2
-            mii_mgr_write(0,  2, 0x6254); //enlarge agcsel threshold 5 and threshold 4
-            mii_mgr_write(0,  3, 0xa17f); //enlarge agcsel threshold 6
-            mii_mgr_write(0, 14, 0x65);   //longer TP_IDL tail length
-            mii_mgr_write(0, 16, 0x0684); //increased squelch pulse count threshold.
-            mii_mgr_write(0, 17, 0x0fe0); //set TX10 signal amplitude threshold to minimum
-            mii_mgr_write(0, 18, 0x40ba); //set squelch amplitude to higher threshold
-            mii_mgr_write(0, 22, 0x052f); //tune TP_IDL tail and head waveform
-            mii_mgr_write(0, 27, 0x2fce); //set PLL/Receive bias current are calibrated
-            mii_mgr_write(0, 28, 0xc410); //change PLL/Receive bias current to internal(RT3350)
-	    mii_mgr_write(0, 29, 0x598b); //change PLL bias current to internal(RT3052_MP3)
-	    mii_mgr_write(0, 31, 0x8000); //select local register
-
-            for(i=0;i<5;i++){
-                //LSB=1 enable PHY
-                mii_mgr_read(i, 26, &phy_val);
-                phy_val |= 0x0001;
-                mii_mgr_write(i, 26, phy_val);
-            }
+		printk("setting cameo ethernet\n");
+		mii_mgr_write( 1, 0, 0x3900); //set port 1 register0 bit11
+		mii_mgr_write( 3, 0, 0x3900); //set port 3 register0 bit11
+		mii_mgr_write( 4, 0, 0x3900); //set port 4 register0 bit1
+		*(unsigned long *)(0xb0110040) = 0x00001002;
+		*(unsigned long *)(0xb0110070) = 0x00004144;
 	}
+
+
 #elif defined (CONFIG_RT3352_ASIC)
 	//PHY IOT
 	// reset EPHY
@@ -2319,7 +2169,12 @@
             phy_val |= 0x0001;
             mii_mgr_write(i, 26, phy_val);
         }
-
+	printk("setting cameo ethernet\n");
+	mii_mgr_write( 1, 0, 0x3900); //set port 1 register0 bit11
+	mii_mgr_write( 3, 0, 0x3900); //set port 3 register0 bit11
+	mii_mgr_write( 4, 0, 0x3900); //set port 4 register0 bit1
+	*(unsigned long *)(0xb0110040) = 0x00001002;
+	*(unsigned long *)(0xb0110070) = 0x00004144;
 #else
 #error "Chip is not supported"
 #endif
@@ -2329,6 +2184,49 @@
 }
 #endif
 
+static int
+sw_dev_open(struct inode *inode, struct file *file)
+{
+	int result = 0;
+	unsigned int dev_minor = MINOR(inode->i_rdev);
+
+	if (dev_minor != 0)
+	{
+		printk(KERN_ERR  "sw_dev: trying to access unknown minor device -> %d\n", dev_minor);
+		result = -ENODEV;
+		goto out;
+	}
+out:
+	return result;
+}
+
+static int
+sw_dev_release(struct inode * inode, struct file * file)
+{
+	return 0;
+}
+
+static ssize_t sw_dev_read(struct file *filp, char *buffer, size_t length, loff_t * offset)
+{
+	int bytes_read ;
+	char tmp[256];
+	if(!sw_dev_seen)
+		return 0;
+	bytes_read = snprintf(tmp, 2, "%c", (unsigned char)sw_dev_val);
+	if(bytes_read > length)
+		return 0;
+	copy_to_user(buffer, tmp, bytes_read);
+	sw_dev_seen = 0;
+	return bytes_read;
+}
+
+static struct file_operations  sw_dev_fops =
+{
+	.open = sw_dev_open,
+	.release = sw_dev_release,
+	.read = sw_dev_read,
+};
+
 /**
  * ra2882eth_init - Module Init code
  *
@@ -2442,6 +2340,7 @@
 	// Case3: RT305x/RT335x + EmbeddedSW
 #if defined (CONFIG_RT_3052_ESW)
 	rt305x_esw_init();
+	register_chrdev(201, "switch", &sw_dev_fops);
 #endif 
 	// Case4:  RT288x/RT388x GE1 + GigaSW
 #if defined (CONFIG_GE1_RGMII_FORCE_1000)
--- a/drivers/net/raeth/raether.h
+++ b/drivers/net/raeth/raether.h
@@ -46,7 +46,7 @@
 #endif
 #endif
 
-#define DEV_NAME        "eth2"
+#define DEV_NAME        "eth0"
 
 #define GMAC2_OFFSET    0x22
 #define GMAC0_OFFSET    0x28 
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -27,7 +27,7 @@
 
 obj-y				+= serial/
 obj-$(CONFIG_PARPORT)		+= parport/
-obj-y				+= base/ block/ misc/ mfd/ net/ media/
+obj-y				+= base/ block/ misc/ mfd/ media/
 obj-$(CONFIG_NUBUS)		+= nubus/
 obj-$(CONFIG_ATM)		+= atm/
 obj-y				+= macintosh/
@@ -40,6 +40,7 @@
 obj-y				+= cdrom/
 obj-y				+= auxdisplay/
 obj-$(CONFIG_MTD)		+= mtd/
+obj-y				+= net/
 obj-$(CONFIG_SPI)		+= spi/
 obj-$(CONFIG_PCCARD)		+= pcmcia/
 obj-$(CONFIG_DIO)		+= dio/
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -231,3 +231,4 @@
 obj-$(CONFIG_FS_ENET) += fs_enet/
 
 obj-$(CONFIG_NETXEN_NIC) += netxen/
+obj-$(CONFIG_RAETH) += raeth/
--- a/drivers/net/raeth/Makefile
+++ b/drivers/net/raeth/Makefile
@@ -7,20 +7,6 @@
 raeth-objs += ra_qos.o
 endif
 
-ifeq ($(CONFIG_ETHTOOL),y)
-ifeq ($(CONFIG_RAETH_ROUTER),y)
-raeth-objs += ra_ethtool.o
-else
-ifeq ($(CONFIG_RT_3052_ESW),y)
-raeth-objs += ra_ethtool.o
-else
-ifeq ($(CONFIG_RALINK_RT3883),y)
-raeth-objs += ra_ethtool.o
-endif
-endif
-endif
-endif
-
 ifeq ($(CONFIG_RALINK_RT3052_MP2),y)
 raeth-objs += mcast.o
 endif
--- a/drivers/net/raeth/ra2882ethreg.h
+++ b/drivers/net/raeth/ra2882ethreg.h
@@ -108,9 +108,6 @@
     struct net_device *RaethDev;
     struct net_device *PseudoDev;
     struct net_device_stats stat;
-#if defined (CONFIG_ETHTOOL)
-	struct mii_if_info	mii_info;
-#endif
 
 } PSEUDO_ADAPTER, PPSEUDO_ADAPTER;
 
@@ -698,9 +695,6 @@
     struct net_device *PseudoDev;
     unsigned int isPseudo;
 #endif
-#if defined (CONFIG_ETHTOOL)
-	struct mii_if_info	mii_info;
-#endif
 } END_DEVICE, *pEND_DEVICE;
 
 #define RAETH_VERSION	"v2.0"
